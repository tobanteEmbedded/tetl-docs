<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: etl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tetl
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceetl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">etl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceetl_1_1chrono"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1chrono.html">chrono</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1literals_1_1chrono__literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html">chrono_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1linalg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1linalg.html">linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals.html">literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1numbers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1numbers.html">numbers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1placeholders"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1ranges"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1ranges.html">ranges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1simd__abi"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1simd__abi.html">simd_abi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1literals_1_1string__view__literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1string__view__literals.html">string_view_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array is a container that encapsulates fixed size arrays.  <a href="structetl_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01array_3_01T_00_01N_01_4_01_4.html">tuple_size&lt; array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the number of elements in an array as a compile-time constant expression.  <a href="structetl_1_1tuple__size_3_01array_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element.html">tuple_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the type of the elements of the array using tuple-like interface.  <a href="structetl_1_1tuple__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01array_3_01T_00_01N_01_4_01_4.html">tuple_element&lt; I, array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1empty__c__array.html">empty_c_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1dynamic__array.html">dynamic_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uninitialized__array.html">uninitialized_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bitset.html">bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators.  <a href="structetl_1_1bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1assert__msg.html">assert_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Payload for an assertion.  <a href="structetl_1_1assert__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1binary__t.html">binary_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1half.html">half</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive numerical input conversion.  <a href="structetl_1_1from__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive numerical output conversion.  <a href="structetl_1_1to__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01chrono_1_1durat4fc2dee09f301ff098a97ea2485d2b03.html">common_type&lt; chrono::duration&lt; Rep1, Period1 &gt;, chrono::duration&lt; Rep2, Period2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes the type named type, which is the common type of two etl::chrono::durations, whose period is the greatest common divisor of Period1 and Period2.  <a href="structetl_1_1common__type_3_01chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01chrono_1_1durat4fc2dee09f301ff098a97ea2485d2b03.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01chrono_1_1time__point_3_01Clock_00_01Duration1_01_4_00_01chrono_1_ca83745423d4bfe5bc518c116bc7e175.html">common_type&lt; chrono::time_point&lt; Clock, Duration1 &gt;, chrono::time_point&lt; Clock, Duration2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes the type named type, which is the common type of two chrono::time_points.  <a href="structetl_1_1common__type_3_01chrono_1_1time__point_3_01Clock_00_01Duration1_01_4_00_01chrono_1_ca83745423d4bfe5bc518c116bc7e175.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__comparison__category.html">common_comparison_category</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1compare__three__way__result.html">compare_three_way_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1compare__three__way__result_3_01T_00_01U_01_4.html">compare_three_way_result&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1strong__ordering.html">strong_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1weak__ordering.html">weak_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1complex.html">complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A complex number.  <a href="structetl_1_1complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01etl_1_1complex_3_01T_01_4_01_4.html">tuple_size&lt; etl::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1max__align__t.html">max_align_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1max__align__t.html" title="etl::max_align_t is a trivial standard-layout type whose alignment requirement is at least as strict ...">etl::max_align_t</a> is a trivial standard-layout type whose alignment requirement is at least as strict (as large) as that of every scalar type.  <a href="structetl_1_1max__align__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tm.html">tm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1div__t.html">div_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1div__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1imaxdiv__t.html">imaxdiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1imaxdiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1ldiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1lldiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1timespec.html">timespec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1exception.html">exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1expected.html">expected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unexpect__t.html">unexpect_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unexpected.html">unexpected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1flat__set.html">flat_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a> is a container adaptor that provides an associative container interface that supports unique keys (contains at most one of each key value) and provides for fast retrieval of the keys themselves. <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a> supports random access iterators. Any sequence container supporting random access iteration can be used to instantiate <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a>.  <a href="structetl_1_1flat__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__arg.html">basic_format_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter.html">formatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The enabled specializations of formatter define formatting rules for a given type. Enabled specializations meet the Formatter requirements.  <a href="structetl_1_1formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to formatting state consisting of the formatting arguments and the output iterator.  <a href="structetl_1_1basic__format__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1format__to__n__result.html" title="etl::format_to_n_result has no base classes, or members other than out, size and implicitly declared ...">etl::format_to_n_result</a> has no base classes, or members other than out, size and implicitly declared special member functions.  <a href="structetl_1_1format__to__n__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_00_01char_01_4.html">formatter&lt; char, char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard specializations for basic type char.  <a href="structetl_1_1formatter_3_01char_00_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_01const_01_5_00_01char_01_4.html">formatter&lt; char const *, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_0fN_0e_00_01char_01_4.html">formatter&lt; char[N], char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01etl_1_1string__view_00_01char_01_4.html">formatter&lt; etl::string_view, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01etl_1_1static__string_3_01Capacity_01_4_00_01char_01_4.html">formatter&lt; etl::static_string&lt; Capacity &gt;, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01short_00_01char_01_4.html">formatter&lt; short, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01int_00_01char_01_4.html">formatter&lt; int, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01long_00_01char_01_4.html">formatter&lt; long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01long_01long_00_01char_01_4.html">formatter&lt; long long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01short_00_01char_01_4.html">formatter&lt; unsigned short, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_00_01char_01_4.html">formatter&lt; unsigned, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01long_00_01char_01_4.html">formatter&lt; unsigned long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01long_01long_00_01char_01_4.html">formatter&lt; unsigned long long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__and.html">bit_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise AND. Effectively calls operator&amp; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/bit_and">https://en.cppreference.com/w/cpp/utility/functional/bit_and</a>.  <a href="structetl_1_1bit__and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__and_3_01void_01_4.html">bit_and&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__not.html">bit_not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise NOT. Effectively calls operator~ on type T.  <a href="structetl_1_1bit__not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__not_3_01void_01_4.html">bit_not&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__or.html">bit_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise OR. Effectively calls operator| on type T.  <a href="structetl_1_1bit__or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__or_3_01void_01_4.html">bit_or&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__xor.html">bit_xor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise XOR. Effectively calls operator^ on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/bit_xor">https://en.cppreference.com/w/cpp/utility/functional/bit_xor</a>.  <a href="structetl_1_1bit__xor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__xor_3_01void_01_4.html">bit_xor&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__searcher.html">default_searcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default searcher. A class suitable for use with Searcher overload of <a class="el" href="namespaceetl.html#af39a57bc56c6f3c0bf94045777e9f274" title="Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range [first,...">etl::search</a> that delegates the search operation to the pre-C++17 standard library's <a class="el" href="namespaceetl.html#af39a57bc56c6f3c0bf94045777e9f274" title="Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range [first,...">etl::search</a>.  <a href="structetl_1_1default__searcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1divides.html">divides</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing division. Effectively calls operator/ on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/divides">https://en.cppreference.com/w/cpp/utility/functional/divides</a>.  <a href="structetl_1_1divides.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1divides_3_01void_01_4.html">divides&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1equal__to.html">equal_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator== on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/equal_to">https://en.cppreference.com/w/cpp/utility/functional/equal_to</a>.  <a href="structetl_1_1equal__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1equal__to_3_01void_01_4.html">equal_to&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1function__ref.html">function_ref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1function__ref_3_01R_07Args_8_8_8_08_4.html">function_ref&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning view of a callable.  <a href="structetl_1_1function__ref_3_01R_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater.html">greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/greater">https://en.cppreference.com/w/cpp/utility/functional/greater</a>.  <a href="structetl_1_1greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater_3_01void_01_4.html">greater&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater__equal.html">greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt;= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/greater_equal">https://en.cppreference.com/w/cpp/utility/functional/greater_equal</a>.  <a href="structetl_1_1greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater__equal_3_01void_01_4.html">greater_equal&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash  <a href="structetl_1_1hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01bool_01_4.html">hash&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char_01_4.html">hash&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01signed_01char_01_4.html">hash&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01char_01_4.html">hash&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char8__t_01_4.html">hash&lt; char8_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char16__t_01_4.html">hash&lt; char16_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char32__t_01_4.html">hash&lt; char32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01wchar__t_01_4.html">hash&lt; wchar_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01short_01_4.html">hash&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01short_01_4.html">hash&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01int_01_4.html">hash&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01int_01_4.html">hash&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01_4.html">hash&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01long_01_4.html">hash&lt; long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01long_01_4.html">hash&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01long_01long_01_4.html">hash&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01float_01_4.html">hash&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01double_01_4.html">hash&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01double_01_4.html">hash&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01etl_1_1nullptr__t_01_4.html">hash&lt; etl::nullptr_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01T_01_5_01_4.html">hash&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1identity.html" title="etl::identity is a function object type whose operator() returns its argument unchanged.">etl::identity</a> is a function object type whose operator() returns its argument unchanged.  <a href="structetl_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__function__call.html">bad_function_call</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__function_3_01R_07Args_8_8_8_08_00_01Capacity_00_01Alignment_01_4.html">inplace_function&lt; R(Args...), Capacity, Alignment &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less.html">less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/less">https://en.cppreference.com/w/cpp/utility/functional/less</a>.  <a href="structetl_1_1less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less_3_01void_01_4.html">less&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less__equal.html">less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt;= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/less_equal">https://en.cppreference.com/w/cpp/utility/functional/less_equal</a>.  <a href="structetl_1_1less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less__equal_3_01void_01_4.html">less_equal&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__and.html">logical_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical AND (logical conjunction). Effectively calls operator&amp;&amp; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_and">https://en.cppreference.com/w/cpp/utility/functional/logical_and</a>.  <a href="structetl_1_1logical__and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__and_3_01void_01_4.html">logical_and&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__not.html">logical_not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical NOT (logical negation). Effectively calls operator! for type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_not">https://en.cppreference.com/w/cpp/utility/functional/logical_not</a>.  <a href="structetl_1_1logical__not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__not_3_01void_01_4.html">logical_not&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__or.html">logical_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical OR (logical disjunction). Effectively calls operator|| on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_or">https://en.cppreference.com/w/cpp/utility/functional/logical_or</a>.  <a href="structetl_1_1logical__or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__or_3_01void_01_4.html">logical_or&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1minus.html">minus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing subtraction. Effectively calls operator- on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/minus">https://en.cppreference.com/w/cpp/utility/functional/minus</a>.  <a href="structetl_1_1minus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1minus_3_01void_01_4.html">minus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1modulus.html">modulus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for computing remainders of divisions. Implements operator% for type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/modulus">https://en.cppreference.com/w/cpp/utility/functional/modulus</a>.  <a href="structetl_1_1modulus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1modulus_3_01void_01_4.html">modulus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1multiplies.html">multiplies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing multiplication. Effectively calls operator* on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/multiplies">https://en.cppreference.com/w/cpp/utility/functional/multiplies</a>.  <a href="structetl_1_1multiplies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1multiplies_3_01void_01_4.html">multiplies&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negate.html">negate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing negation. Effectively calls operator- on an instance of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/negate">https://en.cppreference.com/w/cpp/utility/functional/negate</a>.  <a href="structetl_1_1negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negate_3_01void_01_4.html">negate&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1not__equal__to.html">not_equal_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator!= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/not_equal_to">https://en.cppreference.com/w/cpp/utility/functional/not_equal_to</a>.  <a href="structetl_1_1not__equal__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1not__equal__to_3_01void_01_4.html">not_equal_to&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_placeholder&lt; detail::placeholder_type&lt; N &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01const_01_4.html">is_placeholder&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01volatile_01_4.html">is_placeholder&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01const_01volatile_01_4.html">is_placeholder&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1plus.html">plus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing addition. Effectively calls operator+ on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/plus">https://en.cppreference.com/w/cpp/utility/functional/plus</a>.  <a href="structetl_1_1plus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1plus_3_01void_01_4.html">plus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">etl::static_vector</a>) which cannot normally hold references. Specifically, <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is a CopyConstructible and CopyAssignable wrapper around a reference to object or reference to function of type T. Instances of <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> are objects (they can be copied or stored in containers) but they are implicitly convertible to T&amp;, so that they can be used as arguments with the functions that take the underlying type by reference. If the stored reference is Callable, <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is callable with the same arguments.  <a href="structetl_1_1reference__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__vector.html">inplace_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__vector_3_01T_00_010_01_4.html">inplace_vector&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__streambuf.html">basic_streambuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__stringbuf.html">basic_stringbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bitmask_type&lt; detail::openmode_type &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bitmask_type&lt; detail::fmtflags_type &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bitmask_type&lt; detail::iostate_type &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ios__base.html">ios_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits.html">char_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class is a traits class template that abstracts basic character and string operations for a given character type. The defined operation set is such that generic algorithms almost always can be implemented in terms of it. It is thus possible to use such algorithms with almost any possible character or string type, just by supplying a customized <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class. The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class template serves as a basis for explicit instantiations. The user can provide a specialization for any custom character types. Several specializations are defined for the standard character types. If an operation on traits emits an exception, the behavior is undefined.  <a href="structetl_1_1char__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a LegacyOutputIterator that appends to a container for which it was constructed. The container's push_back() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a no-op.  <a href="structetl_1_1back__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> is an LegacyOutputIterator that prepends elements to a container for which it was constructed. The container's push_front() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> is a no-op.  <a href="structetl_1_1front__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits.html">incrementable_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01const_01_4.html">incrementable_traits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01_5_01_4.html">incrementable_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01_4.html">incrementable_traits&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits.html">indirectly_readable_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01const_01_4.html">indirectly_readable_traits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01_5_01_4.html">indirectly_readable_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01I_01_4.html">indirectly_readable_traits&lt; I &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01_4.html">indirectly_readable_traits&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1iterator__traits.html" title="iterator_traits is the type trait class that provides uniform interface to the properties of LegacyIt...">iterator_traits</a> is the type trait class that provides uniform interface to the properties of LegacyIterator types. This makes it possible to implement algorithms only in terms of iterators.  <a href="structetl_1_1iterator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1iterator__traits_3_01T_01_5_01_4.html">iterator_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">reverse_iterator</a> is an iterator adaptor that reverses the direction of a given iterator. In other words, when provided with a bidirectional iterator, <code><a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">reverse_iterator</a></code> produces a new iterator that moves from the end to the beginning of the sequence defined by the underlying bidirectional iterator. This is the iterator returned by member functions <code><a class="el" href="namespaceetl.html#a31aadf1fc327da2eaac11d7e6e8617a8" title="Returns an iterator to the reverse-beginning of the given container.">rbegin()</a></code> and <code><a class="el" href="namespaceetl.html#a3db12aaf2a7b1819d28995d635d91954" title="Returns an iterator to the reverse-end of the given container.">rend()</a></code> of the standard library containers.  <a href="structetl_1_1reverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1input__iterator__tag.html">input_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1input__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1output__iterator__tag.html">output_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1output__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1forward__iterator__tag.html">forward_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1forward__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1bidirectional__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1random__access__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1contiguous__iterator__tag.html">contiguous_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1contiguous__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits.html">numeric_limits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01bool_01_4.html">numeric_limits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01char_01_4.html">numeric_limits&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01signed_01char_01_4.html">numeric_limits&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01char_01_4.html">numeric_limits&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01char8__t_01_4.html">numeric_limits&lt; char8_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01short_01_4.html">numeric_limits&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01short_01_4.html">numeric_limits&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01int_01_4.html">numeric_limits&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01int_01_4.html">numeric_limits&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01long_01_4.html">numeric_limits&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01long_01_4.html">numeric_limits&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01float_01_4.html">numeric_limits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01double_01_4.html">numeric_limits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01long_01double_01_4.html">numeric_limits&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01const_01_4.html">numeric_limits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01volatile_01_4.html">numeric_limits&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01const_01volatile_01_4.html">numeric_limits&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1mdarray.html">mdarray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__accessor.html">default_accessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extents.html">extents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1full__extent__t.html">full_extent_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__left.html">layout_left</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__right.html">layout_right</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__stride.html">layout_stride</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1mdspan.html">mdspan</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1strided__slice.html">strided_slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1submdspan__mapping__result.html">submdspan_mapping_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> is an empty class type used to disambiguate the overloads of constructors and member functions of allocator-aware objects.  <a href="structetl_1_1allocator__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1allocator__traits.html">allocator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__delete.html">default_delete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__delete_3_01T_0f_0e_4.html">default_delete&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1monotonic__allocator.html">monotonic_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__int__pair.html">pointer_int_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct implements a pair of a pointer and small integer. It is designed to represent this in the space required by one pointer by bitmangling the integer into the low part of the pointer. This can only be done for small integers: typically up to 3 bits, but it depends on the number of bits available according to <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for the type.  <a href="structetl_1_1pointer__int__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01pointer__int__pair_3_01PtrT_00_01IntBits_00_01IntT_00_01PtrTraits_01_4_01_4.html">pointer_like_traits&lt; pointer_int_pair&lt; PtrT, IntBits, IntT, PtrTraits &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__int__pair__info.html">pointer_int_pair_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits.html">pointer_like_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits type that is used to handle pointer types and things that are just wrappers for pointers as a uniform entity.  <a href="structetl_1_1pointer__like__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01_5_01_4.html">pointer_like_traits&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for non-cvr pointers.  <a href="structetl_1_1pointer__like__traits_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01const_01_4.html">pointer_like_traits&lt; T const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for const things.  <a href="structetl_1_1pointer__like__traits_3_01T_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01const_01_5_01_4.html">pointer_like_traits&lt; T const * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for const pointers.  <a href="structetl_1_1pointer__like__traits_3_01T_01const_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01uintptr__t_01_4.html">pointer_like_traits&lt; uintptr_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for uintptr_t.  <a href="structetl_1_1pointer__like__traits_3_01uintptr__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__traits.html">pointer_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1pointer__traits.html" title="The pointer_traits class template provides the standardized way to access certain properties of point...">pointer_traits</a> class template provides the standardized way to access certain properties of pointer-like types.  <a href="structetl_1_1pointer__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__traits_3_01T_01_5_01_4.html">pointer_traits&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1pointer__traits.html" title="The pointer_traits class template provides the standardized way to access certain properties of point...">pointer_traits</a> class template provides the standardized way to access certain properties of pointer-like types. <a href="https://en.cppreference.com/w/cpp/memory/pointer_traits">https://en.cppreference.com/w/cpp/memory/pointer_traits</a>.  <a href="structetl_1_1pointer__traits_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1small__ptr.html">small_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed pointer to specified size. Intended to be used as a drop in replacement for native pointers.  <a href="structetl_1_1small__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false.  <a href="structetl_1_1uses__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1lock__guard.html">lock_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> is a mutex wrapper that provides a convenient RAII-style mechanism for owning a mutex for the duration of a scoped block. When a <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> object was created, the <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> is destructed and the mutex is released. The <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> struct is non-copyable.  <a href="structetl_1_1lock__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1defer__lock__t.html">defer_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1defer__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1try__to__lock__t.html">try_to_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1try__to__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1adopt__lock__t.html">adopt_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1adopt__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unique__lock.html">unique_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">unique_lock</a> is a general-purpose mutex ownership wrapper allowing deferred locking, time-constrained attempts at locking, recursive locking, transfer of lock ownership, and use with condition variables.  <a href="structetl_1_1unique__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type used to identify the destroying delete form of operator delete.  <a href="structetl_1_1destroying__delete__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nothrow__t.html">nothrow_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> is an empty class type used to disambiguate the overloads of throwing and non-throwing allocation functions.  <a href="structetl_1_1nothrow__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__optional__access.html">bad_optional_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a type of object to be thrown by <a class="el" href="structetl_1_1optional.html#acd491ba0eadd7e069af95df1e99d591d" title="If *this contains a value, returns a reference to the contained value. Otherwise, raises a etl::bad_o...">etl::optional::value</a> when accessing an optional object that does not contain a value.  <a href="structetl_1_1bad__optional__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">etl::nullopt_t</a> is an empty class type used to indicate optional type with uninitialized state. In particular, <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a> has a constructor with <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">nullopt_t</a> as a single argument, which creates an optional that does not contain a value.  <a href="structetl_1_1nullopt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template optional manages an optional contained value, i.e. a value that may or may not be present.  <a href="structetl_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1optional_3_01T_01_6_01_4.html">optional&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01etl_1_1optional_3_01T_01_4_01_4.html">hash&lt; etl::optional&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template specialization of <a class="el" href="structetl_1_1hash.html" title="hash">etl::hash</a> for the <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a> class allows users to obtain hashes of the values contained in optional objects.  <a href="structetl_1_1hash_3_01etl_1_1optional_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bernoulli__distribution.html">bernoulli_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uniform__int__distribution.html">uniform_int_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uniform__real__distribution.html">uniform_real_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xorshift.html">xorshift</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128plus.html">xoshiro128plus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128plusplus.html">xoshiro128plusplus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128starstar.html">xoshiro128starstar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio.html">ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The typename template provides compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number as long as its numerator Num and denominator Denom are representable as compile-time constants of type intmax_t.  <a href="structetl_1_1ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__equal.html">ratio_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are equal, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__greater__equal.html">ratio_greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__less.html">ratio_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are not equal, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__not__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1scope__exit.html">scope_exit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <code><a class="el" href="structetl_1_1scope__exit.html" title="The class template scope_exit is a general-purpose scope guard intended to call its exit function whe...">scope_exit</a></code> is a general-purpose scope guard intended to call its exit function when a scope is exited.  <a href="structetl_1_1scope__exit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html">static_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1static__set.html" title="static_set is an associative container that contains a sorted set of unique objects of type Key....">static_set</a> is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare.  <a href="structetl_1_1static__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1element__aligned__tag.html">element_aligned_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1vector__aligned__tag.html">vector_aligned_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1overaligned__tag.html">overaligned_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1const__where__expression.html">const_where_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1where__expression.html">where_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning view over a contiguous sequence of objects.  <a href="structetl_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1stack.html">stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stack class is a container adapter that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.  <a href="structetl_1_1stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1domain__error.html">domain_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1invalid__argument.html">invalid_argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1length__error.html">length_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logic__error.html">logic_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1out__of__range.html">out_of_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1overflow__error.html">overflow_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1range__error.html">range_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1runtime__error.html">runtime_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1underflow__error.html">underflow_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> class with fixed size capacity.  <a href="structetl_1_1basic__static__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html">char_traits&lt; char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char.  <a href="structetl_1_1char__traits_3_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01wchar__t_01_4.html">char_traits&lt; wchar_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1string__constant.html">string_constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <a class="el" href="structetl_1_1basic__string__view.html" title="The class template basic_string_view describes an object that can refer to a constant contiguous sequ...">basic_string_view</a> describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. A typical implementation holds only two members: a pointer to constant CharType and a size.  <a href="structetl_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__error__condition__enum_3_01errc_01_4.html">is_error_condition_enum&lt; errc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__error__condition__enum.html">is_error_condition_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ignore.html">ignore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with <a class="el" href="namespaceetl.html#ada3ddae955d45b6a63298906227f2f60">etl::tie</a> when unpacking a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>, as a placeholder for the arguments that are not used.  <a href="structetl_1_1ignore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple.html">tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01tuple_3_01Ts_8_8_8_01_4_01_4.html">tuple_element&lt; I, tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01tuple_3_01Ts_8_8_8_01_4_01_4.html">tuple_size&lt; tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01const_01_4.html">tuple_element&lt; I, T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01volatile_01_4.html">tuple_element&lt; I, T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01const_01volatile_01_4.html">tuple_element&lt; I, T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size.html">tuple_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01const_01_4.html">tuple_size&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01volatile_01_4.html">tuple_size&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01const_01volatile_01_4.html">tuple_size&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__const.html">add_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds const.  <a href="structetl_1_1add__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__cv.html">add_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds both const and volatile.  <a href="structetl_1_1add__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__lvalue__reference.html">add_lvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a lvalue reference type of T.  <a href="structetl_1_1add__lvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__pointer.html">add_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type, then provides the member typedef type which is a pointer to the referred type. Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef type which is the type T*. Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef type which is the type T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1add__pointer.html" title="If T is a reference type, then provides the member typedef type which is a pointer to the referred ty...">add_pointer</a> is undefined.  <a href="structetl_1_1add__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__rvalue__reference.html">add_rvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rvalue reference type of T.  <a href="structetl_1_1add__rvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__volatile.html">add_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds volatile.  <a href="structetl_1_1add__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1aligned__storage.html">aligned_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a trivial standard-layout type suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align. The default value of Align is the most stringent (the largest) alignment requirement for any object whose size is at most Len. If the default value is not used, Align must be the value of alignof(T) for some type T, or the behavior is undefined.  <a href="structetl_1_1aligned__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1aligned__union.html">aligned_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitable for use as uninitialized storage for an object of any of the types listed in Types. The size of the storage is at least Len. <a class="el" href="structetl_1_1aligned__union.html" title="Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitab...">aligned_union</a> also determines the strictest (largest) alignment requirement among all Types and makes it available as the constant alignment_value. If sizeof...(Types) == 0 or if any of the types in Types is not a complete object type, the behavior is undefined. It is implementation-defined whether any extended alignment is supported. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1aligned__union.html" title="Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitab...">aligned_union</a> is undefined.  <a href="structetl_1_1aligned__union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1alignment__of.html">alignment_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1alignment__of.html" title="alignment_of">alignment_of</a>  <a href="structetl_1_1alignment__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__common__reference.html">basic_common_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <a class="el" href="structetl_1_1basic__common__reference.html" title="The class template basic_common_reference is a customization point that allows users to influence the...">basic_common_reference</a> is a customization point that allows users to influence the result of <a class="el" href="structetl_1_1common__reference.html" title="Determines the common reference type of the types T..., that is, the type to which all the types in T...">common_reference</a> for user-defined types (typically proxy references). The primary template is empty.  <a href="structetl_1_1basic__common__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference.html">common_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the common reference type of the types T..., that is, the type to which all the types in T... can be converted or bound. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type. The behavior is undefined if any of the types in T... is an incomplete type other than (possibly cv-qualified) void.  <a href="structetl_1_1common__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_4.html">common_reference&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_01T_01_4.html">common_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_01T_00_01U_01_4.html">common_reference&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type.html">common_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the common type among all types <code>T...</code>, that is the type all <code>T...</code> can be implicitly converted to. If such a type exists, the member type names that type. Otherwise, there is no member type.  <a href="structetl_1_1common__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T_01_4.html">common_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_01_4.html">common_type&lt; T1, T2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_00_01R_8_8_8_01_4.html">common_type&lt; T1, T2, R... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional.html">conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false.  <a href="structetl_1_1conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional_3_01false_00_01T_00_01F_01_4.html">conditional&lt; false, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conjunction.html">conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical conjunction of the type traits B..., effectively performing a logical AND on the sequence of traits.  <a href="structetl_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1decay.html">decay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type T, removes cv-qualifiers, and defines the resulting type as the member typedef type.  <a href="structetl_1_1decay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__void.html">is_void</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1is__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__integral.html">is_integral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a floating-point type. Provides the member constant value which is equal to true, if T is the type float, double, long double, including any cv-qualified variants. Otherwise, value is equal to false.  <a href="structetl_1_1is__floating__point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array.html">is_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type. Provides the member constant value which is equal to true, if T is an array type. Otherwise, value is equal to false.  <a href="structetl_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__pointer.html">is_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a pointer to object or a pointer to function (but not a pointer to member/member function). Provides the member constant value which is equal to true, if T is a object/function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a lvalue reference type. Provides the member constant value which is equal to true, if T is a lvalue reference type. Otherwise, value is equal to false.  <a href="structetl_1_1is__lvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a rvalue reference type. Provides the member constant value which is equal to true, if T is a rvalue reference type. Otherwise, value is equal to false.  <a href="structetl_1_1is__rvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member object pointer. Provides the member constant value which is equal to true, if T is a non-static member object pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__object__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member function pointer. Provides the member constant value which is equal to true, if T is a non-static member function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__enum.html">is_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__union.html">is_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__typename.html">is_typename</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__function.html">is_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference.html">is_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type (lvalue reference or rvalue reference), provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__reference.html" title="If T is a reference type (lvalue reference or rvalue reference), provides the member constant value e...">is_reference</a> or is_reference_v is undefined.  <a href="structetl_1_1is__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__arithmetic.html" title="If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified ver...">is_arithmetic</a> or is_arithmetic_v (since C++17) is undefined.  <a href="structetl_1_1is__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a fundamental type (that is, arithmetic type, void, or nullptr_t), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__fundamental.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__object.html">is_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an object type (that is any possibly cv-qualified type other than function, reference, or void types), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scalar.html">is_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a scalar type (that is a possibly cv-qualified arithmetic, pointer, pointer to member, enumeration, or <a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> type), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__compound.html">is_compound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__compound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__member__pointer.html" title="If T is pointer to non-static member object or a pointer to non-static member function,...">is_member_pointer</a> or is_member_pointer_v (since C++17) is undefined.  <a href="structetl_1_1is__member__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1disjunction.html">disjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical disjunction of the type traits B..., effectively performing a logical OR on the sequence of traits.  <a href="structetl_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1enable__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if_3_01true_00_01Type_01_4.html">enable_if&lt; true, Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent.html">extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array type, provides the member constant value equal to the number of elements along the Nth dimension of the array, if N is in [0, rank_v&lt;T&gt;). For any other type, or if T is an array of unknown bound along its first dimension and N is 0, value is 0.  <a href="structetl_1_1extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0f_0e_00_010_01_4.html">extent&lt; T[], 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0f_0e_00_01N_01_4.html">extent&lt; T[], N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0fI_0e_00_010_01_4.html">extent&lt; T[I], 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0fI_0e_00_01N_01_4.html">extent&lt; T[I], N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is TriviallyCopyable and if any two objects of type T with the same value have the same object representation, provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1has__unique__object__representations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1has__virtual__destructor.html">has_virtual_destructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a>  <a href="structetl_1_1has__virtual__destructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1invoke__result.html">invoke_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the return type of an INVOKE expression at compile time. F and all types in ArgTypes can be any complete type, array of unknown bound, or (possibly cv-qualified) void. The behavior of a program that adds specializations for any of the templates described on this page is undefined. This implementation is copied from <b>cppreference.com</b>.  <a href="structetl_1_1invoke__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__abstract.html">is_abstract</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__aggregate.html">is_aggregate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__any__of.html">is_any_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T_0f_0e_4.html">is_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T_0fN_0e_4.html">is_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__assignable.html">is_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__base__of.html">is_base_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Derived is derived from Base or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__base__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bounded__array.html">is_bounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type of known bound. Provides the member constant value which is equal to true, if T is an array type of known bound. Otherwise, value is equal to false.  <a href="structetl_1_1is__bounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bounded__array_3_01T_0fN_0e_4.html">is_bounded_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__class.html">is_class</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const.html">is_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a const-qualified type (that is, const, or const volatile), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const_3_01T_01const_01_4.html">is_const&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__convertible.html">is_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the imaginary function definition <code>To test() { return <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;From&gt;(); }</code> is well-formed, (that is, either <code><a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;From&gt;()</code> can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true. Otherwise value is false. For the purposes of this check, the use of <code><a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a></code> in the return statement is not considered an odr-use. Access checks are performed as if from a context unrelated to either type. Only the validity of the immediate context of the expression in the return statement (including conversions to the return type) is considered.  <a href="structetl_1_1is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_constructible&lt;T, T const&amp;&gt;::value.  <a href="structetl_1_1is__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If etl::is_constructible&lt;T&gt;::value is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible.html">is_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because the C++ program terminates if a destructor throws an exception during stack unwinding (which usually cannot be predicted), all practical destructors are non-throwing even if they are not declared noexcept. All destructors found in the C++ standard library are non-throwing.  <a href="structetl_1_1is__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible_3_01Type_0f_0e_4.html">is_destructible&lt; Type[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible_3_01void_01_4.html">is_destructible&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__empty.html">is_empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f T is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__final.html">is_final</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a final class (that is, a class declared with the final specifier), provides the member constant value equal true. For any other type, value is false. If T is a class type, T shall be a complete type; otherwise, the behavior is undefined.  <a href="structetl_1_1is__final.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible_3_01T_00_01decltype_07test__implicit__default_63505ad1d5845f9b40fca2dabe8d3bef.html">is_implicit_default_constructible&lt; T, decltype(test_implicit_default_constructible&lt; T const &amp; &gt;({})), true_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible_3_01T_00_01decltype_07test__implicit__default_374fbed591f2848368bdbdd39f8c8e31.html">is_implicit_default_constructible&lt; T, decltype(test_implicit_default_constructible&lt; T const &amp; &gt;({})), false_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__invocable.html">is_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__lvalue__reference_3_01T_01_6_01_4.html">is_lvalue_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_constructible&lt;T, T&amp;&amp;&gt;::value.  <a href="structetl_1_1is__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__nothrow__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__assignable_3_01T_00_01U_01_4.html">is_nothrow_assignable&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__nothrow__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__convertible_3_01From_00_01To_01_4.html">is_nothrow_convertible&lt; From, To &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_nothrow_constructible&lt;T, T const&amp;&gt;.  <a href="structetl_1_1is__nothrow__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__nothrow__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/is_destructible">https://en.cppreference.com/w/cpp/types/is_destructible</a>  <a href="structetl_1_1is__nothrow__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_0fN_0e_4.html">is_nothrow_destructible&lt; Type[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_01_4.html">is_nothrow_destructible&lt; Type &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_6_01_4.html">is_nothrow_destructible&lt; Type &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_swappable_with&lt;T&amp;, T&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swap__no__throw.html">_swap_no_throw</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__swappable__with.html">is_nothrow_swappable_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__polymorphic.html">is_polymorphic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_01_4.html">is_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_6_01_4.html">is_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference__wrapper_3_01reference__wrapper_3_01U_01_4_01_4.html">is_reference_wrapper&lt; reference_wrapper&lt; U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__rvalue__reference_3_01T_01_6_6_01_4.html">is_rvalue_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same.html">is_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T and U name the same type (taking into account const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scoped__enum_3_01T_00_01true_01_4.html">is_scoped_enum&lt; T, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__signed.html">is_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(-1) &lt; T(0): this results in true for the floating-point types and the signed integer types, and in false for the unsigned integer types and the type bool. For any other type, value is false.  <a href="structetl_1_1is__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__specialized.html">is_specialized</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__specialized_3_01Template_00_01T_00_01etl_1_1void__t_3_01decltype_07Template_3_01T_01_4_02_03_08_4_01_4.html">is_specialized&lt; Template, T, etl::void_t&lt; decltype(Template&lt; T &gt;{})&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__standard__integer.html">is_standard_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__standard__layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__standard__signed__integer.html">is_standard_signed_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__standard__unsigned__integer.html">is_standard_unsigned_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__swappable.html">is_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_swappable_with&lt;T&amp;, T&amp;&gt;::value</a>.  <a href="structetl_1_1is__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swappable__with__helper.html">_swappable_with_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swappable__with__helper_3_01T_00_01U_00_01void__t_3_01decltype_07swap_07declval_3a85b88c6bbfa63467fd799de16a3d15b.html">_swappable_with_helper&lt; T, U, void_t&lt; decltype(swap(declval&lt; T &gt;(), declval&lt; U &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivial.html">is_trivial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is TrivialType (that is, a scalar type, a trivially copyable class with a trivial default constructor, or array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__trivial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__trivially__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__trivially__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_trivially_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_trivially_constructible&lt;T, T const&amp;&gt;.  <a href="structetl_1_1is__trivially__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copyable.html">is_trivially_copyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a TriviallyCopyable type, provides the member constant value equal to true. For any other type, value is false. The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly cv-qualified). group is_trivial_copyable.  <a href="structetl_1_1is__trivially__copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_trivially_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__trivially__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__destructible.html">is_trivially_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage occupied by trivially destructible objects may be reused without calling the destructor.  <a href="structetl_1_1is__trivially__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__move__constructible.html">is_trivially_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unbounded__array.html">is_unbounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type of unknown bound. Provides the member constant value which is equal to true, if T is an array type of unknown bound. Otherwise, value is equal to false.  <a href="structetl_1_1is__unbounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unbounded__array_3_01T_0f_0e_4.html">is_unbounded_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__unsigned.html" title="If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this re...">is_unsigned</a> or is_unsigned_v (since C++17) is undefined.  <a href="structetl_1_1is__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned_3_01T_01const_01_4.html">is_unsigned&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned_3_01T_01volatile_01_4.html">is_unsigned&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned_3_01T_01const_01volatile_01_4.html">is_unsigned&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__volatile.html">is_volatile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__volatile_3_01T_01volatile_01_4.html">is_volatile&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__signed.html">make_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__signed.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_signed</a> is undefined.  <a href="structetl_1_1make__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__unsigned.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_unsigned</a> is undefined.  <a href="structetl_1_1make__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negation.html">negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical negation of the type trait B.  <a href="structetl_1_1negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank.html">rank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Type is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0. The behavior of a program that adds specializations for rank or rank_v is undefined.  <a href="structetl_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T_0f_0e_4.html">rank&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T_0fN_0e_4.html">rank&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X,...">remove_all_extents</a> is undefined.  <a href="structetl_1_1remove__all__extents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents_3_01T_0f_0e_4.html">remove_all_extents&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents_3_01T_0fN_0e_4.html">remove_all_extents&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const.html">remove_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const.  <a href="structetl_1_1remove__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const_3_01Type_01const_01_4.html">remove_const&lt; Type const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cv.html">remove_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const, or the topmost volatile, or both, if present.  <a href="structetl_1_1remove__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cvref.html">remove_cvref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the type T is a reference type, provides the member typedef type which is the type referred to by T with its topmost cv-qualifiers removed. Otherwise type is T with its topmost cv-qualifiers removed.  <a href="structetl_1_1remove__cvref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent.html">remove_extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__extent.html" title="If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T....">remove_extent</a> is undefined.  <a href="structetl_1_1remove__extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T_0f_0e_4.html">remove_extent&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T_0fN_0e_4.html">remove_extent&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer.html">remove_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer, then type is the same as T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__pointer.html" title="Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer,...">remove_pointer</a> is undefined.  <a href="structetl_1_1remove__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5_01_4.html">remove_pointer&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01_4.html">remove_pointer&lt; T *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5volatile_01_4.html">remove_pointer&lt; T *volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01volatile_01_4.html">remove_pointer&lt; T *const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference.html">remove_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_01_4.html">remove_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_6_01_4.html">remove_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile.html">remove_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost volatile.  <a href="structetl_1_1remove__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile_3_01Type_01volatile_01_4.html">remove_volatile&lt; Type volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1type__identity.html">type_identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1type__pack__element.html">type_pack_element</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1underlying__type.html">underlying_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying type of an enum.  <a href="structetl_1_1underlying__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__reference.html">unwrap_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__reference_3_01etl_1_1reference__wrapper_3_01T_01_4_01_4.html">unwrap_reference&lt; etl::reference_wrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__ref__decay.html">unwrap_ref_decay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <code>optional</code>, <code>variant</code>, and <code>any</code> to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__index__t.html">in_place_index_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>, <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__index__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__type__t.html">in_place_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>, <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__type__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integer__sequence.html">integer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nontype__t.html">nontype_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pair.html">pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> is a class template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a> with two elements. If neither T1 nor T2 is a possibly cv-qualified class type with non-trivial destructor, or array thereof, the destructor of pair is trivial.  <a href="structetl_1_1pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html">tuple_size&lt; pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specialization of <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a> for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax.  <a href="structetl_1_1tuple__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01pair_3_01T1_00_01T2_01_4_01_4.html">tuple_element&lt; I, pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specializations of <a class="el" href="structetl_1_1tuple__element.html" title="Provides compile-time indexed access to the type of the elements of the array using tuple-like interf...">tuple_element</a> for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if I &gt;= 2.  <a href="structetl_1_1tuple__element_3_01I_00_01pair_3_01T1_00_01T2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a> is an empty class tag type used to disambiguate between different functions that take two tuple arguments.  <a href="structetl_1_1piecewise__construct__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__variant__access.html">bad_variant_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">etl::bad_variant_access</a> is the type of the exception thrown in the following situations: (1) etl::get(etl::variant) called with an index or type that does not match the currently active alternative. (2) <a class="el" href="namespaceetl.html#aa43fcb4942d4cec1824f6e38edce9981" title="Applies the visitor vis (Callable that can be called with any combination of types from variants) to ...">etl::visit</a> called to visit a variant that is valueless_by_exception  <a href="structetl_1_1bad__variant__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1monostate.html">monostate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit type intended for use as a well-behaved empty alternative in <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>. In particular, a variant of non-default-constructible types may list <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> as its first alternative: this makes the variant itself default-constructible.  <a href="structetl_1_1monostate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1overload.html">overload</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uninitialized__union.html">uninitialized_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionetl_1_1variadic__union.html">variadic_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionetl_1_1variadic__union_3_01T_00_01Ts_8_8_8_01_4.html">variadic_union&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant.html">variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template variant represents a type-safe union. An instance of variant at any given time either holds a value of one of its alternative types.  <a href="structetl_1_1variant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant2.html">variant2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01etl_1_1variant_3_01Ts_8_8_8_01_4_01_4.html">variant_alternative&lt; Idx, etl::variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01etl_1_1variant2_3_01Ts_8_8_8_01_4_01_4.html">variant_alternative&lt; Idx, etl::variant2&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01const_01_4.html">variant_alternative&lt; Idx, T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01volatile_01_4.html">variant_alternative&lt; Idx, T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01const_01volatile_01_4.html">variant_alternative&lt; Idx, T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size.html">variant_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative.  <a href="structetl_1_1variant__alternative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01variant_3_01Ts_8_8_8_01_4_01_4.html">variant_size&lt; variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01variant2_3_01Ts_8_8_8_01_4_01_4.html">variant_size&lt; variant2&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01const_01_4.html">variant_size&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01volatile_01_4.html">variant_size&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01const_01volatile_01_4.html">variant_size&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__vector.html">static_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically-resizable fixed-capacity vector.  <a href="structetl_1_1static__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a568b4df04642a2e727b3a8b201f2e450"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , etl::size_t Size&gt; </td></tr>
<tr class="memitem:a568b4df04642a2e727b3a8b201f2e450"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a568b4df04642a2e727b3a8b201f2e450">c_array</a> = ValueType[<a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a>]</td></tr>
<tr class="separator:a568b4df04642a2e727b3a8b201f2e450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04532556e568bb7cc276440befc7f441"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a04532556e568bb7cc276440befc7f441">float_t</a> = float</td></tr>
<tr class="memdesc:a04532556e568bb7cc276440befc7f441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most efficient floating-point type at least as wide as float.  <a href="namespaceetl.html#a04532556e568bb7cc276440befc7f441">More...</a><br /></td></tr>
<tr class="separator:a04532556e568bb7cc276440befc7f441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c91cfdd41de11ccf80532067354fe92"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9c91cfdd41de11ccf80532067354fe92">double_t</a> = double</td></tr>
<tr class="memdesc:a9c91cfdd41de11ccf80532067354fe92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most efficient floating-point type at least as wide as double.  <a href="namespaceetl.html#a9c91cfdd41de11ccf80532067354fe92">More...</a><br /></td></tr>
<tr class="separator:a9c91cfdd41de11ccf80532067354fe92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad206e673dfd2f8aa9800684c6734595c"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad206e673dfd2f8aa9800684c6734595c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad206e673dfd2f8aa9800684c6734595c">common_comparison_category_t</a> = typename <a class="el" href="structetl_1_1common__comparison__category.html">common_comparison_category</a>&lt; Ts... &gt;::type</td></tr>
<tr class="separator:ad206e673dfd2f8aa9800684c6734595c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076e8c592e28166b1126264966624b4b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = T&gt; </td></tr>
<tr class="memitem:a076e8c592e28166b1126264966624b4b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a076e8c592e28166b1126264966624b4b">compare_three_way_result_t</a> = decltype(<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt; <a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt; T &gt; const  &amp; &gt;()&lt;=&gt; <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt; <a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt; U &gt; const  &amp; &gt;())</td></tr>
<tr class="separator:a076e8c592e28166b1126264966624b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910e85d940ada86b5e325f3a16815963"><td class="memTemplParams" colspan="2">template&lt;unsigned long long N&gt; </td></tr>
<tr class="memitem:a910e85d940ada86b5e325f3a16815963"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a910e85d940ada86b5e325f3a16815963">smallest_size_t</a> = <a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">conditional_t</a>&lt;(N&lt; static_cast&lt; unsigned char &gt;(-1)), unsigned char, <a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">conditional_t</a>&lt;(N&lt; static_cast&lt; unsigned short &gt;(-1)), unsigned short, <a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">conditional_t</a>&lt;(N&lt; static_cast&lt; unsigned int &gt;(-1)), unsigned int, <a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">conditional_t</a>&lt;(N&lt; static_cast&lt; unsigned long &gt;(-1)), unsigned long, unsigned long long &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:a910e85d940ada86b5e325f3a16815963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest fixed-width unsigned integer type that can represent values in the range [0, N].  <a href="namespaceetl.html#a910e85d940ada86b5e325f3a16815963">More...</a><br /></td></tr>
<tr class="separator:a910e85d940ada86b5e325f3a16815963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4272f3f16bf2234ac8248db615f133"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">nullptr_t</a> = decltype(nullptr)</td></tr>
<tr class="memdesc:adf4272f3f16bf2234ac8248db615f133"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type.  <a href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">More...</a><br /></td></tr>
<tr class="separator:adf4272f3f16bf2234ac8248db615f133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955e0d5a5e84e9e394bf38a95c8ce380"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a955e0d5a5e84e9e394bf38a95c8ce380">ptrdiff_t</a> = <a class="el" href="builtin__types_8hpp.html#a19bfe4995271e67306bab6dc974ed002">TETL_BUILTIN_PTRDIFF</a></td></tr>
<tr class="memdesc:a955e0d5a5e84e9e394bf38a95c8ce380"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#a955e0d5a5e84e9e394bf38a95c8ce380" title="etl::ptrdiff_t is the signed integer type of the result of subtracting two pointers.">etl::ptrdiff_t</a> is the signed integer type of the result of subtracting two pointers.  <a href="namespaceetl.html#a955e0d5a5e84e9e394bf38a95c8ce380">More...</a><br /></td></tr>
<tr class="separator:a955e0d5a5e84e9e394bf38a95c8ce380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9671046b2e5aea5a45a7f12fecc9f911"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> = <a class="el" href="builtin__types_8hpp.html#ab236bea848bc390350ba3fc38ae07819">TETL_BUILTIN_SIZET</a></td></tr>
<tr class="memdesc:a9671046b2e5aea5a45a7f12fecc9f911"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> is the unsigned integer type of the result of the sizeof operator.  <a href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">More...</a><br /></td></tr>
<tr class="separator:a9671046b2e5aea5a45a7f12fecc9f911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2ed7b5d4c5b80c8000cdf5e85bcf5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abb2ed7b5d4c5b80c8000cdf5e85bcf5f">int_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:abb2ed7b5d4c5b80c8000cdf5e85bcf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <a href="namespaceetl.html#abb2ed7b5d4c5b80c8000cdf5e85bcf5f">More...</a><br /></td></tr>
<tr class="separator:abb2ed7b5d4c5b80c8000cdf5e85bcf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a65f3a332a5af06e36e13783ba42db3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3a65f3a332a5af06e36e13783ba42db3">int_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:a3a65f3a332a5af06e36e13783ba42db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <a href="namespaceetl.html#a3a65f3a332a5af06e36e13783ba42db3">More...</a><br /></td></tr>
<tr class="separator:a3a65f3a332a5af06e36e13783ba42db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177099d663b48f0f92b67ca7cbdf65c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a177099d663b48f0f92b67ca7cbdf65c3">int_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:a177099d663b48f0f92b67ca7cbdf65c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <a href="namespaceetl.html#a177099d663b48f0f92b67ca7cbdf65c3">More...</a><br /></td></tr>
<tr class="separator:a177099d663b48f0f92b67ca7cbdf65c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1150023b8ce4b5b4a8ea6a373e9b388"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab1150023b8ce4b5b4a8ea6a373e9b388">int_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:ab1150023b8ce4b5b4a8ea6a373e9b388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <a href="namespaceetl.html#ab1150023b8ce4b5b4a8ea6a373e9b388">More...</a><br /></td></tr>
<tr class="separator:ab1150023b8ce4b5b4a8ea6a373e9b388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e1f2b57192eb59d8896c3c5e3bb51d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a95e1f2b57192eb59d8896c3c5e3bb51d">int_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:a95e1f2b57192eb59d8896c3c5e3bb51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <a href="namespaceetl.html#a95e1f2b57192eb59d8896c3c5e3bb51d">More...</a><br /></td></tr>
<tr class="separator:a95e1f2b57192eb59d8896c3c5e3bb51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa91b645d41d579ad9d546b1696bac4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5aa91b645d41d579ad9d546b1696bac4">int_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:a5aa91b645d41d579ad9d546b1696bac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <a href="namespaceetl.html#a5aa91b645d41d579ad9d546b1696bac4">More...</a><br /></td></tr>
<tr class="separator:a5aa91b645d41d579ad9d546b1696bac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc620fcad636bc011a67f10a08fa104"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aecc620fcad636bc011a67f10a08fa104">int_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:aecc620fcad636bc011a67f10a08fa104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <a href="namespaceetl.html#aecc620fcad636bc011a67f10a08fa104">More...</a><br /></td></tr>
<tr class="separator:aecc620fcad636bc011a67f10a08fa104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668df81287b2fc3bec1db5bb30e1a68a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a668df81287b2fc3bec1db5bb30e1a68a">int_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:a668df81287b2fc3bec1db5bb30e1a68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <a href="namespaceetl.html#a668df81287b2fc3bec1db5bb30e1a68a">More...</a><br /></td></tr>
<tr class="separator:a668df81287b2fc3bec1db5bb30e1a68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74b36e22a5adda58be542d7c31f8109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab74b36e22a5adda58be542d7c31f8109">int8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:ab74b36e22a5adda58be542d7c31f8109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 8 bits.  <a href="namespaceetl.html#ab74b36e22a5adda58be542d7c31f8109">More...</a><br /></td></tr>
<tr class="separator:ab74b36e22a5adda58be542d7c31f8109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44df0d1723c3871b21fb46551504d4f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a44df0d1723c3871b21fb46551504d4f4">int16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:a44df0d1723c3871b21fb46551504d4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 16 bits.  <a href="namespaceetl.html#a44df0d1723c3871b21fb46551504d4f4">More...</a><br /></td></tr>
<tr class="separator:a44df0d1723c3871b21fb46551504d4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6647b6b071a7156c723345a83e838db7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6647b6b071a7156c723345a83e838db7">int32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:a6647b6b071a7156c723345a83e838db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 32 bits.  <a href="namespaceetl.html#a6647b6b071a7156c723345a83e838db7">More...</a><br /></td></tr>
<tr class="separator:a6647b6b071a7156c723345a83e838db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4158519b6c914f0112e3e0f9547e8710"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4158519b6c914f0112e3e0f9547e8710">int64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:a4158519b6c914f0112e3e0f9547e8710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 64 bits.  <a href="namespaceetl.html#a4158519b6c914f0112e3e0f9547e8710">More...</a><br /></td></tr>
<tr class="separator:a4158519b6c914f0112e3e0f9547e8710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04395ca65e067ae9f19def97c62af3ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a04395ca65e067ae9f19def97c62af3ce">intmax_t</a> = <a class="el" href="builtin__types_8hpp.html#ad8678dda9c4b939fee5244864c53ada1">TETL_BUILTIN_INTMAX</a></td></tr>
<tr class="memdesc:a04395ca65e067ae9f19def97c62af3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum-width signed integer type.  <a href="namespaceetl.html#a04395ca65e067ae9f19def97c62af3ce">More...</a><br /></td></tr>
<tr class="separator:a04395ca65e067ae9f19def97c62af3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74f9bed34c8c76ba2dfee118b63ac26"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac74f9bed34c8c76ba2dfee118b63ac26">intptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a021098c463419df8b156d80c9153387e">TETL_BUILTIN_INTPTR</a></td></tr>
<tr class="memdesc:ac74f9bed34c8c76ba2dfee118b63ac26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type capable of holding a pointer.  <a href="namespaceetl.html#ac74f9bed34c8c76ba2dfee118b63ac26">More...</a><br /></td></tr>
<tr class="separator:ac74f9bed34c8c76ba2dfee118b63ac26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77926b7a11780aa2676fc552c574ae7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad77926b7a11780aa2676fc552c574ae7">uint_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:ad77926b7a11780aa2676fc552c574ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <a href="namespaceetl.html#ad77926b7a11780aa2676fc552c574ae7">More...</a><br /></td></tr>
<tr class="separator:ad77926b7a11780aa2676fc552c574ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6412e0b86f8258a67d0cf3efc27f29ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6412e0b86f8258a67d0cf3efc27f29ca">uint_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:a6412e0b86f8258a67d0cf3efc27f29ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <a href="namespaceetl.html#a6412e0b86f8258a67d0cf3efc27f29ca">More...</a><br /></td></tr>
<tr class="separator:a6412e0b86f8258a67d0cf3efc27f29ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8231f2a890b4a057d999a9a7d88cf9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aae8231f2a890b4a057d999a9a7d88cf9">uint_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:aae8231f2a890b4a057d999a9a7d88cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <a href="namespaceetl.html#aae8231f2a890b4a057d999a9a7d88cf9">More...</a><br /></td></tr>
<tr class="separator:aae8231f2a890b4a057d999a9a7d88cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f7c13233dafa5cc0f8a3d49093ee1d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a26f7c13233dafa5cc0f8a3d49093ee1d">uint_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:a26f7c13233dafa5cc0f8a3d49093ee1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <a href="namespaceetl.html#a26f7c13233dafa5cc0f8a3d49093ee1d">More...</a><br /></td></tr>
<tr class="separator:a26f7c13233dafa5cc0f8a3d49093ee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db9185a6357a3e71a91491298e8690c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9db9185a6357a3e71a91491298e8690c">uint_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:a9db9185a6357a3e71a91491298e8690c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <a href="namespaceetl.html#a9db9185a6357a3e71a91491298e8690c">More...</a><br /></td></tr>
<tr class="separator:a9db9185a6357a3e71a91491298e8690c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2694291a7c796beec5cfe0c006f185e1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2694291a7c796beec5cfe0c006f185e1">uint_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:a2694291a7c796beec5cfe0c006f185e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <a href="namespaceetl.html#a2694291a7c796beec5cfe0c006f185e1">More...</a><br /></td></tr>
<tr class="separator:a2694291a7c796beec5cfe0c006f185e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b343e0347d929b0ff4d34d643f9cf9e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7b343e0347d929b0ff4d34d643f9cf9e">uint_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:a7b343e0347d929b0ff4d34d643f9cf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <a href="namespaceetl.html#a7b343e0347d929b0ff4d34d643f9cf9e">More...</a><br /></td></tr>
<tr class="separator:a7b343e0347d929b0ff4d34d643f9cf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9447a983a1474ce60b01aa33610d45e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af9447a983a1474ce60b01aa33610d45e">uint_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:af9447a983a1474ce60b01aa33610d45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <a href="namespaceetl.html#af9447a983a1474ce60b01aa33610d45e">More...</a><br /></td></tr>
<tr class="separator:af9447a983a1474ce60b01aa33610d45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4884330ffa7c8d259566d1344e12209"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae4884330ffa7c8d259566d1344e12209">uint8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:ae4884330ffa7c8d259566d1344e12209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 8 bits.  <a href="namespaceetl.html#ae4884330ffa7c8d259566d1344e12209">More...</a><br /></td></tr>
<tr class="separator:ae4884330ffa7c8d259566d1344e12209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07faf2c6165a6ec08c1d7ce7b59c70f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a07faf2c6165a6ec08c1d7ce7b59c70f9">uint16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:a07faf2c6165a6ec08c1d7ce7b59c70f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 16 bits.  <a href="namespaceetl.html#a07faf2c6165a6ec08c1d7ce7b59c70f9">More...</a><br /></td></tr>
<tr class="separator:a07faf2c6165a6ec08c1d7ce7b59c70f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cd8f569fbe5bbe1bc46988b146bf43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a45cd8f569fbe5bbe1bc46988b146bf43">uint32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:a45cd8f569fbe5bbe1bc46988b146bf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 32 bits.  <a href="namespaceetl.html#a45cd8f569fbe5bbe1bc46988b146bf43">More...</a><br /></td></tr>
<tr class="separator:a45cd8f569fbe5bbe1bc46988b146bf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75da701473a787f887fa0c35cb173588"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a75da701473a787f887fa0c35cb173588">uint64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:a75da701473a787f887fa0c35cb173588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 64 bits.  <a href="namespaceetl.html#a75da701473a787f887fa0c35cb173588">More...</a><br /></td></tr>
<tr class="separator:a75da701473a787f887fa0c35cb173588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd6bc49488600867f3af14e73936ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a91bd6bc49488600867f3af14e73936ff">uintmax_t</a> = <a class="el" href="builtin__types_8hpp.html#a64175350ea04c19125422816cd6184e1">TETL_BUILTIN_UINTMAX</a></td></tr>
<tr class="memdesc:a91bd6bc49488600867f3af14e73936ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum-width unsigned integer type.  <a href="namespaceetl.html#a91bd6bc49488600867f3af14e73936ff">More...</a><br /></td></tr>
<tr class="separator:a91bd6bc49488600867f3af14e73936ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1bda2cf8742dabfe32527f518cf5ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aef1bda2cf8742dabfe32527f518cf5ac">uintptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a3b013e093af0767d757a3606463295d9">TETL_BUILTIN_UINTPTR</a></td></tr>
<tr class="memdesc:aef1bda2cf8742dabfe32527f518cf5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type capable of holding a pointer.  <a href="namespaceetl.html#aef1bda2cf8742dabfe32527f518cf5ac">More...</a><br /></td></tr>
<tr class="separator:aef1bda2cf8742dabfe32527f518cf5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0eeae85a8a320c4b560b2c416d739a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aae0eeae85a8a320c4b560b2c416d739a">clock_t</a> = <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></td></tr>
<tr class="separator:aae0eeae85a8a320c4b560b2c416d739a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab825d27ed3dfbe0ed0a6d56ec8f43496"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab825d27ed3dfbe0ed0a6d56ec8f43496">time_t</a> = <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></td></tr>
<tr class="memdesc:ab825d27ed3dfbe0ed0a6d56ec8f43496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic type capable of representing times.  <a href="namespaceetl.html#ab825d27ed3dfbe0ed0a6d56ec8f43496">More...</a><br /></td></tr>
<tr class="separator:ab825d27ed3dfbe0ed0a6d56ec8f43496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242f9848c8ce5c281284bf133ce1bc94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> = unsigned int</td></tr>
<tr class="separator:a242f9848c8ce5c281284bf133ce1bc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fa9df1563f429e510c612727c974ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac9fa9df1563f429e510c612727c974ee">format_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt; <a class="el" href="namespaceetl.html#aa49c8d8025e0a5d18a2a0f3df0a3cc07">format_context</a> &gt;</td></tr>
<tr class="separator:ac9fa9df1563f429e510c612727c974ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b85be0c7f71b9b0958fd7cc39e35c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab4b85be0c7f71b9b0958fd7cc39e35c3">wformat_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt; <a class="el" href="namespaceetl.html#a7d6b3a02733a03dc5fb0cdcd3c1f7928">wformat_context</a> &gt;</td></tr>
<tr class="separator:ab4b85be0c7f71b9b0958fd7cc39e35c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49c8d8025e0a5d18a2a0f3df0a3cc07"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa49c8d8025e0a5d18a2a0f3df0a3cc07">format_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt; <a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt; detail::fmt_buffer&lt; char &gt; &gt;, char &gt;</td></tr>
<tr class="memdesc:aa49c8d8025e0a5d18a2a0f3df0a3cc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to formatting state consisting of the formatting arguments and the output iterator.  <a href="namespaceetl.html#aa49c8d8025e0a5d18a2a0f3df0a3cc07">More...</a><br /></td></tr>
<tr class="separator:aa49c8d8025e0a5d18a2a0f3df0a3cc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6b3a02733a03dc5fb0cdcd3c1f7928"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7d6b3a02733a03dc5fb0cdcd3c1f7928">wformat_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt; <a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt; detail::fmt_buffer&lt; wchar_t &gt; &gt;, wchar_t &gt;</td></tr>
<tr class="separator:a7d6b3a02733a03dc5fb0cdcd3c1f7928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b23ca440a5d368e5cdda4b322e9fe31"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4b23ca440a5d368e5cdda4b322e9fe31">format_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt; char &gt;</td></tr>
<tr class="separator:a4b23ca440a5d368e5cdda4b322e9fe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671044d4ad13b14eda4b8742ba2790e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a671044d4ad13b14eda4b8742ba2790e7">wformat_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:a671044d4ad13b14eda4b8742ba2790e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d893d90400b4bba35516d905e4c885"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a33d893d90400b4bba35516d905e4c885"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a33d893d90400b4bba35516d905e4c885">format_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt; char, <a class="el" href="namespaceetl.html#af53ccea3515493c555e3a764ffea8ff0">type_identity_t</a>&lt; Args &gt;... &gt;</td></tr>
<tr class="separator:a33d893d90400b4bba35516d905e4c885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ccd4d8cf9499a9b76b57a5a6a3c6d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af67ccd4d8cf9499a9b76b57a5a6a3c6d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af67ccd4d8cf9499a9b76b57a5a6a3c6d">wformat_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt; wchar_t, <a class="el" href="namespaceetl.html#af53ccea3515493c555e3a764ffea8ff0">type_identity_t</a>&lt; Args &gt;... &gt;</td></tr>
<tr class="separator:af67ccd4d8cf9499a9b76b57a5a6a3c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4d7671919f2ad18da41013ecd9dde4"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a0e4d7671919f2ad18da41013ecd9dde4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0e4d7671919f2ad18da41013ecd9dde4">diff_t</a> = typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; <a class="el" href="namespaceetl.html#ac0c34af472196537fb719bde6ab1c4ad">etl::remove_cvref_t</a>&lt; Iter &gt; &gt;::difference_type</td></tr>
<tr class="separator:a0e4d7671919f2ad18da41013ecd9dde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc35dfd838fd831b02bd53096097def"><td class="memTemplParams" colspan="2">template&lt;size_t Capacity&gt; </td></tr>
<tr class="memitem:a9bc35dfd838fd831b02bd53096097def"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9bc35dfd838fd831b02bd53096097def">stringbuf</a> = <a class="el" href="structetl_1_1basic__stringbuf.html">basic_stringbuf</a>&lt; char, Capacity &gt;</td></tr>
<tr class="separator:a9bc35dfd838fd831b02bd53096097def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc54c8127416c33c963bee08bc99596"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8cc54c8127416c33c963bee08bc99596">streamoff</a> = long</td></tr>
<tr class="separator:a8cc54c8127416c33c963bee08bc99596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a81fba06194ff9cf0d14e9dd9339a0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa6a81fba06194ff9cf0d14e9dd9339a0">streamsize</a> = <a class="el" href="namespaceetl.html#abffe34c79351f871acb3e0438b2ad488">make_signed_t</a>&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> &gt;</td></tr>
<tr class="separator:aa6a81fba06194ff9cf0d14e9dd9339a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a7197a7953a7c1e620701f90bec2cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91a7197a7953a7c1e620701f90bec2cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a91a7197a7953a7c1e620701f90bec2cc">iter_difference_t</a> = typename detail::iter_difference&lt; T &gt;::type</td></tr>
<tr class="separator:a91a7197a7953a7c1e620701f90bec2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6106bae4778d251870adc7ae5b1974ef"><td class="memTemplParams" colspan="2">template&lt;detail::dereferenceable T&gt; </td></tr>
<tr class="memitem:a6106bae4778d251870adc7ae5b1974ef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6106bae4778d251870adc7ae5b1974ef">iter_reference_t</a> = decltype(*<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt; T &amp; &gt;())</td></tr>
<tr class="separator:a6106bae4778d251870adc7ae5b1974ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c22455efb7e072deb03e78241405e56"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c22455efb7e072deb03e78241405e56"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7c22455efb7e072deb03e78241405e56">iter_value_t</a> = typename detail::iter_value&lt; T &gt;::type</td></tr>
<tr class="separator:a7c22455efb7e072deb03e78241405e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314896b8468bbdbea59f862f4c5e8aef"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , etl::size_t Rank&gt; </td></tr>
<tr class="memitem:a314896b8468bbdbea59f862f4c5e8aef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a314896b8468bbdbea59f862f4c5e8aef">dextents</a> = typename detail::dextents_impl&lt; IndexType, <a class="el" href="namespaceetl.html#acca681165e818e6caaf5e237e8125ae8">etl::make_index_sequence</a>&lt; Rank &gt; &gt;::type</td></tr>
<tr class="separator:a314896b8468bbdbea59f862f4c5e8aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8937b566b6510cbe3ede298d8b128f2b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8937b566b6510cbe3ede298d8b128f2b">new_handler</a> = void(*)()</td></tr>
<tr class="memdesc:a8937b566b6510cbe3ede298d8b128f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#a8937b566b6510cbe3ede298d8b128f2b" title="etl::new_handler is the function pointer type (pointer to function that takes no arguments and return...">etl::new_handler</a> is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions etl::set_new_handler and etl::get_new_handler  <a href="namespaceetl.html#a8937b566b6510cbe3ede298d8b128f2b">More...</a><br /></td></tr>
<tr class="separator:a8937b566b6510cbe3ede298d8b128f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e01072f7d94c62bb328ea01c1588e1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a56e01072f7d94c62bb328ea01c1588e1">xorshift16</a> = <a class="el" href="structetl_1_1xorshift.html">xorshift</a>&lt; <a class="el" href="namespaceetl.html#a07faf2c6165a6ec08c1d7ce7b59c70f9">uint16_t</a>, 7, 9, 8 &gt;</td></tr>
<tr class="memdesc:a56e01072f7d94c62bb328ea01c1588e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit pseudo number generator <a href="http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html">http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html</a> <a href="https://codebase64.org/doku.php?id=base:16bit_xorshift_random_generator">https://codebase64.org/doku.php?id=base:16bit_xorshift_random_generator</a>  <a href="namespaceetl.html#a56e01072f7d94c62bb328ea01c1588e1">More...</a><br /></td></tr>
<tr class="separator:a56e01072f7d94c62bb328ea01c1588e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f97b463f89003915a42b98555c13bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad5f97b463f89003915a42b98555c13bf">xorshift32</a> = <a class="el" href="structetl_1_1xorshift.html">xorshift</a>&lt; <a class="el" href="namespaceetl.html#a45cd8f569fbe5bbe1bc46988b146bf43">uint32_t</a>, 13, 17, 5 &gt;</td></tr>
<tr class="memdesc:ad5f97b463f89003915a42b98555c13bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit pseudo number generator <a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a>  <a href="namespaceetl.html#ad5f97b463f89003915a42b98555c13bf">More...</a><br /></td></tr>
<tr class="separator:ad5f97b463f89003915a42b98555c13bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41a230169af2e293e51036057534936"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac41a230169af2e293e51036057534936">xorshift64</a> = <a class="el" href="structetl_1_1xorshift.html">xorshift</a>&lt; <a class="el" href="namespaceetl.html#a75da701473a787f887fa0c35cb173588">uint64_t</a>, 13, 7, 17 &gt;</td></tr>
<tr class="memdesc:ac41a230169af2e293e51036057534936"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit pseudo number generator <a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a>  <a href="namespaceetl.html#ac41a230169af2e293e51036057534936">More...</a><br /></td></tr>
<tr class="separator:ac41a230169af2e293e51036057534936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc2ccd245f477d45cf1f6957c8f8993"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7cc2ccd245f477d45cf1f6957c8f8993">atto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 '000 '000 '000 '000 '000 &gt;</td></tr>
<tr class="separator:a7cc2ccd245f477d45cf1f6957c8f8993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837dad904f094bc29e24139565eec1c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a837dad904f094bc29e24139565eec1c5">femto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 '000 '000 '000 '000 &gt;</td></tr>
<tr class="separator:a837dad904f094bc29e24139565eec1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85e2cc66c84a64edf096334ea68d82f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab85e2cc66c84a64edf096334ea68d82f">pico</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 '000 '000 '000 &gt;</td></tr>
<tr class="separator:ab85e2cc66c84a64edf096334ea68d82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16ea857b72e93345fcd6fb255f7fe86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab16ea857b72e93345fcd6fb255f7fe86">nano</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 '000 '000 &gt;</td></tr>
<tr class="separator:ab16ea857b72e93345fcd6fb255f7fe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ee5013d725632677b4d1d93204c07b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a56ee5013d725632677b4d1d93204c07b">micro</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 '000 &gt;</td></tr>
<tr class="separator:a56ee5013d725632677b4d1d93204c07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc43923bf9757db3bbaa5a6e4d36a3c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afc43923bf9757db3bbaa5a6e4d36a3c6">milli</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 &gt;</td></tr>
<tr class="separator:afc43923bf9757db3bbaa5a6e4d36a3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d8c20c69482c794a0cfb9e4428ca8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a95d8c20c69482c794a0cfb9e4428ca8d">centi</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 100 &gt;</td></tr>
<tr class="separator:a95d8c20c69482c794a0cfb9e4428ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f2e2c10ab4b06ed261d1e4a8358895"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a59f2e2c10ab4b06ed261d1e4a8358895">deci</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 10 &gt;</td></tr>
<tr class="separator:a59f2e2c10ab4b06ed261d1e4a8358895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae5b099e4ead54343e6304a6371985b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acae5b099e4ead54343e6304a6371985b">deca</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 10, 1 &gt;</td></tr>
<tr class="separator:acae5b099e4ead54343e6304a6371985b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb">hecto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 100, 1 &gt;</td></tr>
<tr class="separator:aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f7df2b4a088f13d067ec91336ad6d8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae0f7df2b4a088f13d067ec91336ad6d8">kilo</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000, 1 &gt;</td></tr>
<tr class="separator:ae0f7df2b4a088f13d067ec91336ad6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8b8f156e99d25877de869998eca882"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afb8b8f156e99d25877de869998eca882">mega</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000 '000, 1 &gt;</td></tr>
<tr class="separator:afb8b8f156e99d25877de869998eca882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa010c22727dfd8ede60afef156650c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aeaa010c22727dfd8ede60afef156650c">giga</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000 '000 '000, 1 &gt;</td></tr>
<tr class="separator:aeaa010c22727dfd8ede60afef156650c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d864adecb109d82a13a134020536ce7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9d864adecb109d82a13a134020536ce7">tera</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000 '000 '000 '000, 1 &gt;</td></tr>
<tr class="separator:a9d864adecb109d82a13a134020536ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2de582631c8b0507fa316267f24ae3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac2de582631c8b0507fa316267f24ae3b">peta</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000 '000 '000 '000 '000, 1 &gt;</td></tr>
<tr class="separator:ac2de582631c8b0507fa316267f24ae3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525a461cc6d062b7138a777cadacac47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a525a461cc6d062b7138a777cadacac47">exa</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000 '000 '000 '000 '000 '000, 1 &gt;</td></tr>
<tr class="separator:a525a461cc6d062b7138a777cadacac47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515e08f8ce11f32a154acd83b2fe6b00"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a515e08f8ce11f32a154acd83b2fe6b00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a515e08f8ce11f32a154acd83b2fe6b00">ratio_add</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; R1::num *R2::den+R2::num *R1::den, R1::den *R2::den &gt;</td></tr>
<tr class="memdesc:a515e08f8ce11f32a154acd83b2fe6b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_add denotes the result of adding two exact rational fractions represented by the ratio specializations R1 and R2.  <a href="namespaceetl.html#a515e08f8ce11f32a154acd83b2fe6b00">More...</a><br /></td></tr>
<tr class="separator:a515e08f8ce11f32a154acd83b2fe6b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420acf1424e7ed7ae82f703ac31ff258"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a420acf1424e7ed7ae82f703ac31ff258"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a420acf1424e7ed7ae82f703ac31ff258">ratio_divide</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; R1::num *R2::den, R1::den *R2::num &gt;</td></tr>
<tr class="memdesc:a420acf1424e7ed7ae82f703ac31ff258"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_divide denotes the result of dividing two exact rational fractions represented by the ratio specializations R1 and R2.  <a href="namespaceetl.html#a420acf1424e7ed7ae82f703ac31ff258">More...</a><br /></td></tr>
<tr class="separator:a420acf1424e7ed7ae82f703ac31ff258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdaf3b94f7cb0830c812d5c8aabbe0b"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:abbdaf3b94f7cb0830c812d5c8aabbe0b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abbdaf3b94f7cb0830c812d5c8aabbe0b">ratio_multiply</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; R1::num *R2::num, R1::den *R2::den &gt;</td></tr>
<tr class="memdesc:abbdaf3b94f7cb0830c812d5c8aabbe0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_multiply denotes the result of multiplying two exact rational fractions represented by the ratio specializations R1 and R2.  <a href="namespaceetl.html#abbdaf3b94f7cb0830c812d5c8aabbe0b">More...</a><br /></td></tr>
<tr class="separator:abbdaf3b94f7cb0830c812d5c8aabbe0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234acc6c1438740afe4f7766f1208784"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a234acc6c1438740afe4f7766f1208784"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a234acc6c1438740afe4f7766f1208784">ratio_subtract</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; R1::num *R2::den - R2::num *R1::den, R1::den *R2::den &gt;</td></tr>
<tr class="memdesc:a234acc6c1438740afe4f7766f1208784"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_subtract denotes the result of subtracting two exact rational fractions represented by the ratio specializations R1 and R2.  <a href="namespaceetl.html#a234acc6c1438740afe4f7766f1208784">More...</a><br /></td></tr>
<tr class="separator:a234acc6c1438740afe4f7766f1208784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfb181ab4cdace72138dcfb3b7b8e27"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a8dfb181ab4cdace72138dcfb3b7b8e27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">static_string</a> = <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; char, Capacity &gt;</td></tr>
<tr class="memdesc:a8dfb181ab4cdace72138dcfb3b7b8e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'char'.  <a href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">More...</a><br /></td></tr>
<tr class="separator:a8dfb181ab4cdace72138dcfb3b7b8e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764367809b942e7602a985553294edba"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a764367809b942e7602a985553294edba"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a764367809b942e7602a985553294edba">static_wstring</a> = <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; wchar_t, Capacity &gt;</td></tr>
<tr class="memdesc:a764367809b942e7602a985553294edba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'wchar_t'.  <a href="namespaceetl.html#a764367809b942e7602a985553294edba">More...</a><br /></td></tr>
<tr class="separator:a764367809b942e7602a985553294edba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ec92a1e825e31fc024b95f85aed1da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">string_view</a> = <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; char, <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt; &gt;</td></tr>
<tr class="memdesc:a41ec92a1e825e31fc024b95f85aed1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedefs for common character type.  <a href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">More...</a><br /></td></tr>
<tr class="separator:a41ec92a1e825e31fc024b95f85aed1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700f0f867c8a351c79de3b290004521e"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename T &gt; </td></tr>
<tr class="memitem:a700f0f867c8a351c79de3b290004521e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a700f0f867c8a351c79de3b290004521e">tuple_element_t</a> = typename <a class="el" href="structetl_1_1tuple__element.html">tuple_element</a>&lt; I, T &gt;::type</td></tr>
<tr class="separator:a700f0f867c8a351c79de3b290004521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fe98569e6409cac789c54e1e563996"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06fe98569e6409cac789c54e1e563996"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a06fe98569e6409cac789c54e1e563996">add_const_t</a> = T const</td></tr>
<tr class="separator:a06fe98569e6409cac789c54e1e563996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ebe7b76517ccaa9b434dbd1db3d992"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97ebe7b76517ccaa9b434dbd1db3d992"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a97ebe7b76517ccaa9b434dbd1db3d992">add_cv_t</a> = T const volatile</td></tr>
<tr class="separator:a97ebe7b76517ccaa9b434dbd1db3d992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2518533f04904417528e26d187b2bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc2518533f04904417528e26d187b2bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acc2518533f04904417528e26d187b2bb">add_lvalue_reference_t</a> = typename <a class="el" href="structetl_1_1add__lvalue__reference.html">etl::add_lvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:acc2518533f04904417528e26d187b2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab42b86be16dbdbaa744a2caaca7e80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ab42b86be16dbdbaa744a2caaca7e80"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2ab42b86be16dbdbaa744a2caaca7e80">add_pointer_t</a> = typename <a class="el" href="structetl_1_1add__pointer.html">etl::add_pointer</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a2ab42b86be16dbdbaa744a2caaca7e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1498f004a367863b7b1b4f0f8ca3f75d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1498f004a367863b7b1b4f0f8ca3f75d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1498f004a367863b7b1b4f0f8ca3f75d">add_rvalue_reference_t</a> = typename <a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a1498f004a367863b7b1b4f0f8ca3f75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a2ecbbe3dd734b6c724afc995c9849"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8a2ecbbe3dd734b6c724afc995c9849"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8a2ecbbe3dd734b6c724afc995c9849">add_volatile_t</a> = T volatile</td></tr>
<tr class="separator:af8a2ecbbe3dd734b6c724afc995c9849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e24f91ae41b68d72dc83e45765ffe3"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Len, etl::size_t Align = alignof(detail::aligned_storage_impl&lt;Len&gt;)&gt; </td></tr>
<tr class="memitem:a89e24f91ae41b68d72dc83e45765ffe3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a89e24f91ae41b68d72dc83e45765ffe3">aligned_storage_t</a> = typename <a class="el" href="structetl_1_1aligned__storage.html">etl::aligned_storage</a>&lt; Len, Align &gt;::type</td></tr>
<tr class="separator:a89e24f91ae41b68d72dc83e45765ffe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5633d0f4ab2cab13d3635ee77ecba9ad"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Len, typename... Types&gt; </td></tr>
<tr class="memitem:a5633d0f4ab2cab13d3635ee77ecba9ad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5633d0f4ab2cab13d3635ee77ecba9ad">aligned_union_t</a> = typename <a class="el" href="structetl_1_1aligned__union.html">etl::aligned_union</a>&lt; Len, Types... &gt;::type</td></tr>
<tr class="separator:a5633d0f4ab2cab13d3635ee77ecba9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19ff9e7939158584698cee4260e4471"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:aa19ff9e7939158584698cee4260e4471"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">bool_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; bool, B &gt;</td></tr>
<tr class="separator:aa19ff9e7939158584698cee4260e4471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa107a29afbb5288d6dceb9fae86b07b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa107a29afbb5288d6dceb9fae86b07b8">true_type</a> = <a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">bool_constant</a>&lt; true &gt;</td></tr>
<tr class="separator:aa107a29afbb5288d6dceb9fae86b07b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466dc202e27dec8fa05a9fcc6ef47e27"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a466dc202e27dec8fa05a9fcc6ef47e27">false_type</a> = <a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">bool_constant</a>&lt; false &gt;</td></tr>
<tr class="separator:a466dc202e27dec8fa05a9fcc6ef47e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadad4ea85004a040c0e6e70341e2d221"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:aadad4ea85004a040c0e6e70341e2d221"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aadad4ea85004a040c0e6e70341e2d221">common_reference_t</a> = typename <a class="el" href="structetl_1_1common__reference.html">common_reference</a>&lt; T... &gt;::type</td></tr>
<tr class="separator:aadad4ea85004a040c0e6e70341e2d221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa474dd82a788a57735f0603b85954c37"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:aa474dd82a788a57735f0603b85954c37"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa474dd82a788a57735f0603b85954c37">common_type_t</a> = typename <a class="el" href="structetl_1_1common__type.html">etl::common_type</a>&lt; T... &gt;::type</td></tr>
<tr class="separator:aa474dd82a788a57735f0603b85954c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f0be4dd8251443fd1dbf06fa9c2bde"><td class="memTemplParams" colspan="2">template&lt;bool B, typename T , typename F &gt; </td></tr>
<tr class="memitem:a27f0be4dd8251443fd1dbf06fa9c2bde"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">conditional_t</a> = typename <a class="el" href="structetl_1_1conditional.html">etl::conditional</a>&lt; B, T, F &gt;::type</td></tr>
<tr class="separator:a27f0be4dd8251443fd1dbf06fa9c2bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceeadc8f7b907c46772511ac5ec654c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaceeadc8f7b907c46772511ac5ec654c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a> = typename <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt; T &gt;::type</td></tr>
<tr class="separator:aaceeadc8f7b907c46772511ac5ec654c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2df4ab89284c8c5866afea3100f290"><td class="memTemplParams" colspan="2">template&lt;bool B, typename T  = void&gt; </td></tr>
<tr class="memitem:a2a2df4ab89284c8c5866afea3100f290"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a> = typename <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="separator:a2a2df4ab89284c8c5866afea3100f290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee9f2213a709e3392d4d998d2a406f2"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I&gt; </td></tr>
<tr class="memitem:adee9f2213a709e3392d4d998d2a406f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adee9f2213a709e3392d4d998d2a406f2">index_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">etl::integral_constant</a>&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>, I &gt;</td></tr>
<tr class="separator:adee9f2213a709e3392d4d998d2a406f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ed3feabd9624cf09aa604f49155cc2"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a93ed3feabd9624cf09aa604f49155cc2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a93ed3feabd9624cf09aa604f49155cc2">invoke_result_t</a> = typename <a class="el" href="structetl_1_1invoke__result.html">etl::invoke_result</a>&lt; F, ArgTypes... &gt;::type</td></tr>
<tr class="separator:a93ed3feabd9624cf09aa604f49155cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3c8b104138758267e7fc29e7aa2828"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a9c3c8b104138758267e7fc29e7aa2828"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9c3c8b104138758267e7fc29e7aa2828">is_constructible</a> = detail::is_constructible_helper&lt; <a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">etl::void_t</a>&lt;&gt;, T, Args... &gt;</td></tr>
<tr class="separator:a9c3c8b104138758267e7fc29e7aa2828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffe34c79351f871acb3e0438b2ad488"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abffe34c79351f871acb3e0438b2ad488"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abffe34c79351f871acb3e0438b2ad488">make_signed_t</a> = typename <a class="el" href="structetl_1_1make__signed.html">make_signed</a>&lt; T &gt;::type</td></tr>
<tr class="separator:abffe34c79351f871acb3e0438b2ad488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2df53f4e399975501cf8300d451814"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb2df53f4e399975501cf8300d451814"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acb2df53f4e399975501cf8300d451814">make_unsigned_t</a> = typename <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt; T &gt;::type</td></tr>
<tr class="separator:acb2df53f4e399975501cf8300d451814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e53fc126f7c9ebf9901856b9c2db22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a96e53fc126f7c9ebf9901856b9c2db22"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a96e53fc126f7c9ebf9901856b9c2db22">remove_all_extents_t</a> = typename <a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a96e53fc126f7c9ebf9901856b9c2db22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ceeb1a17bd47c943002a1c687be53c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ceeb1a17bd47c943002a1c687be53c1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6ceeb1a17bd47c943002a1c687be53c1">remove_const_t</a> = typename <a class="el" href="structetl_1_1remove__const.html">etl::remove_const</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a6ceeb1a17bd47c943002a1c687be53c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0aad8fae1237db2f92705fe80729cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd0aad8fae1237db2f92705fe80729cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">remove_cv_t</a> = <a class="el" href="namespaceetl.html#a6ceeb1a17bd47c943002a1c687be53c1">etl::remove_const_t</a>&lt; <a class="el" href="namespaceetl.html#a48541bce1229d664e678b7a89009200f">etl::remove_volatile_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:abd0aad8fae1237db2f92705fe80729cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c34af472196537fb719bde6ab1c4ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0c34af472196537fb719bde6ab1c4ad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac0c34af472196537fb719bde6ab1c4ad">remove_cvref_t</a> = <a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">etl::remove_cv_t</a>&lt; <a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">etl::remove_reference_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:ac0c34af472196537fb719bde6ab1c4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af678c3a5233d580ef71c70f11f076483"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af678c3a5233d580ef71c70f11f076483"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af678c3a5233d580ef71c70f11f076483">remove_extent_t</a> = typename <a class="el" href="structetl_1_1remove__extent.html">etl::remove_extent</a>&lt; T &gt;::type</td></tr>
<tr class="separator:af678c3a5233d580ef71c70f11f076483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e186a746241ab4cfcf810655e8f7844"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e186a746241ab4cfcf810655e8f7844"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5e186a746241ab4cfcf810655e8f7844">remove_pointer_t</a> = typename <a class="el" href="structetl_1_1remove__pointer.html">etl::remove_pointer</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a5e186a746241ab4cfcf810655e8f7844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab812e9b378e738c7b7b7fc34f4dab9f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab812e9b378e738c7b7b7fc34f4dab9f3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a> = typename <a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ab812e9b378e738c7b7b7fc34f4dab9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48541bce1229d664e678b7a89009200f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48541bce1229d664e678b7a89009200f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a48541bce1229d664e678b7a89009200f">remove_volatile_t</a> = typename <a class="el" href="structetl_1_1remove__volatile.html">etl::remove_volatile</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a48541bce1229d664e678b7a89009200f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53ccea3515493c555e3a764ffea8ff0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af53ccea3515493c555e3a764ffea8ff0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af53ccea3515493c555e3a764ffea8ff0">type_identity_t</a> = T</td></tr>
<tr class="separator:af53ccea3515493c555e3a764ffea8ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb4b27e61146521edc4ab6035681ed2"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a9fb4b27e61146521edc4ab6035681ed2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9fb4b27e61146521edc4ab6035681ed2">type_pack_element_t</a> = typename <a class="el" href="structetl_1_1type__pack__element.html">type_pack_element</a>&lt; I, Ts... &gt;::type</td></tr>
<tr class="separator:a9fb4b27e61146521edc4ab6035681ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49061e75c4b48962719493fb046259e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49061e75c4b48962719493fb046259e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a49061e75c4b48962719493fb046259e2">underlying_type_t</a> = typename <a class="el" href="structetl_1_1underlying__type.html">etl::underlying_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a49061e75c4b48962719493fb046259e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944255034d5f023db7654f5d8dbc9701"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a944255034d5f023db7654f5d8dbc9701"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a944255034d5f023db7654f5d8dbc9701">unwrap_ref_decay_t</a> = typename <a class="el" href="structetl_1_1unwrap__ref__decay.html">etl::unwrap_ref_decay</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a944255034d5f023db7654f5d8dbc9701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">void_t</a> = void</td></tr>
<tr class="separator:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4271478b9ac53d8758a27dc93d55aa8f"><td class="memTemplParams" colspan="2">template&lt;etl::size_t... Ints&gt; </td></tr>
<tr class="memitem:a4271478b9ac53d8758a27dc93d55aa8f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4271478b9ac53d8758a27dc93d55aa8f">index_sequence</a> = <a class="el" href="structetl_1_1integer__sequence.html">etl::integer_sequence</a>&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>, Ints... &gt;</td></tr>
<tr class="separator:a4271478b9ac53d8758a27dc93d55aa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca681165e818e6caaf5e237e8125ae8"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Size&gt; </td></tr>
<tr class="memitem:acca681165e818e6caaf5e237e8125ae8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acca681165e818e6caaf5e237e8125ae8">make_index_sequence</a> = <a class="el" href="namespaceetl.html#ac5bd86337786fcf4b5b9ff86cdb9674d">etl::make_integer_sequence</a>&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt;</td></tr>
<tr class="separator:acca681165e818e6caaf5e237e8125ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131ba515ad6cb810a2d722fefb0a6325"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a131ba515ad6cb810a2d722fefb0a6325"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a131ba515ad6cb810a2d722fefb0a6325">index_sequence_for</a> = <a class="el" href="namespaceetl.html#acca681165e818e6caaf5e237e8125ae8">etl::make_index_sequence</a>&lt; sizeof...(T)&gt;</td></tr>
<tr class="separator:a131ba515ad6cb810a2d722fefb0a6325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bd86337786fcf4b5b9ff86cdb9674d"><td class="memTemplParams" colspan="2">template&lt;typename T , T Size&gt; </td></tr>
<tr class="memitem:ac5bd86337786fcf4b5b9ff86cdb9674d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac5bd86337786fcf4b5b9ff86cdb9674d">make_integer_sequence</a> = <a class="el" href="builtin__functions_8hpp.html#a303c6144751de3e45c44990112e8b1cb">TETL_BUILTIN_INT_SEQ</a>(T, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a>)</td></tr>
<tr class="separator:ac5bd86337786fcf4b5b9ff86cdb9674d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7110ca07ee5b481d99d9ae57a977ed"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename T &gt; </td></tr>
<tr class="memitem:aef7110ca07ee5b481d99d9ae57a977ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a> = typename <a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a>&lt; I, T &gt;::type</td></tr>
<tr class="separator:aef7110ca07ee5b481d99d9ae57a977ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aadba129a7dc760f449b09b7fafeb63a8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8">endian</a> { <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8aaae6635e044ac56046b2893a529b5114">little</a> = implementation defined
, <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8ad861877da56b8b4ceb35c8cbfdf65bb4">big</a> = implementation defined
, <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796">native</a> = implementation defined
 }</td></tr>
<tr class="memdesc:aadba129a7dc760f449b09b7fafeb63a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the endianness of all scalar types. If all scalar types are little-endian, <code>endian::native</code> equals <code>endian::little</code>. If all scalar types are big-endian, <code>endian::native</code> equals <code>endian::big</code>.  <a href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8">More...</a><br /></td></tr>
<tr class="separator:aadba129a7dc760f449b09b7fafeb63a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af524d0acb625979997f7a2dd1c0ea944"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af524d0acb625979997f7a2dd1c0ea944">chars_format</a> : etl::uint8_t { <a class="el" href="namespaceetl.html#af524d0acb625979997f7a2dd1c0ea944a55a95650a66b53ecbb960b53d985b964">scientific</a> = 0x1
, <a class="el" href="namespaceetl.html#af524d0acb625979997f7a2dd1c0ea944acec315e3d0975e5cc2811d5d8725f149">fixed</a> = 0x2
, <a class="el" href="namespaceetl.html#af524d0acb625979997f7a2dd1c0ea944ab8d1b43eae73587ba56baef574709ecb">hex</a> = 0x4
, <a class="el" href="namespaceetl.html#af524d0acb625979997f7a2dd1c0ea944a958153f1b8b96ec4c4eb2147429105d9">general</a> = fixed | scientific
 }</td></tr>
<tr class="memdesc:af524d0acb625979997f7a2dd1c0ea944"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BitmaskType used to specify floating-point formatting for to_chars and from_chars.  <a href="namespaceetl.html#af524d0acb625979997f7a2dd1c0ea944">More...</a><br /></td></tr>
<tr class="separator:af524d0acb625979997f7a2dd1c0ea944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4892bd9af0bd3ad759fb95ab241247c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247c">float_denorm_style</a> { <a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247cadc095ee49d9e6884cd67bc20a4c73287">denorm_indeterminate</a> = -1
, <a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247caf254439f29ec6166a1a6fb7b09efd141">denorm_absent</a> = 0
, <a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247ca5a085126714d6734d58691edaa278aa5">denorm_present</a> = 1
 }</td></tr>
<tr class="separator:ad4892bd9af0bd3ad759fb95ab241247c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdec522db16c755ade7c7222bf8af92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92">float_round_style</a> { <br />
&#160;&#160;<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92afd0fa1de009f9a47f51a0ec9c23aa10b">round_indeterminate</a> = -1
, <a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92a00004115cf199c1cd29d07f78679a63d">round_toward_zero</a> = 0
, <a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92a1fc678348a02cf4262fb59153d5b73c3">round_to_nearest</a> = 1
, <a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92a274b79e7a1a164b8b9eea17dda4751c0">round_toward_infinity</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92ac6babddc09b7dbf6e3daf12455e3417f">round_toward_neg_infinity</a> = 3
<br />
 }</td></tr>
<tr class="separator:a0cdec522db16c755ade7c7222bf8af92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91722a64a739818dbac515ddd4ea5387"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a91722a64a739818dbac515ddd4ea5387">align_val_t</a> : etl::size_t </td></tr>
<tr class="memdesc:a91722a64a739818dbac515ddd4ea5387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Both new-expression and delete-expression, when used with objects whose alignment requirement is greater than the default, pass that alignment requirement as an argument of type align_val_t to the selected allocation/deallocation function.  <a href="namespaceetl.html#a91722a64a739818dbac515ddd4ea5387">More...</a><br /></td></tr>
<tr class="separator:a91722a64a739818dbac515ddd4ea5387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf855e66ccd0c031e0994ed578f1c170"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170">errc</a> { <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a8ab69162f060cc46b805b3265ad1cdf1">address_family_not_supported</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a8e2bc80599069d337b43dff6edfb6891">address_in_use</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a20abf2ffbf6e82e36405843f269d6438">address_not_available</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ab5580b198f691ab2df12f5e2ab974373">already_connected</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a1b245b26b5ea3428c050d7f1503d7715">argument_list_too_long</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a4b82222a0895b538d0597092b3ceab3e">argument_out_of_domain</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aaf169f73a82794128aa491c4b4f1c071">bad_address</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a9941c5c8c58ff058b870e94e96ac38e1">bad_file_descriptor</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ac7944ab5d2e25bf75b267d070b506d1c">bad_message</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a2f0338eed54503152be1d31c93c9c2f1">broken_pipe</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a2f8f27a7eef1ad585c7ab6f25a6c2c79">connection_aborted</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a81cf222a9b1530171fdfd66c3f734989">connection_already_in_progress</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a53793ee58fc24168a0d6549c3cb2df8e">connection_refused</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170abf39bfc8665384194e343c08ab344405">connection_reset</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a6177070a517d51a4382ab0d7c88e5b58">cross_device_link</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a326032e01f2a5e14c7f730f4d03d753a">destination_address_required</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ab3ab5338a00f49c4451851cc5442f370">device_or_resource_busy</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a6a336135d33e62f49edc55f29354e12e">directory_not_empty</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a4dfaf9c996cf045f32d17edc9754fc95">executable_format_error</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a41edf636e3c7b59f797348fc58472258">file_exists</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aa1e14bfb89b41ddf654b1772c8fd2e74">file_too_large</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a6e56e6ed055b9771b8192a4f229fee27">filename_too_long</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aa33c516bbdfb179cef733c8daeb97bed">function_not_supported</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170afe2377fbd16d7f335474e1df7d6376bf">host_unreachable</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a054e5b4ff59331386872de744d661719">identifier_removed</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a53a9e57a679708b2d8ff0ccd8ec96b18">illegal_byte_sequence</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a45fe7da1767194b580aeba752d7b44ae">inappropriate_io_control_operation</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170afadb76763385627e57ec386c9b6038f0">interrupted</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ae55d43eabeefe5a8271b4a3c898bd18f">invalid_argument</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170abd86a2c65caf6a270b916234ab321ce3">invalid_seek</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170acccc32f2a5f7dc7b87d2f85daea66789">io_error</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170af3c51d7ea75a76f26c0a2bdc00c4e006">is_a_directory</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ade5f4bc2f8a4690176e22e83196b9fd3">message_size</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a93b16d34b1689f66f0cfed60e99c0009">network_down</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a0e1d200ae35ede416bf85f84093ce37a">network_reset</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a608a68344b4eb1fe0690861a83828816">network_unreachable</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a618ead44397b73cf0baa08b460b66c39">no_buffer_space</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ad08d4c854a6810cebd2a8ab61876f919">no_child_process</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170add431dfaf61ea842693dca8be1ebcaf7">no_link</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a58688487c3e24313637a76bd29881e64">no_lock_available</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aeec0f03ad92584c78835c10ab79d7f42">no_message_available</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170acec935db07cfc57caafa37e98eafb213">no_message</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170abed8a9032d9366c28582a0ad59a31525">no_protocol_option</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a1a5334dd8d1ca56e33887bd44630641b">no_space_on_device</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ad8b1d94a0ac09c6d55b2ed68f0836142">no_stream_resources</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a5c83a012eac17bbf458df5804801e373">no_such_device_or_address</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170af42b2e58729e2783b683c8610977fc22">no_such_device</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a2e70fc89b08f26fa3fc77694c91e8f7a">no_such_file_or_directory</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ad91a9b8a734f2bef4b778f89806cbab7">no_such_process</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a21e867ca95e1dfecff4701863547dcec">not_a_directory</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a22ac64bb14c46bcbc338a21950b6e722">not_a_socket</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a6e752b7a04543e5052b2d0dd05eca0fa">not_a_stream</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a69c2dbb5917ca550a862e9c1c839bca1">not_connected</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aafdb5594dc3e484fc1bfd7c564d550c1">not_enough_memory</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aa55e82356e9721946aa9ba954733c6f0">not_supported</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170afd3d0bdcc9eb9e68534b7d055c5fe586">operation_canceled</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a4c7eb50b6d86ac8a130ebebc18dbe263">operation_in_progress</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a8344b3d509942f035d5e303022f9b986">operation_not_permitted</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a69bf074bf052ee4c9047b62fe7c24569">operation_not_supported</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a738abdaead9cd7b2e2ea19a34764b385">operation_would_block</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a2abac2fa6722c56b2ea17ac6c4097f68">owner_dead</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ae8ee838822072f02738dbd7d97ea03fc">permission_denied</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a9665c745d0a9132d8da6ed55e89a0564">protocol_error</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aa2635acef8b9a3e1c40923829722d472">protocol_not_supported</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a06108efce8ef1cd8aa4cc440f8b4317f">read_only_file_system</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aed65f7649c6f0e365673d65a9d8119d8">resource_deadlock_would_occur</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ae46a97ea2906921c8c626890bde832cf">resource_unavailable_try_again</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a8e0fafb181567cc468e1ee81983d739d">result_out_of_range</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a6805059549401365b824b54573a6f46e">state_not_recoverable</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ac1a620a30954dc9402a811453c2c3e3f">stream_timeout</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ad2f80f12d22bb099fcf1062db660b567">text_file_busy</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a56c27b1ab1a5a5a0eae853cabb4dc0c1">timed_out</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a3130d1d4e000cdc1e7c47013e313c10e">too_many_files_open_in_system</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aed2c33c8fe874cfeba6f4a7747c62d05">too_many_files_open</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170abfe22fc9b27a8ff13186aba60b6bc5c8">too_many_links</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a33c78baca1480479c88aa4d50cb68206">too_many_symbolic_link_levels</a>
, <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a143653b075bff946193644ba6d97fa5d">value_too_large</a>
, <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a81cac28a38438710de9856af4a8bcd0b">wrong_protocol_type</a>
<br />
 }</td></tr>
<tr class="memdesc:abf855e66ccd0c031e0994ed578f1c170"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scoped enumeration <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170" title="The scoped enumeration etl::errc defines the values of portable error conditions that correspond to t...">etl::errc</a> defines the values of portable error conditions that correspond to the POSIX error codes.  <a href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170">More...</a><br /></td></tr>
<tr class="separator:abf855e66ccd0c031e0994ed578f1c170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035e7d2ea0f6aebad724e7fab40495d5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a035e7d2ea0f6aebad724e7fab40495d5">implementation</a> { <a class="el" href="namespaceetl.html#a035e7d2ea0f6aebad724e7fab40495d5aed920a9dd5bae2e1c4f11aab8f5784e1">freestanding</a> = 0
, <a class="el" href="namespaceetl.html#a035e7d2ea0f6aebad724e7fab40495d5a734d3030ff72ad8d9678efa82b1db7d2">hosted</a> = 1
 }</td></tr>
<tr class="separator:a035e7d2ea0f6aebad724e7fab40495d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f63a594bf7e2b29cb07e1868483ee53"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> : unsigned char { <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53a6289bbfa378818f7066ccad5847da5a2">cpp_17</a> = 17
, <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53a4c7aabdc3eb0d845c62edfb822b0fe5a">cpp_20</a> = 20
, <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53af7d98f68372c9de30cc2d571b75b19d7">cpp_23</a> = 23
, <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53af94629088b2e56f93753526b629a62ff">cpp_26</a> = 26
 }</td></tr>
<tr class="memdesc:a2f63a594bf7e2b29cb07e1868483ee53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for the currently selected C++ standard version. Unlike the official macro <code>__cplusplus</code>, these values only include the published year. This is to make the actual values smaller and therfore fit on smaller word sized chips.  <a href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">More...</a><br /></td></tr>
<tr class="separator:a2f63a594bf7e2b29cb07e1868483ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a46270726b5073fd6eeefb5ccd9ed1f72"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:a46270726b5073fd6eeefb5ccd9ed1f72"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a46270726b5073fd6eeefb5ccd9ed1f72">bubble_sort</a> (RandomIt first, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:a46270726b5073fd6eeefb5ccd9ed1f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. <a href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a>.  <a href="namespaceetl.html#a46270726b5073fd6eeefb5ccd9ed1f72">More...</a><br /></td></tr>
<tr class="separator:a46270726b5073fd6eeefb5ccd9ed1f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc149eb7abea4405c02e767e7860dae"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:a1cc149eb7abea4405c02e767e7860dae"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1cc149eb7abea4405c02e767e7860dae">bubble_sort</a> (RandomIt first, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="separator:a1cc149eb7abea4405c02e767e7860dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9162720047d01bb438874bf56df5d2"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename T &gt; </td></tr>
<tr class="memitem:a3f9162720047d01bb438874bf56df5d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; InputIt &gt;::difference_type</td></tr>
<tr class="memdesc:a3f9162720047d01bb438874bf56df5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts the elements that are equal to value.  <a href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">More...</a><br /></td></tr>
<tr class="separator:a3f9162720047d01bb438874bf56df5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be834c1a5353b7d9b51d77cd30a9654"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:a9be834c1a5353b7d9b51d77cd30a9654"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9be834c1a5353b7d9b51d77cd30a9654">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:a9be834c1a5353b7d9b51d77cd30a9654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range <code>[first1, last1)</code> is equal to the range <code>[first2, first2 + (last1 - first1))</code>, and false otherwise.  <a href="namespaceetl.html#a9be834c1a5353b7d9b51d77cd30a9654">More...</a><br /></td></tr>
<tr class="separator:a9be834c1a5353b7d9b51d77cd30a9654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934bfc901fe1ed60e93f7f9b9fb34079"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:a934bfc901fe1ed60e93f7f9b9fb34079"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a934bfc901fe1ed60e93f7f9b9fb34079">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2) -&gt; bool</td></tr>
<tr class="separator:a934bfc901fe1ed60e93f7f9b9fb34079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dda20bb1c4958e2a9ce23f6ebd4fb9c"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:a7dda20bb1c4958e2a9ce23f6ebd4fb9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7dda20bb1c4958e2a9ce23f6ebd4fb9c">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Predicate p) -&gt; bool</td></tr>
<tr class="separator:a7dda20bb1c4958e2a9ce23f6ebd4fb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bb44dc832eef8b58d30b1cc70411ff"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:a19bb44dc832eef8b58d30b1cc70411ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a19bb44dc832eef8b58d30b1cc70411ff">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2) -&gt; bool</td></tr>
<tr class="separator:a19bb44dc832eef8b58d30b1cc70411ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292ca875d178a8cfb23a5b2f74d5ed33"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:a292ca875d178a8cfb23a5b2f74d5ed33"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a292ca875d178a8cfb23a5b2f74d5ed33">equal_range</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, Compare comp) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; ForwardIt, ForwardIt &gt;</td></tr>
<tr class="memdesc:a292ca875d178a8cfb23a5b2f74d5ed33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements equivalent to value in the range <code>[first, last)</code>.  <a href="namespaceetl.html#a292ca875d178a8cfb23a5b2f74d5ed33">More...</a><br /></td></tr>
<tr class="separator:a292ca875d178a8cfb23a5b2f74d5ed33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67b5001d764da2ece198e4fc86fde26"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:af67b5001d764da2ece198e4fc86fde26"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af67b5001d764da2ece198e4fc86fde26">equal_range</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; ForwardIt, ForwardIt &gt;</td></tr>
<tr class="separator:af67b5001d764da2ece198e4fc86fde26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086d2ed75d087dea9497d60549d77485"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:a086d2ed75d087dea9497d60549d77485"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a086d2ed75d087dea9497d60549d77485">exchange_sort</a> (RandomIt first, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:a086d2ed75d087dea9497d60549d77485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort">https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort</a>.  <a href="namespaceetl.html#a086d2ed75d087dea9497d60549d77485">More...</a><br /></td></tr>
<tr class="separator:a086d2ed75d087dea9497d60549d77485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9635d27783910f84b9a83730f26f2c19"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:a9635d27783910f84b9a83730f26f2c19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9635d27783910f84b9a83730f26f2c19">exchange_sort</a> (RandomIt first, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="separator:a9635d27783910f84b9a83730f26f2c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11bb84e871a5db6b2a230e5ef065234"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:aa11bb84e871a5db6b2a230e5ef065234"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa11bb84e871a5db6b2a230e5ef065234">fill</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; void</td></tr>
<tr class="memdesc:aa11bb84e871a5db6b2a230e5ef065234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the elements in the range <code>[first, last)</code>.  <a href="namespaceetl.html#aa11bb84e871a5db6b2a230e5ef065234">More...</a><br /></td></tr>
<tr class="separator:aa11bb84e871a5db6b2a230e5ef065234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ac240345a96ad39668967bf8bdf76f"><td class="memTemplParams" colspan="2">template&lt;typename OutputIt , typename Size , typename T &gt; </td></tr>
<tr class="memitem:ad5ac240345a96ad39668967bf8bdf76f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad5ac240345a96ad39668967bf8bdf76f">fill_n</a> (OutputIt first, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; OutputIt</td></tr>
<tr class="memdesc:ad5ac240345a96ad39668967bf8bdf76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the first count elements in the range beginning at <code>first</code> if <code>count &gt; 0</code>. Does nothing otherwise.  <a href="namespaceetl.html#ad5ac240345a96ad39668967bf8bdf76f">More...</a><br /></td></tr>
<tr class="separator:ad5ac240345a96ad39668967bf8bdf76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074d4da4cb7d3a678c5ae1fce471ddfb"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename T &gt; </td></tr>
<tr class="memitem:a074d4da4cb7d3a678c5ae1fce471ddfb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a074d4da4cb7d3a678c5ae1fce471ddfb">find</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; InputIt</td></tr>
<tr class="memdesc:a074d4da4cb7d3a678c5ae1fce471ddfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element equal to value.  <a href="namespaceetl.html#a074d4da4cb7d3a678c5ae1fce471ddfb">More...</a><br /></td></tr>
<tr class="separator:a074d4da4cb7d3a678c5ae1fce471ddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8d78c0146673a9463dc7c68540b963"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:a7c8d78c0146673a9463dc7c68540b963"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7c8d78c0146673a9463dc7c68540b963">find_end</a> (ForwardIt1 first, ForwardIt1 <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, ForwardIt2 sFirst, ForwardIt2 sLast, Predicate p) -&gt; ForwardIt1</td></tr>
<tr class="memdesc:a7c8d78c0146673a9463dc7c68540b963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of the sequence [sFirst, sLast) in the range <code>[first, last)</code>. Elements are compared using the given binary predicate p.  <a href="namespaceetl.html#a7c8d78c0146673a9463dc7c68540b963">More...</a><br /></td></tr>
<tr class="separator:a7c8d78c0146673a9463dc7c68540b963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a3af0f6b1ea2008b53ed21446814f5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:a67a3af0f6b1ea2008b53ed21446814f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a67a3af0f6b1ea2008b53ed21446814f5">find_end</a> (ForwardIt1 first, ForwardIt1 <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, ForwardIt2 sFirst, ForwardIt2 sLast) -&gt; ForwardIt1</td></tr>
<tr class="separator:a67a3af0f6b1ea2008b53ed21446814f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea99982a37144ad397257540600269a0"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:aea99982a37144ad397257540600269a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aea99982a37144ad397257540600269a0">find_first_of</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, ForwardIt sFirst, ForwardIt sLast, Predicate pred) -&gt; InputIt</td></tr>
<tr class="memdesc:aea99982a37144ad397257540600269a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). Elements are compared using the given binary predicate pred.  <a href="namespaceetl.html#aea99982a37144ad397257540600269a0">More...</a><br /></td></tr>
<tr class="separator:aea99982a37144ad397257540600269a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4931d3f143272627df883beae8bd9bd5"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename ForwardIt &gt; </td></tr>
<tr class="memitem:a4931d3f143272627df883beae8bd9bd5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4931d3f143272627df883beae8bd9bd5">find_first_of</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, ForwardIt sFirst, ForwardIt sLast) -&gt; InputIt</td></tr>
<tr class="memdesc:a4931d3f143272627df883beae8bd9bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast).  <a href="namespaceetl.html#a4931d3f143272627df883beae8bd9bd5">More...</a><br /></td></tr>
<tr class="separator:a4931d3f143272627df883beae8bd9bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c802502e6a81c3b77d98dbcaf030c19"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:a9c802502e6a81c3b77d98dbcaf030c19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9c802502e6a81c3b77d98dbcaf030c19">find_if</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate pred) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; InputIt</td></tr>
<tr class="memdesc:a9c802502e6a81c3b77d98dbcaf030c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate p returns true.  <a href="namespaceetl.html#a9c802502e6a81c3b77d98dbcaf030c19">More...</a><br /></td></tr>
<tr class="separator:a9c802502e6a81c3b77d98dbcaf030c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e68ff6f7166005f9862c8772fa43fd"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:a29e68ff6f7166005f9862c8772fa43fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a29e68ff6f7166005f9862c8772fa43fd">find_if_not</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate pred) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; InputIt</td></tr>
<tr class="memdesc:a29e68ff6f7166005f9862c8772fa43fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate q returns false.  <a href="namespaceetl.html#a29e68ff6f7166005f9862c8772fa43fd">More...</a><br /></td></tr>
<tr class="separator:a29e68ff6f7166005f9862c8772fa43fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad01de69ea01da886464fc3ef1390cc"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename UnaryFunc &gt; </td></tr>
<tr class="memitem:a3ad01de69ea01da886464fc3ef1390cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3ad01de69ea01da886464fc3ef1390cc">for_each</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, UnaryFunc f) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; UnaryFunc</td></tr>
<tr class="memdesc:a3ad01de69ea01da886464fc3ef1390cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, last)</code> in order.  <a href="namespaceetl.html#a3ad01de69ea01da886464fc3ef1390cc">More...</a><br /></td></tr>
<tr class="separator:a3ad01de69ea01da886464fc3ef1390cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9839f986201c53e618b3435d27ad43a"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Size , typename UnaryFunc &gt; </td></tr>
<tr class="memitem:ab9839f986201c53e618b3435d27ad43a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab9839f986201c53e618b3435d27ad43a">for_each_n</a> (InputIt first, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> n, UnaryFunc f) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; InputIt</td></tr>
<tr class="memdesc:ab9839f986201c53e618b3435d27ad43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, first + n]</code> in order.  <a href="namespaceetl.html#ab9839f986201c53e618b3435d27ad43a">More...</a><br /></td></tr>
<tr class="separator:ab9839f986201c53e618b3435d27ad43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b963791bdb1da038a64b23555f245c4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Generator &gt; </td></tr>
<tr class="memitem:a0b963791bdb1da038a64b23555f245c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0b963791bdb1da038a64b23555f245c4">generate</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Generator g) -&gt; void</td></tr>
<tr class="memdesc:a0b963791bdb1da038a64b23555f245c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns each element in range <code>[first, last)</code> a value generated by the given function object g.  <a href="namespaceetl.html#a0b963791bdb1da038a64b23555f245c4">More...</a><br /></td></tr>
<tr class="separator:a0b963791bdb1da038a64b23555f245c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="memTemplParams" colspan="2">template&lt;typename OutputIt , typename SizeT , typename Generator &gt; </td></tr>
<tr class="memitem:ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab984bfa2eb0fd6da7369b629ca3acdc7">generate_n</a> (OutputIt first, SizeT <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>, Generator g) -&gt; OutputIt</td></tr>
<tr class="memdesc:ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns values, generated by given function object <code>g</code>, to the first count elements in the range beginning at <code>first</code>, if <code>count &gt; 0</code>. Does nothing otherwise.  <a href="namespaceetl.html#ab984bfa2eb0fd6da7369b629ca3acdc7">More...</a><br /></td></tr>
<tr class="separator:ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d92f2387c738f0636ab8495aa18613"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt , typename Compare &gt; </td></tr>
<tr class="memitem:a72d92f2387c738f0636ab8495aa18613"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a72d92f2387c738f0636ab8495aa18613">gnome_sort</a> (BidirIt first, BidirIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:a72d92f2387c738f0636ab8495aa18613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Gnome_sort">https://en.wikipedia.org/wiki/Gnome_sort</a>.  <a href="namespaceetl.html#a72d92f2387c738f0636ab8495aa18613">More...</a><br /></td></tr>
<tr class="separator:a72d92f2387c738f0636ab8495aa18613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4a4559a0af0147ebc0d7572dbc142e"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt &gt; </td></tr>
<tr class="memitem:add4a4559a0af0147ebc0d7572dbc142e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#add4a4559a0af0147ebc0d7572dbc142e">gnome_sort</a> (BidirIt first, BidirIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="separator:add4a4559a0af0147ebc0d7572dbc142e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7d9a038b385aff889235d470b837e4"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:acc7d9a038b385aff889235d470b837e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acc7d9a038b385aff889235d470b837e4">includes</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2) -&gt; bool</td></tr>
<tr class="memdesc:acc7d9a038b385aff889235d470b837e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sorted range <code>[first2, last2)</code> is a subsequence of the sorted range <code>[first1, last1)</code>. Both ranges must be sorted.  <a href="namespaceetl.html#acc7d9a038b385aff889235d470b837e4">More...</a><br /></td></tr>
<tr class="separator:acc7d9a038b385aff889235d470b837e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f97df033ed5dc7c5458f991078633d9"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </td></tr>
<tr class="memitem:a2f97df033ed5dc7c5458f991078633d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2f97df033ed5dc7c5458f991078633d9">includes</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Compare comp) -&gt; bool</td></tr>
<tr class="separator:a2f97df033ed5dc7c5458f991078633d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a63b710f7e13e8142d025fe5f2ef94"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt , typename Compare &gt; </td></tr>
<tr class="memitem:af8a63b710f7e13e8142d025fe5f2ef94"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8a63b710f7e13e8142d025fe5f2ef94">inplace_merge</a> (BidirIt <a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2">begin</a>, BidirIt mid, BidirIt <a class="el" href="namespaceetl.html#abf9eb859a31968a9179b29b638cd054b">end</a>, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:af8a63b710f7e13e8142d025fe5f2ef94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last).  <a href="namespaceetl.html#af8a63b710f7e13e8142d025fe5f2ef94">More...</a><br /></td></tr>
<tr class="separator:af8a63b710f7e13e8142d025fe5f2ef94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9e7376359b4a88a505f218d6aa0ddc"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt &gt; </td></tr>
<tr class="memitem:a0e9e7376359b4a88a505f218d6aa0ddc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0e9e7376359b4a88a505f218d6aa0ddc">inplace_merge</a> (BidirIt first, BidirIt mid, BidirIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="separator:a0e9e7376359b4a88a505f218d6aa0ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0080a41003199426077c02b6175ae904"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:a0080a41003199426077c02b6175ae904"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0080a41003199426077c02b6175ae904">insertion_sort</a> (RandomIt first, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:a0080a41003199426077c02b6175ae904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. <a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a>.  <a href="namespaceetl.html#a0080a41003199426077c02b6175ae904">More...</a><br /></td></tr>
<tr class="separator:a0080a41003199426077c02b6175ae904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6d5b25a5beae6b886f7eaccb6ccfd2"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:a5e6d5b25a5beae6b886f7eaccb6ccfd2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5e6d5b25a5beae6b886f7eaccb6ccfd2">insertion_sort</a> (RandomIt first, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="separator:a5e6d5b25a5beae6b886f7eaccb6ccfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577d3ae817b5678a0a0b91213a403c21"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:a577d3ae817b5678a0a0b91213a403c21"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a577d3ae817b5678a0a0b91213a403c21">is_partitioned</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:a577d3ae817b5678a0a0b91213a403c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements in the range <code>[first, last)</code> that satisfy the predicate p appear before all elements that don't. Also returns true if the range is empty. <a href="https://en.cppreference.com/w/cpp/algorithm/is_partitioned">https://en.cppreference.com/w/cpp/algorithm/is_partitioned</a>.  <a href="namespaceetl.html#a577d3ae817b5678a0a0b91213a403c21">More...</a><br /></td></tr>
<tr class="separator:a577d3ae817b5678a0a0b91213a403c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01459034f5f84e415ed7c9f73700b54f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:a01459034f5f84e415ed7c9f73700b54f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a01459034f5f84e415ed7c9f73700b54f">is_permutation</a> (ForwardIt1 first, ForwardIt1 <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, ForwardIt2 first2) -&gt; bool</td></tr>
<tr class="memdesc:a01459034f5f84e415ed7c9f73700b54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists a permutation of the elements in the range <code>[first1, last1)</code> that makes that range equal to the range <code>[first2, last2)</code>, where <code>last2</code> denotes <code>first2 + (last1 - first1)</code> if it was not given.  <a href="namespaceetl.html#a01459034f5f84e415ed7c9f73700b54f">More...</a><br /></td></tr>
<tr class="separator:a01459034f5f84e415ed7c9f73700b54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc05db4110903905f00fc26bb6de03a1"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:adc05db4110903905f00fc26bb6de03a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adc05db4110903905f00fc26bb6de03a1">is_permutation</a> (ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2) -&gt; bool</td></tr>
<tr class="separator:adc05db4110903905f00fc26bb6de03a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671187bf1a3dd1a99a1acfada1927fcf"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:a671187bf1a3dd1a99a1acfada1927fcf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a671187bf1a3dd1a99a1acfada1927fcf">is_sorted</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; bool</td></tr>
<tr class="memdesc:a671187bf1a3dd1a99a1acfada1927fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the elements in range <code>[first, last)</code> are sorted in non-descending order.  <a href="namespaceetl.html#a671187bf1a3dd1a99a1acfada1927fcf">More...</a><br /></td></tr>
<tr class="separator:a671187bf1a3dd1a99a1acfada1927fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab728b1a920fd45e985ed73b9874fcb7d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Compare &gt; </td></tr>
<tr class="memitem:ab728b1a920fd45e985ed73b9874fcb7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab728b1a920fd45e985ed73b9874fcb7d">is_sorted</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; bool</td></tr>
<tr class="separator:ab728b1a920fd45e985ed73b9874fcb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cb4df55d0b061279b599134e294f22"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Compare &gt; </td></tr>
<tr class="memitem:a26cb4df55d0b061279b599134e294f22"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a26cb4df55d0b061279b599134e294f22">is_sorted_until</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; ForwardIt</td></tr>
<tr class="separator:a26cb4df55d0b061279b599134e294f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cca9919e02704d1dd11db707e679ee"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:a04cca9919e02704d1dd11db707e679ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a04cca9919e02704d1dd11db707e679ee">is_sorted_until</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a04cca9919e02704d1dd11db707e679ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the range <code>[first, last)</code> and finds the largest range beginning at <code>first</code> in which the elements are sorted in non-descending order.  <a href="namespaceetl.html#a04cca9919e02704d1dd11db707e679ee">More...</a><br /></td></tr>
<tr class="separator:a04cca9919e02704d1dd11db707e679ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18b878794474881fce640e7a163abf3"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:aa18b878794474881fce640e7a163abf3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa18b878794474881fce640e7a163abf3">iter_swap</a> (ForwardIt1 a, ForwardIt2 <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) -&gt; void</td></tr>
<tr class="memdesc:aa18b878794474881fce640e7a163abf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values of the elements the given iterators are pointing to.  <a href="namespaceetl.html#aa18b878794474881fce640e7a163abf3">More...</a><br /></td></tr>
<tr class="separator:aa18b878794474881fce640e7a163abf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73951d21be0807534a52bbd26b866f7b"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </td></tr>
<tr class="memitem:a73951d21be0807534a52bbd26b866f7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a73951d21be0807534a52bbd26b866f7b">lexicographical_compare</a> (InputIt1 f1, InputIt1 l1, InputIt2 f2, InputIt2 l2, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:a73951d21be0807534a52bbd26b866f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first range <code>[f1, l1)</code> is lexicographically less than the second range <code>[f2, l2)</code>.  <a href="namespaceetl.html#a73951d21be0807534a52bbd26b866f7b">More...</a><br /></td></tr>
<tr class="separator:a73951d21be0807534a52bbd26b866f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386a232aa903a5387aa91c4ed5194d9f"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:a386a232aa903a5387aa91c4ed5194d9f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a386a232aa903a5387aa91c4ed5194d9f">lexicographical_compare</a> (InputIt1 f1, InputIt1 l1, InputIt2 f2, InputIt2 l2) -&gt; bool</td></tr>
<tr class="separator:a386a232aa903a5387aa91c4ed5194d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779ffb051a7e52e4702eb01aa18f167f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:a779ffb051a7e52e4702eb01aa18f167f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a779ffb051a7e52e4702eb01aa18f167f">lower_bound</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, Compare comp) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; ForwardIt</td></tr>
<tr class="memdesc:a779ffb051a7e52e4702eb01aa18f167f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is not less than (i.e. greater or equal to) value, or last if no such element is found.  <a href="namespaceetl.html#a779ffb051a7e52e4702eb01aa18f167f">More...</a><br /></td></tr>
<tr class="separator:a779ffb051a7e52e4702eb01aa18f167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb1800f39f2305708f67187a3a49993"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:a9fb1800f39f2305708f67187a3a49993"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9fb1800f39f2305708f67187a3a49993">lower_bound</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; ForwardIt</td></tr>
<tr class="separator:a9fb1800f39f2305708f67187a3a49993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7fdd0cf88f36f44f8fe8ec8327cfac74">max</a> (Type const &amp;a, Type const &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b.  <a href="namespaceetl.html#a7fdd0cf88f36f44f8fe8ec8327cfac74">More...</a><br /></td></tr>
<tr class="separator:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220fbd23aca7dbc728c200471ed114c8"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:a220fbd23aca7dbc728c200471ed114c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a220fbd23aca7dbc728c200471ed114c8">max</a> (Type const &amp;a, Type const &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>, Compare comp) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a220fbd23aca7dbc728c200471ed114c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b, using a compare function.  <a href="namespaceetl.html#a220fbd23aca7dbc728c200471ed114c8">More...</a><br /></td></tr>
<tr class="separator:a220fbd23aca7dbc728c200471ed114c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc62e1e0c57de79b8b007265bc308ec2"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:abc62e1e0c57de79b8b007265bc308ec2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abc62e1e0c57de79b8b007265bc308ec2">max_element</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; ForwardIt</td></tr>
<tr class="memdesc:abc62e1e0c57de79b8b007265bc308ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;.  <a href="namespaceetl.html#abc62e1e0c57de79b8b007265bc308ec2">More...</a><br /></td></tr>
<tr class="separator:abc62e1e0c57de79b8b007265bc308ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcf261d2d7377e2284ab3f5738b34e1"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Compare &gt; </td></tr>
<tr class="memitem:aedcf261d2d7377e2284ab3f5738b34e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aedcf261d2d7377e2284ab3f5738b34e1">max_element</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; ForwardIt</td></tr>
<tr class="memdesc:aedcf261d2d7377e2284ab3f5738b34e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp.  <a href="namespaceetl.html#aedcf261d2d7377e2284ab3f5738b34e1">More...</a><br /></td></tr>
<tr class="separator:aedcf261d2d7377e2284ab3f5738b34e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee09e4768fc381002cd7dc14e8e561b"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </td></tr>
<tr class="memitem:a9ee09e4768fc381002cd7dc14e8e561b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9ee09e4768fc381002cd7dc14e8e561b">merge</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination, Compare comp) -&gt; OutputIt</td></tr>
<tr class="memdesc:a9ee09e4768fc381002cd7dc14e8e561b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into one sorted range beginning at <code>destination</code>.  <a href="namespaceetl.html#a9ee09e4768fc381002cd7dc14e8e561b">More...</a><br /></td></tr>
<tr class="separator:a9ee09e4768fc381002cd7dc14e8e561b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0face2f5fe06333854b6b120bd6bad"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </td></tr>
<tr class="memitem:a6d0face2f5fe06333854b6b120bd6bad"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6d0face2f5fe06333854b6b120bd6bad">merge</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="separator:a6d0face2f5fe06333854b6b120bd6bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bffa34e9bd6075ec150aa9e30153950"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt , typename Compare &gt; </td></tr>
<tr class="memitem:a5bffa34e9bd6075ec150aa9e30153950"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5bffa34e9bd6075ec150aa9e30153950">merge_sort</a> (BidirIt first, BidirIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:a5bffa34e9bd6075ec150aa9e30153950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a>.  <a href="namespaceetl.html#a5bffa34e9bd6075ec150aa9e30153950">More...</a><br /></td></tr>
<tr class="separator:a5bffa34e9bd6075ec150aa9e30153950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da0fcb091026bf11e56eb257e9d3bc5"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt &gt; </td></tr>
<tr class="memitem:a4da0fcb091026bf11e56eb257e9d3bc5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4da0fcb091026bf11e56eb257e9d3bc5">merge_sort</a> (BidirIt first, BidirIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="separator:a4da0fcb091026bf11e56eb257e9d3bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae1500815312b248e453896d5439b63"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:adae1500815312b248e453896d5439b63"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adae1500815312b248e453896d5439b63">min</a> (Type const &amp;a, Type const &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Type const &amp;</td></tr>
<tr class="memdesc:adae1500815312b248e453896d5439b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b.  <a href="namespaceetl.html#adae1500815312b248e453896d5439b63">More...</a><br /></td></tr>
<tr class="separator:adae1500815312b248e453896d5439b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479c4a8315ae3ef2d1128858d723afc2"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:a479c4a8315ae3ef2d1128858d723afc2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a479c4a8315ae3ef2d1128858d723afc2">min</a> (Type const &amp;a, Type const &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>, Compare comp) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a479c4a8315ae3ef2d1128858d723afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b, using a compare function.  <a href="namespaceetl.html#a479c4a8315ae3ef2d1128858d723afc2">More...</a><br /></td></tr>
<tr class="separator:a479c4a8315ae3ef2d1128858d723afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71878538e0e2b2f8026ed657836382c0"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:a71878538e0e2b2f8026ed657836382c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a71878538e0e2b2f8026ed657836382c0">min_element</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; ForwardIt</td></tr>
<tr class="memdesc:a71878538e0e2b2f8026ed657836382c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;.  <a href="namespaceetl.html#a71878538e0e2b2f8026ed657836382c0">More...</a><br /></td></tr>
<tr class="separator:a71878538e0e2b2f8026ed657836382c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af4c7706179eef16ba76242c48518a9"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Compare &gt; </td></tr>
<tr class="memitem:a4af4c7706179eef16ba76242c48518a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4af4c7706179eef16ba76242c48518a9">min_element</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a4af4c7706179eef16ba76242c48518a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp.  <a href="namespaceetl.html#a4af4c7706179eef16ba76242c48518a9">More...</a><br /></td></tr>
<tr class="separator:a4af4c7706179eef16ba76242c48518a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81f900b934c83cdb278826ede239e6b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare &gt; </td></tr>
<tr class="memitem:ae81f900b934c83cdb278826ede239e6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae81f900b934c83cdb278826ede239e6b">minmax</a> (T const &amp;a, T const &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>, Compare comp) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T const &amp;, T const &amp; &gt;</td></tr>
<tr class="memdesc:ae81f900b934c83cdb278826ede239e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <a href="namespaceetl.html#ae81f900b934c83cdb278826ede239e6b">More...</a><br /></td></tr>
<tr class="separator:ae81f900b934c83cdb278826ede239e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85dc58adf499e8f90a9e9c4eb0594a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1a85dc58adf499e8f90a9e9c4eb0594a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1a85dc58adf499e8f90a9e9c4eb0594a">minmax</a> (T const &amp;a, T const &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T const &amp;, T const &amp; &gt;</td></tr>
<tr class="memdesc:a1a85dc58adf499e8f90a9e9c4eb0594a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <a href="namespaceetl.html#a1a85dc58adf499e8f90a9e9c4eb0594a">More...</a><br /></td></tr>
<tr class="separator:a1a85dc58adf499e8f90a9e9c4eb0594a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3573e5fccf8f6ff5d8636e23b1ffa0"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Compare &gt; </td></tr>
<tr class="memitem:adf3573e5fccf8f6ff5d8636e23b1ffa0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adf3573e5fccf8f6ff5d8636e23b1ffa0">minmax_element</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; ForwardIt, ForwardIt &gt;</td></tr>
<tr class="memdesc:adf3573e5fccf8f6ff5d8636e23b1ffa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range <code>[first, last)</code>.  <a href="namespaceetl.html#adf3573e5fccf8f6ff5d8636e23b1ffa0">More...</a><br /></td></tr>
<tr class="separator:adf3573e5fccf8f6ff5d8636e23b1ffa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3442eebc68bb878d66ab8a37478ff679"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:a3442eebc68bb878d66ab8a37478ff679"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3442eebc68bb878d66ab8a37478ff679">minmax_element</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; ForwardIt, ForwardIt &gt;</td></tr>
<tr class="memdesc:a3442eebc68bb878d66ab8a37478ff679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range <code>[first, last)</code>.  <a href="namespaceetl.html#a3442eebc68bb878d66ab8a37478ff679">More...</a><br /></td></tr>
<tr class="separator:a3442eebc68bb878d66ab8a37478ff679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5674e86a91ac9cb808d365aa09d5d07f"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:a5674e86a91ac9cb808d365aa09d5d07f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5674e86a91ac9cb808d365aa09d5d07f">mismatch</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, Predicate pred) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; InputIt1, InputIt2 &gt;</td></tr>
<tr class="memdesc:a5674e86a91ac9cb808d365aa09d5d07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by <code>[first1, last1)</code> and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). Elements are compared using the given binary predicate pred.  <a href="namespaceetl.html#a5674e86a91ac9cb808d365aa09d5d07f">More...</a><br /></td></tr>
<tr class="separator:a5674e86a91ac9cb808d365aa09d5d07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae399b1c12f42fcf2365021710f1e1667"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:ae399b1c12f42fcf2365021710f1e1667"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae399b1c12f42fcf2365021710f1e1667">mismatch</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; InputIt1, InputIt2 &gt;</td></tr>
<tr class="separator:ae399b1c12f42fcf2365021710f1e1667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85be5a2493fc37bb07bab46871d7732b"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:a85be5a2493fc37bb07bab46871d7732b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a85be5a2493fc37bb07bab46871d7732b">mismatch</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Predicate pred) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; InputIt1, InputIt2 &gt;</td></tr>
<tr class="separator:a85be5a2493fc37bb07bab46871d7732b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8936cbbb27640ce6d9411dd5bc4859b3"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:a8936cbbb27640ce6d9411dd5bc4859b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8936cbbb27640ce6d9411dd5bc4859b3">mismatch</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; InputIt1, InputIt2 &gt;</td></tr>
<tr class="separator:a8936cbbb27640ce6d9411dd5bc4859b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8df3814fc65f04932c2f0d09a56107"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:a1b8df3814fc65f04932c2f0d09a56107"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1b8df3814fc65f04932c2f0d09a56107">move</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:a1b8df3814fc65f04932c2f0d09a56107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements in the range <code>[first, last)</code>, to another range beginning at destination, starting from first and proceeding to <code>last - 1</code>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.  <a href="namespaceetl.html#a1b8df3814fc65f04932c2f0d09a56107">More...</a><br /></td></tr>
<tr class="separator:a1b8df3814fc65f04932c2f0d09a56107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739385d15b43be76e906acbc6e6459a5"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt1 , typename BidirIt2 &gt; </td></tr>
<tr class="memitem:a739385d15b43be76e906acbc6e6459a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a739385d15b43be76e906acbc6e6459a5">move_backward</a> (BidirIt1 first, BidirIt1 <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, BidirIt2 destination) -&gt; BidirIt2</td></tr>
<tr class="memdesc:a739385d15b43be76e906acbc6e6459a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements from the range <code>[first, last)</code>, to another range ending at destination. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved.  <a href="namespaceetl.html#a739385d15b43be76e906acbc6e6459a5">More...</a><br /></td></tr>
<tr class="separator:a739385d15b43be76e906acbc6e6459a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b5fe643bd62734bbb66af22e88544c"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ae2b5fe643bd62734bbb66af22e88544c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae2b5fe643bd62734bbb66af22e88544c">none_of</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:ae2b5fe643bd62734bbb66af22e88544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for no elements in the range <code>[first, last)</code>.  <a href="namespaceetl.html#ae2b5fe643bd62734bbb66af22e88544c">More...</a><br /></td></tr>
<tr class="separator:ae2b5fe643bd62734bbb66af22e88544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade97d95e33160e2176476b303cacc224"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:ade97d95e33160e2176476b303cacc224"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ade97d95e33160e2176476b303cacc224">nth_element</a> (RandomIt first, RandomIt nth, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:ade97d95e33160e2176476b303cacc224"><td class="mdescLeft">&#160;</td><td class="mdescRight">nth_element is a partial sorting algorithm that rearranges elements in <code>[first, last)</code> such that:  <a href="namespaceetl.html#ade97d95e33160e2176476b303cacc224">More...</a><br /></td></tr>
<tr class="separator:ade97d95e33160e2176476b303cacc224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31997e04071d6cfa4b887e46783efbf3"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:a31997e04071d6cfa4b887e46783efbf3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a31997e04071d6cfa4b887e46783efbf3">nth_element</a> (RandomIt first, RandomIt nth, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="separator:a31997e04071d6cfa4b887e46783efbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d1bed984c0aceff254e912cf251c6e"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:a61d1bed984c0aceff254e912cf251c6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a61d1bed984c0aceff254e912cf251c6e">partial_sort</a> (RandomIt first, RandomIt middle, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:a61d1bed984c0aceff254e912cf251c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges elements such that the range <code>[first, middle)</code> contains the sorted <code>middle - first</code> smallest elements in the range <code>[first, last)</code>. The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range <code>[middle, last)</code> is unspecified.  <a href="namespaceetl.html#a61d1bed984c0aceff254e912cf251c6e">More...</a><br /></td></tr>
<tr class="separator:a61d1bed984c0aceff254e912cf251c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf059ef9f744ed7d731faa69834ddc9a"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:adf059ef9f744ed7d731faa69834ddc9a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adf059ef9f744ed7d731faa69834ddc9a">partial_sort</a> (RandomIt first, RandomIt middle, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="separator:adf059ef9f744ed7d731faa69834ddc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c256595c3b4e99c28c50d5f1c0d73f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:a94c256595c3b4e99c28c50d5f1c0d73f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a94c256595c3b4e99c28c50d5f1c0d73f">partition</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate p) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a94c256595c3b4e99c28c50d5f1c0d73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved.  <a href="namespaceetl.html#a94c256595c3b4e99c28c50d5f1c0d73f">More...</a><br /></td></tr>
<tr class="separator:a94c256595c3b4e99c28c50d5f1c0d73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34f1c15b38f8436c5d6dcc1f9f38491"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt1 , typename OutputIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:ad34f1c15b38f8436c5d6dcc1f9f38491"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad34f1c15b38f8436c5d6dcc1f9f38491">partition_copy</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt1 destinationTrue, OutputIt2 destinationFalse, Predicate p) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; OutputIt1, OutputIt2 &gt;</td></tr>
<tr class="memdesc:ad34f1c15b38f8436c5d6dcc1f9f38491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code> to two different ranges depending on the value returned by the predicate p. The elements that satisfy the predicate p are copied to the range beginning at destination_true. The rest of the elements are copied to the range beginning at destination_false.  <a href="namespaceetl.html#ad34f1c15b38f8436c5d6dcc1f9f38491">More...</a><br /></td></tr>
<tr class="separator:ad34f1c15b38f8436c5d6dcc1f9f38491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4c550073b16bc102ef6b2447cc31d6"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:a8d4c550073b16bc102ef6b2447cc31d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8d4c550073b16bc102ef6b2447cc31d6">partition_point</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate p) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a8d4c550073b16bc102ef6b2447cc31d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the partitioned (as if by partition) range [first, last) and locates the end of the first partition, that is, the first element that does not satisfy p or last if all elements satisfy p.  <a href="namespaceetl.html#a8d4c550073b16bc102ef6b2447cc31d6">More...</a><br /></td></tr>
<tr class="separator:a8d4c550073b16bc102ef6b2447cc31d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde454dc915d0c4c32bd8041b0bd8ecf"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:adde454dc915d0c4c32bd8041b0bd8ecf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adde454dc915d0c4c32bd8041b0bd8ecf">remove</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; ForwardIt</td></tr>
<tr class="memdesc:adde454dc915d0c4c32bd8041b0bd8ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range.  <a href="namespaceetl.html#adde454dc915d0c4c32bd8041b0bd8ecf">More...</a><br /></td></tr>
<tr class="separator:adde454dc915d0c4c32bd8041b0bd8ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0bacdf9416ed0db41e5527c7bb1b29"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename T &gt; </td></tr>
<tr class="memitem:a7e0bacdf9416ed0db41e5527c7bb1b29"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7e0bacdf9416ed0db41e5527c7bb1b29">remove_copy</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; OutputIt</td></tr>
<tr class="memdesc:a7e0bacdf9416ed0db41e5527c7bb1b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements that are equal to value.  <a href="namespaceetl.html#a7e0bacdf9416ed0db41e5527c7bb1b29">More...</a><br /></td></tr>
<tr class="separator:a7e0bacdf9416ed0db41e5527c7bb1b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dc3e941f0f6b0d00f923fec94b6694"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:a68dc3e941f0f6b0d00f923fec94b6694"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a68dc3e941f0f6b0d00f923fec94b6694">remove_copy_if</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination, Predicate p) -&gt; OutputIt</td></tr>
<tr class="memdesc:a68dc3e941f0f6b0d00f923fec94b6694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements for which predicate p returns true.  <a href="namespaceetl.html#a68dc3e941f0f6b0d00f923fec94b6694">More...</a><br /></td></tr>
<tr class="separator:a68dc3e941f0f6b0d00f923fec94b6694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc5f42480a4033b9a58cb5c7236fbee"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:a5dc5f42480a4033b9a58cb5c7236fbee"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5dc5f42480a4033b9a58cb5c7236fbee">remove_if</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate pred) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a5dc5f42480a4033b9a58cb5c7236fbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range.  <a href="namespaceetl.html#a5dc5f42480a4033b9a58cb5c7236fbee">More...</a><br /></td></tr>
<tr class="separator:a5dc5f42480a4033b9a58cb5c7236fbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab115e24caa45f16f79bb770a6e3cbbab"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:ab115e24caa45f16f79bb770a6e3cbbab"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab115e24caa45f16f79bb770a6e3cbbab">replace</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;oldValue, T const &amp;newValue) -&gt; void</td></tr>
<tr class="memdesc:ab115e24caa45f16f79bb770a6e3cbbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements that are equal to old_value.  <a href="namespaceetl.html#ab115e24caa45f16f79bb770a6e3cbbab">More...</a><br /></td></tr>
<tr class="separator:ab115e24caa45f16f79bb770a6e3cbbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290953b933269399f045b7e2b37d97b7"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate , typename T &gt; </td></tr>
<tr class="memitem:a290953b933269399f045b7e2b37d97b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a290953b933269399f045b7e2b37d97b7">replace_if</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate p, T const &amp;newValue) -&gt; void</td></tr>
<tr class="memdesc:a290953b933269399f045b7e2b37d97b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements for which predicate p returns true.  <a href="namespaceetl.html#a290953b933269399f045b7e2b37d97b7">More...</a><br /></td></tr>
<tr class="separator:a290953b933269399f045b7e2b37d97b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa198aa5e9e5759947d51496cede4e6f6"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt &gt; </td></tr>
<tr class="memitem:aa198aa5e9e5759947d51496cede4e6f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa198aa5e9e5759947d51496cede4e6f6">reverse</a> (BidirIt first, BidirIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="memdesc:aa198aa5e9e5759947d51496cede4e6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the range <code>[first, last)</code>. Behaves as if applying iter_swap to every pair of iterators <code>first + i</code>, <code>(last-i) - 1</code> for each non-negative <code>i &lt; (last - first) / 2</code>.  <a href="namespaceetl.html#aa198aa5e9e5759947d51496cede4e6f6">More...</a><br /></td></tr>
<tr class="separator:aa198aa5e9e5759947d51496cede4e6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0246fc85a8996116ecfe4be33cd1495"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:ae0246fc85a8996116ecfe4be33cd1495"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae0246fc85a8996116ecfe4be33cd1495">reverse_copy</a> (BidirIt first, BidirIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:ae0246fc85a8996116ecfe4be33cd1495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code> to another range beginning at d_first in such a way that the elements in the new range are in reverse order.  <a href="namespaceetl.html#ae0246fc85a8996116ecfe4be33cd1495">More...</a><br /></td></tr>
<tr class="separator:ae0246fc85a8996116ecfe4be33cd1495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0cdef8cb8f1fb054c43f8aadb43d36"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:a1c0cdef8cb8f1fb054c43f8aadb43d36"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1c0cdef8cb8f1fb054c43f8aadb43d36">rotate</a> (ForwardIt first, ForwardIt nFirst, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a1c0cdef8cb8f1fb054c43f8aadb43d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotation on a range of elements.  <a href="namespaceetl.html#a1c0cdef8cb8f1fb054c43f8aadb43d36">More...</a><br /></td></tr>
<tr class="separator:a1c0cdef8cb8f1fb054c43f8aadb43d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d28d5f25cdee05003b4190e57dd519"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:ad0d28d5f25cdee05003b4190e57dd519"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad0d28d5f25cdee05003b4190e57dd519">rotate_copy</a> (ForwardIt first, ForwardIt nFirst, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:ad0d28d5f25cdee05003b4190e57dd519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code>, to another range beginning at destination in such a way, that the element <code>nFirst</code> becomes the first element of the new range and <code>nFirst - 1</code> becomes the last element.  <a href="namespaceetl.html#ad0d28d5f25cdee05003b4190e57dd519">More...</a><br /></td></tr>
<tr class="separator:ad0d28d5f25cdee05003b4190e57dd519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39a57bc56c6f3c0bf94045777e9f274"><td class="memTemplParams" colspan="2">template&lt;typename FwdIt1 , typename FwdIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:af39a57bc56c6f3c0bf94045777e9f274"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af39a57bc56c6f3c0bf94045777e9f274">search</a> (FwdIt1 first, FwdIt1 <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, FwdIt2 sFirst, FwdIt2 sLast, Predicate pred) -&gt; FwdIt1</td></tr>
<tr class="memdesc:af39a57bc56c6f3c0bf94045777e9f274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range <code>[first, last)</code>.  <a href="namespaceetl.html#af39a57bc56c6f3c0bf94045777e9f274">More...</a><br /></td></tr>
<tr class="separator:af39a57bc56c6f3c0bf94045777e9f274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8c774a650ce6535a79e6a11dd90fdf"><td class="memTemplParams" colspan="2">template&lt;typename FwdIt1 , typename FwdIt2 &gt; </td></tr>
<tr class="memitem:a5e8c774a650ce6535a79e6a11dd90fdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5e8c774a650ce6535a79e6a11dd90fdf">search</a> (FwdIt1 first, FwdIt1 <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, FwdIt2 sFirst, FwdIt2 sLast) -&gt; FwdIt1</td></tr>
<tr class="separator:a5e8c774a650ce6535a79e6a11dd90fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a90d9aad4e00eb080d9dce99472a40"><td class="memTemplParams" colspan="2">template&lt;typename FwdIt , typename Searcher &gt; </td></tr>
<tr class="memitem:a21a90d9aad4e00eb080d9dce99472a40"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a21a90d9aad4e00eb080d9dce99472a40">search</a> (FwdIt first, FwdIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Searcher const &amp;searcher) -&gt; FwdIt</td></tr>
<tr class="separator:a21a90d9aad4e00eb080d9dce99472a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047bb8dc9dd92624ad901db1d27e5d83"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Size , typename ValueT , typename Predicate &gt; </td></tr>
<tr class="memitem:a047bb8dc9dd92624ad901db1d27e5d83"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a047bb8dc9dd92624ad901db1d27e5d83">search_n</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>, ValueT const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, Predicate pred) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a047bb8dc9dd92624ad901db1d27e5d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value.  <a href="namespaceetl.html#a047bb8dc9dd92624ad901db1d27e5d83">More...</a><br /></td></tr>
<tr class="separator:a047bb8dc9dd92624ad901db1d27e5d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8fcaf19422ff5c92791797f6373260"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Size , typename ValueT &gt; </td></tr>
<tr class="memitem:a6c8fcaf19422ff5c92791797f6373260"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6c8fcaf19422ff5c92791797f6373260">search_n</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>, ValueT const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; ForwardIt</td></tr>
<tr class="separator:a6c8fcaf19422ff5c92791797f6373260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563244b70e444026e7ddee3ad609b4a5"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </td></tr>
<tr class="memitem:a563244b70e444026e7ddee3ad609b4a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a563244b70e444026e7ddee3ad609b4a5">set_difference</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination, Compare comp) -&gt; OutputIt</td></tr>
<tr class="memdesc:a563244b70e444026e7ddee3ad609b4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same.  <a href="namespaceetl.html#a563244b70e444026e7ddee3ad609b4a5">More...</a><br /></td></tr>
<tr class="separator:a563244b70e444026e7ddee3ad609b4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c804f0766a786779b7c17886e601a2"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </td></tr>
<tr class="memitem:a50c804f0766a786779b7c17886e601a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a50c804f0766a786779b7c17886e601a2">set_difference</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="separator:a50c804f0766a786779b7c17886e601a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6670fa3cc294c702e9b6245c55a1da4"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </td></tr>
<tr class="memitem:ac6670fa3cc294c702e9b6245c55a1da4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac6670fa3cc294c702e9b6245c55a1da4">set_intersection</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp) -&gt; OutputIt</td></tr>
<tr class="memdesc:ac6670fa3cc294c702e9b6245c55a1da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges.  <a href="namespaceetl.html#ac6670fa3cc294c702e9b6245c55a1da4">More...</a><br /></td></tr>
<tr class="separator:ac6670fa3cc294c702e9b6245c55a1da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a31828bddd42fb93f6afb491bd4b4f"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </td></tr>
<tr class="memitem:a47a31828bddd42fb93f6afb491bd4b4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a47a31828bddd42fb93f6afb491bd4b4f">set_intersection</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest) -&gt; OutputIt</td></tr>
<tr class="separator:a47a31828bddd42fb93f6afb491bd4b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c7a269a772f000cb710d042d7aee20"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </td></tr>
<tr class="memitem:a40c7a269a772f000cb710d042d7aee20"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a40c7a269a772f000cb710d042d7aee20">set_symmetric_difference</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination, Compare comp) -&gt; OutputIt</td></tr>
<tr class="memdesc:a40c7a269a772f000cb710d042d7aee20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes symmetric difference of two sorted ranges: the elements that are found in either of the ranges, but not in both of them are copied to the range beginning at destination. The resulting range is also sorted.  <a href="namespaceetl.html#a40c7a269a772f000cb710d042d7aee20">More...</a><br /></td></tr>
<tr class="separator:a40c7a269a772f000cb710d042d7aee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e87148d2ced5612a3f9f09fd4eb941"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </td></tr>
<tr class="memitem:ac0e87148d2ced5612a3f9f09fd4eb941"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac0e87148d2ced5612a3f9f09fd4eb941">set_symmetric_difference</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest) -&gt; OutputIt</td></tr>
<tr class="separator:ac0e87148d2ced5612a3f9f09fd4eb941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9009346ce6e69bac2a9406592192aef1"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </td></tr>
<tr class="memitem:a9009346ce6e69bac2a9406592192aef1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9009346ce6e69bac2a9406592192aef1">set_union</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination, Compare comp) -&gt; OutputIt</td></tr>
<tr class="memdesc:a9009346ce6e69bac2a9406592192aef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges.  <a href="namespaceetl.html#a9009346ce6e69bac2a9406592192aef1">More...</a><br /></td></tr>
<tr class="separator:a9009346ce6e69bac2a9406592192aef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c31225d785d8d6b0702705ce2706c53"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </td></tr>
<tr class="memitem:a4c31225d785d8d6b0702705ce2706c53"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4c31225d785d8d6b0702705ce2706c53">set_union</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="separator:a4c31225d785d8d6b0702705ce2706c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df8e5c73b49b744646fa291c63525c1"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:a9df8e5c73b49b744646fa291c63525c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9df8e5c73b49b744646fa291c63525c1">shift_left</a> (ForwardIt first, ForwardIt const <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; ForwardIt &gt;::difference_type n) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a9df8e5c73b49b744646fa291c63525c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the elements in the range [first, last) by n positions.  <a href="namespaceetl.html#a9df8e5c73b49b744646fa291c63525c1">More...</a><br /></td></tr>
<tr class="separator:a9df8e5c73b49b744646fa291c63525c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828f0e293b30f2af1151a2de5ef8d26e"><td class="memTemplParams" colspan="2">template&lt;typename BidiIt &gt; </td></tr>
<tr class="memitem:a828f0e293b30f2af1151a2de5ef8d26e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a828f0e293b30f2af1151a2de5ef8d26e">shift_right</a> (BidiIt first, BidiIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; BidiIt &gt;::difference_type n) -&gt; BidiIt</td></tr>
<tr class="memdesc:a828f0e293b30f2af1151a2de5ef8d26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the elements in the range [first, last) by n positions.  <a href="namespaceetl.html#a828f0e293b30f2af1151a2de5ef8d26e">More...</a><br /></td></tr>
<tr class="separator:a828f0e293b30f2af1151a2de5ef8d26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda62f64ad31faeb43dab1bbe8b2a664"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:adda62f64ad31faeb43dab1bbe8b2a664"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adda62f64ad31faeb43dab1bbe8b2a664">sort</a> (RandomIt first, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:adda62f64ad31faeb43dab1bbe8b2a664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is not guaranteed to be preserved.  <a href="namespaceetl.html#adda62f64ad31faeb43dab1bbe8b2a664">More...</a><br /></td></tr>
<tr class="separator:adda62f64ad31faeb43dab1bbe8b2a664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29031b0fee25653ff42e6fab29670267"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:a29031b0fee25653ff42e6fab29670267"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a29031b0fee25653ff42e6fab29670267">sort</a> (RandomIt first, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="separator:a29031b0fee25653ff42e6fab29670267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04627f836421020d549c77618e404bef"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt , typename Predicate &gt; </td></tr>
<tr class="memitem:a04627f836421020d549c77618e404bef"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a04627f836421020d549c77618e404bef">stable_partition</a> (BidirIt f, BidirIt l, Predicate p) -&gt; BidirIt</td></tr>
<tr class="memdesc:a04627f836421020d549c77618e404bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved.  <a href="namespaceetl.html#a04627f836421020d549c77618e404bef">More...</a><br /></td></tr>
<tr class="separator:a04627f836421020d549c77618e404bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba546db0dc7852f32bae5b43c1cbb973"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:aba546db0dc7852f32bae5b43c1cbb973"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aba546db0dc7852f32bae5b43c1cbb973">stable_sort</a> (RandomIt first, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:aba546db0dc7852f32bae5b43c1cbb973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equivalent elements is guaranteed to be preserved. Elements are compared using the given comparison function comp.  <a href="namespaceetl.html#aba546db0dc7852f32bae5b43c1cbb973">More...</a><br /></td></tr>
<tr class="separator:aba546db0dc7852f32bae5b43c1cbb973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018602a1181cba5553c619612ae2bf58"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:a018602a1181cba5553c619612ae2bf58"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a018602a1181cba5553c619612ae2bf58">stable_sort</a> (RandomIt first, RandomIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="separator:a018602a1181cba5553c619612ae2bf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2864370cd9173ff7ac8fb507dd6779a"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:ab2864370cd9173ff7ac8fb507dd6779a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab2864370cd9173ff7ac8fb507dd6779a">swap_ranges</a> (ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2) -&gt; ForwardIt2</td></tr>
<tr class="memdesc:ab2864370cd9173ff7ac8fb507dd6779a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges elements between range <code>[first1 ,last1)</code> and another range starting at <code>first2</code>.  <a href="namespaceetl.html#ab2864370cd9173ff7ac8fb507dd6779a">More...</a><br /></td></tr>
<tr class="separator:ab2864370cd9173ff7ac8fb507dd6779a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4467ebe5b0d985e1661eb04cb65fab6a"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename UnaryOp &gt; </td></tr>
<tr class="memitem:a4467ebe5b0d985e1661eb04cb65fab6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4467ebe5b0d985e1661eb04cb65fab6a">transform</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt dest, UnaryOp op) -&gt; OutputIt</td></tr>
<tr class="memdesc:a4467ebe5b0d985e1661eb04cb65fab6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function to a range and stores the result in another range, beginning at dest. The unary operation op is applied to the range defined by <code>[first, last)</code>.  <a href="namespaceetl.html#a4467ebe5b0d985e1661eb04cb65fab6a">More...</a><br /></td></tr>
<tr class="separator:a4467ebe5b0d985e1661eb04cb65fab6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2860fb376fc216b93922e036f8ead03"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename BinaryOp &gt; </td></tr>
<tr class="memitem:ab2860fb376fc216b93922e036f8ead03"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab2860fb376fc216b93922e036f8ead03">transform</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt dest, BinaryOp op) -&gt; OutputIt</td></tr>
<tr class="separator:ab2860fb376fc216b93922e036f8ead03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9322bfeec8125aeb86d43fee6fade"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:a8ff9322bfeec8125aeb86d43fee6fade"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8ff9322bfeec8125aeb86d43fee6fade">unique</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate pred) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a8ff9322bfeec8125aeb86d43fee6fade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range.  <a href="namespaceetl.html#a8ff9322bfeec8125aeb86d43fee6fade">More...</a><br /></td></tr>
<tr class="separator:a8ff9322bfeec8125aeb86d43fee6fade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438b893eeeaa7e54c01596344dbc939d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:a438b893eeeaa7e54c01596344dbc939d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a438b893eeeaa7e54c01596344dbc939d">unique</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a438b893eeeaa7e54c01596344dbc939d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range.  <a href="namespaceetl.html#a438b893eeeaa7e54c01596344dbc939d">More...</a><br /></td></tr>
<tr class="separator:a438b893eeeaa7e54c01596344dbc939d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e100f1e4a026e9d4789c972b7a4c8d"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ab8e100f1e4a026e9d4789c972b7a4c8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab8e100f1e4a026e9d4789c972b7a4c8d">unique_copy</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination, Predicate pred) -&gt; OutputIt</td></tr>
<tr class="memdesc:ab8e100f1e4a026e9d4789c972b7a4c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.  <a href="namespaceetl.html#ab8e100f1e4a026e9d4789c972b7a4c8d">More...</a><br /></td></tr>
<tr class="separator:ab8e100f1e4a026e9d4789c972b7a4c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63f087df9180e1901cc4105a3a0363"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:a7c63f087df9180e1901cc4105a3a0363"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7c63f087df9180e1901cc4105a3a0363">unique_copy</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:a7c63f087df9180e1901cc4105a3a0363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.  <a href="namespaceetl.html#a7c63f087df9180e1901cc4105a3a0363">More...</a><br /></td></tr>
<tr class="separator:a7c63f087df9180e1901cc4105a3a0363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b32d22be5cb9bbaaf24e21d8b700bcb"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:a9b32d22be5cb9bbaaf24e21d8b700bcb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9b32d22be5cb9bbaaf24e21d8b700bcb">upper_bound</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, Compare comp) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a9b32d22be5cb9bbaaf24e21d8b700bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is greater than <code>value</code>, or last if no such element is found.  <a href="namespaceetl.html#a9b32d22be5cb9bbaaf24e21d8b700bcb">More...</a><br /></td></tr>
<tr class="separator:a9b32d22be5cb9bbaaf24e21d8b700bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3448c90cac95ec2e155cf8ac02b6c592"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:a3448c90cac95ec2e155cf8ac02b6c592"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3448c90cac95ec2e155cf8ac02b6c592">upper_bound</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; ForwardIt</td></tr>
<tr class="separator:a3448c90cac95ec2e155cf8ac02b6c592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a13233ebf471c62f35f40b21128884"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... U&gt; </td></tr>
<tr class="memitem:ae5a13233ebf471c62f35f40b21128884"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae5a13233ebf471c62f35f40b21128884">array</a> (T, U...) -&gt; <a class="el" href="structetl_1_1array.html">array</a>&lt; T, 1+sizeof...(U)&gt;</td></tr>
<tr class="separator:ae5a13233ebf471c62f35f40b21128884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad707bbff2e759a5d868a7bfb7d6bc4c5"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ad707bbff2e759a5d868a7bfb7d6bc4c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5">swap</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(lhs.swap(rhs))) -&gt; void</td></tr>
<tr class="memdesc:ad707bbff2e759a5d868a7bfb7d6bc4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for array. Swaps the contents of lhs and rhs.  <a href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5">More...</a><br /></td></tr>
<tr class="separator:ad707bbff2e759a5d868a7bfb7d6bc4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78053f3dad1753bf6896680da407b07"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ad78053f3dad1753bf6896680da407b07"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad78053f3dad1753bf6896680da407b07">operator==</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ad78053f3dad1753bf6896680da407b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position.  <a href="namespaceetl.html#ad78053f3dad1753bf6896680da407b07">More...</a><br /></td></tr>
<tr class="separator:ad78053f3dad1753bf6896680da407b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147d125b8b1ac3e64edd3a64e62f28f0"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a147d125b8b1ac3e64edd3a64e62f28f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a147d125b8b1ac3e64edd3a64e62f28f0">operator!=</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="separator:a147d125b8b1ac3e64edd3a64e62f28f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabb772977543ab7c5b19143ff371cff"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aaabb772977543ab7c5b19143ff371cff"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaabb772977543ab7c5b19143ff371cff">operator&lt;</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:aaabb772977543ab7c5b19143ff371cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare.  <a href="namespaceetl.html#aaabb772977543ab7c5b19143ff371cff">More...</a><br /></td></tr>
<tr class="separator:aaabb772977543ab7c5b19143ff371cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6a8d3734cee3199f36a9c97e00e286"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a6f6a8d3734cee3199f36a9c97e00e286"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6f6a8d3734cee3199f36a9c97e00e286">operator&lt;=</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="separator:a6f6a8d3734cee3199f36a9c97e00e286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1451f7dad0eb2205217d548a8f9583"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a6c1451f7dad0eb2205217d548a8f9583"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6c1451f7dad0eb2205217d548a8f9583">operator&gt;</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="separator:a6c1451f7dad0eb2205217d548a8f9583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39feefa1e12cd8485e5ac5b1cf25ca5a"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a39feefa1e12cd8485e5ac5b1cf25ca5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a39feefa1e12cd8485e5ac5b1cf25ca5a">operator&gt;=</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="separator:a39feefa1e12cd8485e5ac5b1cf25ca5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b7094f524bee0b6d0e32e83e6d18e2"><td class="memTemplParams" colspan="2">template&lt;size_t Index, typename T , size_t Size&gt; </td></tr>
<tr class="memitem:a86b7094f524bee0b6d0e32e83e6d18e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a86b7094f524bee0b6d0e32e83e6d18e2">get</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; &amp;<a class="el" href="structetl_1_1array.html">array</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T &amp;</td></tr>
<tr class="memdesc:a86b7094f524bee0b6d0e32e83e6d18e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the Ith element element from the array. I must be an integer value in range [0, N). This is enforced at compile time as opposed to at() or operator[].  <a href="namespaceetl.html#a86b7094f524bee0b6d0e32e83e6d18e2">More...</a><br /></td></tr>
<tr class="separator:a86b7094f524bee0b6d0e32e83e6d18e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a288e79c781974b0178e21cc9cc012"><td class="memTemplParams" colspan="2">template&lt;size_t Index, typename T , size_t Size&gt; </td></tr>
<tr class="memitem:a55a288e79c781974b0178e21cc9cc012"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a55a288e79c781974b0178e21cc9cc012">get</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; const &amp;<a class="el" href="structetl_1_1array.html">array</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T const &amp;</td></tr>
<tr class="separator:a55a288e79c781974b0178e21cc9cc012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac584a8e745af05dc346a19d0395a878b"><td class="memTemplParams" colspan="2">template&lt;size_t Index, typename T , size_t Size&gt; </td></tr>
<tr class="memitem:ac584a8e745af05dc346a19d0395a878b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac584a8e745af05dc346a19d0395a878b">get</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; &amp;&amp;<a class="el" href="structetl_1_1array.html">array</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T &amp;&amp;</td></tr>
<tr class="separator:ac584a8e745af05dc346a19d0395a878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631f38db521ab83ff5467fb29405d74a"><td class="memTemplParams" colspan="2">template&lt;size_t Index, typename T , size_t Size&gt; </td></tr>
<tr class="memitem:a631f38db521ab83ff5467fb29405d74a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a631f38db521ab83ff5467fb29405d74a">get</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; const &amp;&amp;<a class="el" href="structetl_1_1array.html">array</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T const &amp;&amp;</td></tr>
<tr class="separator:a631f38db521ab83ff5467fb29405d74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52800519f8ed99c7279ac0e850ab049"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ac52800519f8ed99c7279ac0e850ab049"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac52800519f8ed99c7279ac0e850ab049">to_array</a> (T(&amp;a)[N]) -&gt; <a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">remove_cv_t</a>&lt; T &gt;, N &gt;</td></tr>
<tr class="memdesc:ac52800519f8ed99c7279ac0e850ab049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a array from the one dimensional built-in array a. The elements of the array are copy-initialized from the corresponding element of a. Copying or moving multidimensional built-in array is not supported.  <a href="namespaceetl.html#ac52800519f8ed99c7279ac0e850ab049">More...</a><br /></td></tr>
<tr class="separator:ac52800519f8ed99c7279ac0e850ab049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa365aab3fcf0745f5ea688b372f3aca7"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aa365aab3fcf0745f5ea688b372f3aca7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa365aab3fcf0745f5ea688b372f3aca7">to_array</a> (T(&amp;&amp;a)[N])</td></tr>
<tr class="separator:aa365aab3fcf0745f5ea688b372f3aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877cfa73ea6690339843c3f5b79ca3a7"><td class="memTemplParams" colspan="2">template&lt;etl::detail::sufficiently_trivial T, etl::size_t Size&gt; </td></tr>
<tr class="memitem:a877cfa73ea6690339843c3f5b79ca3a7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a877cfa73ea6690339843c3f5b79ca3a7">requires</a> (<a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> !=0) struct <a class="el" href="structetl_1_1uninitialized__array.html">uninitialized_array</a>&lt; T</td></tr>
<tr class="separator:a877cfa73ea6690339843c3f5b79ca3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321af167e669a0c72a867748fffff377"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a321af167e669a0c72a867748fffff377">uninitialized_array</a> ()=default</td></tr>
<tr class="separator:a321af167e669a0c72a867748fffff377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c0bdae2655a0ed9121aeca58640e9a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab6c0bdae2655a0ed9121aeca58640e9a">data</a> () const <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T const *</td></tr>
<tr class="separator:ab6c0bdae2655a0ed9121aeca58640e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db1ad433c808f8aabe48a2061e633dc"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0db1ad433c808f8aabe48a2061e633dc">size</a> () <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></td></tr>
<tr class="separator:a0db1ad433c808f8aabe48a2061e633dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2836fac65c2a00e47c70508d8d837b3e"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a2836fac65c2a00e47c70508d8d837b3e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2836fac65c2a00e47c70508d8d837b3e">requires</a> (detail::bit_castable_types&lt; To, From &gt;) const expr auto bit_cast(From const &amp;src) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; To</td></tr>
<tr class="memdesc:a2836fac65c2a00e47c70508d8d837b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a value of type To by reinterpreting the object representation of from. Every bit in the value representation of the returned To object is equal to the corresponding bit in the object representation of from.  <a href="namespaceetl.html#a2836fac65c2a00e47c70508d8d837b3e">More...</a><br /></td></tr>
<tr class="separator:a2836fac65c2a00e47c70508d8d837b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa397d9f8380425b5e72d55d7f7f16b10"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:aa397d9f8380425b5e72d55d7f7f16b10"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa397d9f8380425b5e72d55d7f7f16b10">bit_ceil</a> (UInt x) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; UInt</td></tr>
<tr class="memdesc:aa397d9f8380425b5e72d55d7f7f16b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the smallest integral power of two that is not smaller than x. If that value is not representable in UInt, the behavior is undefined. Call to this function is permitted in constant evaluation only if the undefined behavior does not occur.  <a href="namespaceetl.html#aa397d9f8380425b5e72d55d7f7f16b10">More...</a><br /></td></tr>
<tr class="separator:aa397d9f8380425b5e72d55d7f7f16b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344157c15560dd640719de8ecf9a311a"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a344157c15560dd640719de8ecf9a311a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a344157c15560dd640719de8ecf9a311a">bit_floor</a> (UInt x) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; UInt</td></tr>
<tr class="memdesc:a344157c15560dd640719de8ecf9a311a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x is not zero, calculates the largest integral power of two that is not greater than x. If x is zero, returns zero.  <a href="namespaceetl.html#a344157c15560dd640719de8ecf9a311a">More...</a><br /></td></tr>
<tr class="separator:a344157c15560dd640719de8ecf9a311a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9cca4b68917b48f46849a03007d9a9"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a7f9cca4b68917b48f46849a03007d9a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7f9cca4b68917b48f46849a03007d9a9">bit_width</a> (UInt x) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a7f9cca4b68917b48f46849a03007d9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x is not zero, calculates the number of bits needed to store the value x, that is, 1+⌊log2(x)⌋. If x is zero, returns zero.  <a href="namespaceetl.html#a7f9cca4b68917b48f46849a03007d9a9">More...</a><br /></td></tr>
<tr class="separator:a7f9cca4b68917b48f46849a03007d9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4adeee8eaea36f5d0716abfe81148ba"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ad4adeee8eaea36f5d0716abfe81148ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad4adeee8eaea36f5d0716abfe81148ba">byteswap</a> (T <a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T</td></tr>
<tr class="memdesc:ad4adeee8eaea36f5d0716abfe81148ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the bytes in the given integer value n.  <a href="namespaceetl.html#ad4adeee8eaea36f5d0716abfe81148ba">More...</a><br /></td></tr>
<tr class="separator:ad4adeee8eaea36f5d0716abfe81148ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce080db93d1da7b7ac5322f3edab4fa"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a4ce080db93d1da7b7ac5322f3edab4fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4ce080db93d1da7b7ac5322f3edab4fa">countl_one</a> (UInt x) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a4ce080db93d1da7b7ac5322f3edab4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 1 ("one") bits in the value of x, starting from the most significant bit ("left").  <a href="namespaceetl.html#a4ce080db93d1da7b7ac5322f3edab4fa">More...</a><br /></td></tr>
<tr class="separator:a4ce080db93d1da7b7ac5322f3edab4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6df380fce74364ad8da2b39c516c24e"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:ac6df380fce74364ad8da2b39c516c24e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac6df380fce74364ad8da2b39c516c24e">countl_zero</a> (UInt x) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:ac6df380fce74364ad8da2b39c516c24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 0 bits in the value of x, starting from the most significant bit ("left").  <a href="namespaceetl.html#ac6df380fce74364ad8da2b39c516c24e">More...</a><br /></td></tr>
<tr class="separator:ac6df380fce74364ad8da2b39c516c24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3fbba99f7fed7abe96381c03de2e54"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a0e3fbba99f7fed7abe96381c03de2e54"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0e3fbba99f7fed7abe96381c03de2e54">countr_one</a> (UInt x) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a0e3fbba99f7fed7abe96381c03de2e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 1 bits in the value of x, starting from the least significant bit ("right").  <a href="namespaceetl.html#a0e3fbba99f7fed7abe96381c03de2e54">More...</a><br /></td></tr>
<tr class="separator:a0e3fbba99f7fed7abe96381c03de2e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5490ba02f948e6f27acbe515d47eab"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a9a5490ba02f948e6f27acbe515d47eab"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9a5490ba02f948e6f27acbe515d47eab">countr_zero</a> (UInt x) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a9a5490ba02f948e6f27acbe515d47eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 0 bits in the value of x, starting from the least significant bit ("right").  <a href="namespaceetl.html#a9a5490ba02f948e6f27acbe515d47eab">More...</a><br /></td></tr>
<tr class="separator:a9a5490ba02f948e6f27acbe515d47eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0997ae09365ac687cb26999f55fbe724"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a0997ae09365ac687cb26999f55fbe724"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0997ae09365ac687cb26999f55fbe724">flip_bit</a> (UInt <a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>, UInt bit) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; UInt</td></tr>
<tr class="separator:a0997ae09365ac687cb26999f55fbe724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4862a11212e1db1497182b3c5e7acab4"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Bit, etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a4862a11212e1db1497182b3c5e7acab4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4862a11212e1db1497182b3c5e7acab4">flip_bit</a> (UInt <a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; UInt</td></tr>
<tr class="separator:a4862a11212e1db1497182b3c5e7acab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af064bf9681c55a5f04915eeceb13348a"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:af064bf9681c55a5f04915eeceb13348a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af064bf9681c55a5f04915eeceb13348a">has_single_bit</a> (UInt x) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:af064bf9681c55a5f04915eeceb13348a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if x is an integral power of two.  <a href="namespaceetl.html#af064bf9681c55a5f04915eeceb13348a">More...</a><br /></td></tr>
<tr class="separator:af064bf9681c55a5f04915eeceb13348a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec2a511f8b5137e02416b9e4e8dc237"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a6ec2a511f8b5137e02416b9e4e8dc237"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6ec2a511f8b5137e02416b9e4e8dc237">operator&amp;</a> (T x, T y) -&gt; T</td></tr>
<tr class="separator:a6ec2a511f8b5137e02416b9e4e8dc237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cb02b81d1ba34fc33b94555749fa92"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:ac3cb02b81d1ba34fc33b94555749fa92"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac3cb02b81d1ba34fc33b94555749fa92">operator|</a> (T x, T y) -&gt; T</td></tr>
<tr class="separator:ac3cb02b81d1ba34fc33b94555749fa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af622835231ee77bf2d29dd490bcbb2bf"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:af622835231ee77bf2d29dd490bcbb2bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af622835231ee77bf2d29dd490bcbb2bf">operator^</a> (T x, T y) -&gt; T</td></tr>
<tr class="separator:af622835231ee77bf2d29dd490bcbb2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92caafb1e73d48a1d1847f64093be44c"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a92caafb1e73d48a1d1847f64093be44c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a92caafb1e73d48a1d1847f64093be44c">operator~</a> (T x) -&gt; T</td></tr>
<tr class="separator:a92caafb1e73d48a1d1847f64093be44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e027dfa37f613a9d94fe1ee90e7517"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:ad2e027dfa37f613a9d94fe1ee90e7517"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad2e027dfa37f613a9d94fe1ee90e7517">operator|=</a> (T &amp;x, T y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T const &amp;</td></tr>
<tr class="separator:ad2e027dfa37f613a9d94fe1ee90e7517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc72777ea30905ff52e4ce6d3448b3e8"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:abc72777ea30905ff52e4ce6d3448b3e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abc72777ea30905ff52e4ce6d3448b3e8">operator&amp;=</a> (T &amp;x, T y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T const &amp;</td></tr>
<tr class="separator:abc72777ea30905ff52e4ce6d3448b3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f94aefe628a0474274befd3437bf64"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a79f94aefe628a0474274befd3437bf64"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a79f94aefe628a0474274befd3437bf64">operator^=</a> (T &amp;x, T y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T const &amp;</td></tr>
<tr class="separator:a79f94aefe628a0474274befd3437bf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e754daac238cd635c52a571019370d9"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a9e754daac238cd635c52a571019370d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9e754daac238cd635c52a571019370d9">popcount</a> (UInt <a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a9e754daac238cd635c52a571019370d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 1 bits in the value of x.  <a href="namespaceetl.html#a9e754daac238cd635c52a571019370d9">More...</a><br /></td></tr>
<tr class="separator:a9e754daac238cd635c52a571019370d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9159d861c5d8c5ed5708b8381fa19a"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:ace9159d861c5d8c5ed5708b8381fa19a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ace9159d861c5d8c5ed5708b8381fa19a">reset_bit</a> (UInt <a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>, UInt bit) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; UInt</td></tr>
<tr class="separator:ace9159d861c5d8c5ed5708b8381fa19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd9ef98d7cd14ca276c8df92dc00a64"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Bit, etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:aecd9ef98d7cd14ca276c8df92dc00a64"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aecd9ef98d7cd14ca276c8df92dc00a64">reset_bit</a> (UInt <a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; UInt</td></tr>
<tr class="separator:aecd9ef98d7cd14ca276c8df92dc00a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbf35871b94190f98acbfc57d75c63c"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a0bbf35871b94190f98acbfc57d75c63c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0bbf35871b94190f98acbfc57d75c63c">rotl</a> (UInt t, int s) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; UInt</td></tr>
<tr class="memdesc:a0bbf35871b94190f98acbfc57d75c63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the result of bitwise left-rotating the value of x by s positions. This operation is also known as a left circular shift.  <a href="namespaceetl.html#a0bbf35871b94190f98acbfc57d75c63c">More...</a><br /></td></tr>
<tr class="separator:a0bbf35871b94190f98acbfc57d75c63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ebdfe26048f199e0778622f63a6653"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a74ebdfe26048f199e0778622f63a6653"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a74ebdfe26048f199e0778622f63a6653">rotr</a> (UInt t, int s) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; UInt</td></tr>
<tr class="memdesc:a74ebdfe26048f199e0778622f63a6653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the result of bitwise right-rotating the value of x by s positions. This operation is also known as a right circular shift.  <a href="namespaceetl.html#a74ebdfe26048f199e0778622f63a6653">More...</a><br /></td></tr>
<tr class="separator:a74ebdfe26048f199e0778622f63a6653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8da66a736f8e15a2cf4dd681f6ab863"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:af8da66a736f8e15a2cf4dd681f6ab863"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8da66a736f8e15a2cf4dd681f6ab863">set_bit</a> (UInt <a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>, UInt bit) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; UInt</td></tr>
<tr class="separator:af8da66a736f8e15a2cf4dd681f6ab863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a5560970454768aa47bb8d4c5722ee"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Bit, etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a84a5560970454768aa47bb8d4c5722ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a84a5560970454768aa47bb8d4c5722ee">set_bit</a> (UInt <a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; UInt</td></tr>
<tr class="separator:a84a5560970454768aa47bb8d4c5722ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6446130881cadc4edfba7f0ec4b01d5f"><td class="memTemplParams" colspan="2">template&lt;etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a6446130881cadc4edfba7f0ec4b01d5f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6446130881cadc4edfba7f0ec4b01d5f">test_bit</a> (UInt <a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>, UInt bit) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a6446130881cadc4edfba7f0ec4b01d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d062f57d0edbd6d850d13e600e385ee"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Bit, etl::standard_unsigned_integer UInt&gt; </td></tr>
<tr class="memitem:a4d062f57d0edbd6d850d13e600e385ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4d062f57d0edbd6d850d13e600e385ee">test_bit</a> (UInt <a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a4d062f57d0edbd6d850d13e600e385ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaaf991a15c82d1ea08c9932f513126"><td class="memTemplParams" colspan="2">template&lt;etl::size_t N&gt; </td></tr>
<tr class="memitem:a6eaaf991a15c82d1ea08c9932f513126"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6eaaf991a15c82d1ea08c9932f513126">operator&amp;</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt;</td></tr>
<tr class="memdesc:a6eaaf991a15c82d1ea08c9932f513126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary AND between two bitsets, lhs and rhs.  <a href="namespaceetl.html#a6eaaf991a15c82d1ea08c9932f513126">More...</a><br /></td></tr>
<tr class="separator:a6eaaf991a15c82d1ea08c9932f513126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad704bd3a387f58880d2d97024dea9e71"><td class="memTemplParams" colspan="2">template&lt;etl::size_t N&gt; </td></tr>
<tr class="memitem:ad704bd3a387f58880d2d97024dea9e71"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad704bd3a387f58880d2d97024dea9e71">operator|</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt;</td></tr>
<tr class="memdesc:ad704bd3a387f58880d2d97024dea9e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary OR between two bitsets, lhs and rhs.  <a href="namespaceetl.html#ad704bd3a387f58880d2d97024dea9e71">More...</a><br /></td></tr>
<tr class="separator:ad704bd3a387f58880d2d97024dea9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7238e53a5804e54ed1c1fbeb962f74b1"><td class="memTemplParams" colspan="2">template&lt;etl::size_t N&gt; </td></tr>
<tr class="memitem:a7238e53a5804e54ed1c1fbeb962f74b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7238e53a5804e54ed1c1fbeb962f74b1">operator^</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt;</td></tr>
<tr class="memdesc:a7238e53a5804e54ed1c1fbeb962f74b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary XOR between two bitsets, lhs and rhs.  <a href="namespaceetl.html#a7238e53a5804e54ed1c1fbeb962f74b1">More...</a><br /></td></tr>
<tr class="separator:a7238e53a5804e54ed1c1fbeb962f74b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57d9658b5bfda3c9dc53d1a0bd95ca7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad57d9658b5bfda3c9dc53d1a0bd95ca7">default_assert_handler</a> (<a class="el" href="structetl_1_1assert__msg.html">assert_msg</a> const &amp;msg) -&gt; void</td></tr>
<tr class="memdesc:ad57d9658b5bfda3c9dc53d1a0bd95ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default assert handler. This will be called, if an assertion is triggered at runtime.  <a href="namespaceetl.html#ad57d9658b5bfda3c9dc53d1a0bd95ca7">More...</a><br /></td></tr>
<tr class="separator:ad57d9658b5bfda3c9dc53d1a0bd95ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebfa4dc6da592b5c2d73f10ba7490dc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0ebfa4dc6da592b5c2d73f10ba7490dc">isalnum</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a0ebfa4dc6da592b5c2d73f10ba7490dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is an alphanumeric character as classified by the default C locale.  <a href="namespaceetl.html#a0ebfa4dc6da592b5c2d73f10ba7490dc">More...</a><br /></td></tr>
<tr class="separator:a0ebfa4dc6da592b5c2d73f10ba7490dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ad095d93b811823b48e7b0486be7de"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a89ad095d93b811823b48e7b0486be7de">isalpha</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a89ad095d93b811823b48e7b0486be7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is an alphabetic character as classified by the default C locale.  <a href="namespaceetl.html#a89ad095d93b811823b48e7b0486be7de">More...</a><br /></td></tr>
<tr class="separator:a89ad095d93b811823b48e7b0486be7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca9707732972162ec02317639d2154b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acca9707732972162ec02317639d2154b">isblank</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:acca9707732972162ec02317639d2154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (0x20) and horizontal tab (0x09) are classified as blank characters.  <a href="namespaceetl.html#acca9707732972162ec02317639d2154b">More...</a><br /></td></tr>
<tr class="separator:acca9707732972162ec02317639d2154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037d91a684e54521c31eefa609c57f0f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a037d91a684e54521c31eefa609c57f0f">iscntrl</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a037d91a684e54521c31eefa609c57f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a control character as classified by the currently installed C locale. In the default, "C" locale, the control characters are the characters with the codes 0x00-0x1F and 0x7F.  <a href="namespaceetl.html#a037d91a684e54521c31eefa609c57f0f">More...</a><br /></td></tr>
<tr class="separator:a037d91a684e54521c31eefa609c57f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743aaa8e35549baecb60a7a37fbccb7a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a743aaa8e35549baecb60a7a37fbccb7a">isdigit</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a743aaa8e35549baecb60a7a37fbccb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is one of the 10 decimal digits: 0123456789.  <a href="namespaceetl.html#a743aaa8e35549baecb60a7a37fbccb7a">More...</a><br /></td></tr>
<tr class="separator:a743aaa8e35549baecb60a7a37fbccb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcb7b22dcd166bd67a94b6b7f7da42e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3fcb7b22dcd166bd67a94b6b7f7da42e">isgraph</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a3fcb7b22dcd166bd67a94b6b7f7da42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is graphic (has a graphical representation) as classified by the default C locale.  <a href="namespaceetl.html#a3fcb7b22dcd166bd67a94b6b7f7da42e">More...</a><br /></td></tr>
<tr class="separator:a3fcb7b22dcd166bd67a94b6b7f7da42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334ab4709b4cf8c1f5053016825c3bd7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a334ab4709b4cf8c1f5053016825c3bd7">islower</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a334ab4709b4cf8c1f5053016825c3bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is classified as a lowercase character according to the default C locale.  <a href="namespaceetl.html#a334ab4709b4cf8c1f5053016825c3bd7">More...</a><br /></td></tr>
<tr class="separator:a334ab4709b4cf8c1f5053016825c3bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da49fe7c1e61918bbf7dd210e655d8c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8da49fe7c1e61918bbf7dd210e655d8c">isprint</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a8da49fe7c1e61918bbf7dd210e655d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if ch is a printable character as classified by the default C locale.  <a href="namespaceetl.html#a8da49fe7c1e61918bbf7dd210e655d8c">More...</a><br /></td></tr>
<tr class="separator:a8da49fe7c1e61918bbf7dd210e655d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531a127903fbd0d7545d9a69bf13bb3c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a531a127903fbd0d7545d9a69bf13bb3c">ispunct</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a531a127903fbd0d7545d9a69bf13bb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a punctuation character as classified by the current C locale.  <a href="namespaceetl.html#a531a127903fbd0d7545d9a69bf13bb3c">More...</a><br /></td></tr>
<tr class="separator:a531a127903fbd0d7545d9a69bf13bb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c87145259e2ce0061ac810fee723978"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3c87145259e2ce0061ac810fee723978">isspace</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a3c87145259e2ce0061ac810fee723978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is whitespace character as classified by the default C locale.  <a href="namespaceetl.html#a3c87145259e2ce0061ac810fee723978">More...</a><br /></td></tr>
<tr class="separator:a3c87145259e2ce0061ac810fee723978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1e3ecf65c20a6bd5f0b06139694269"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2b1e3ecf65c20a6bd5f0b06139694269">isupper</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a2b1e3ecf65c20a6bd5f0b06139694269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is classified as a uppercase character according to the default C locale.  <a href="namespaceetl.html#a2b1e3ecf65c20a6bd5f0b06139694269">More...</a><br /></td></tr>
<tr class="separator:a2b1e3ecf65c20a6bd5f0b06139694269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b0bd8474428652100d3db55092e788"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a77b0bd8474428652100d3db55092e788">isxdigit</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a77b0bd8474428652100d3db55092e788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a hexadecimal numeric character (0123456789abcdefABCDEF).  <a href="namespaceetl.html#a77b0bd8474428652100d3db55092e788">More...</a><br /></td></tr>
<tr class="separator:a77b0bd8474428652100d3db55092e788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b969e80e81b5a412d56884fc5bfcf2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a25b969e80e81b5a412d56884fc5bfcf2">tolower</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a25b969e80e81b5a412d56884fc5bfcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given character to lowercase according to the character conversion rules defined by the default C locale.  <a href="namespaceetl.html#a25b969e80e81b5a412d56884fc5bfcf2">More...</a><br /></td></tr>
<tr class="separator:a25b969e80e81b5a412d56884fc5bfcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b46f5faca236c0de0b9f378c22498c1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2b46f5faca236c0de0b9f378c22498c1">toupper</a> (int ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a2b46f5faca236c0de0b9f378c22498c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given character to uppercase according to the character conversion rules defined by the default C locale.  <a href="namespaceetl.html#a2b46f5faca236c0de0b9f378c22498c1">More...</a><br /></td></tr>
<tr class="separator:a2b46f5faca236c0de0b9f378c22498c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1ffcebf3ee4f04cf5987def83d0070"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1c1ffcebf3ee4f04cf5987def83d0070">isfinite</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a1c1ffcebf3ee4f04cf5987def83d0070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587d2d42acd3ff40d56a98cdb84e1f57"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a587d2d42acd3ff40d56a98cdb84e1f57">isinf</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a587d2d42acd3ff40d56a98cdb84e1f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8311e8c453fbb5b2e5eea1ed6aead74"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae8311e8c453fbb5b2e5eea1ed6aead74">isnan</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:ae8311e8c453fbb5b2e5eea1ed6aead74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8840adb5e14e1239b4830cdd7e17f29"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab8840adb5e14e1239b4830cdd7e17f29">isnormal</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:ab8840adb5e14e1239b4830cdd7e17f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f672431014d52f52f9ce327fd19b81"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a92f672431014d52f52f9ce327fd19b81">signbit</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a92f672431014d52f52f9ce327fd19b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af75f924fd190d7f6d474cb87ef402f"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a3af75f924fd190d7f6d474cb87ef402f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3af75f924fd190d7f6d474cb87ef402f">requires</a> (not <a class="el" href="namespaceetl.html#aa602e717add57122f28f5186a8399a87">same_as</a>&lt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>, bool &gt;) const expr auto from_chars(char const *first</td></tr>
<tr class="memdesc:a3af75f924fd190d7f6d474cb87ef402f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes the character sequence [first,last) for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.  <a href="namespaceetl.html#a3af75f924fd190d7f6d474cb87ef402f">More...</a><br /></td></tr>
<tr class="separator:a3af75f924fd190d7f6d474cb87ef402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452f2e21f389de11e116d5ebf191b039"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a452f2e21f389de11e116d5ebf191b039"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a452f2e21f389de11e116d5ebf191b039">requires</a> (not <a class="el" href="namespaceetl.html#aa602e717add57122f28f5186a8399a87">same_as</a>&lt; T, bool &gt;) const expr auto to_chars(char *first</td></tr>
<tr class="memdesc:a452f2e21f389de11e116d5ebf191b039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range.  <a href="namespaceetl.html#a452f2e21f389de11e116d5ebf191b039">More...</a><br /></td></tr>
<tr class="separator:a452f2e21f389de11e116d5ebf191b039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4847ea4260b5b202b578c17d63084aa8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a4847ea4260b5b202b578c17d63084aa8">operator&quot;&quot;_d</a> (unsigned long long d) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1chrono_1_1day.html">etl::chrono::day</a></td></tr>
<tr class="memdesc:a4847ea4260b5b202b578c17d63084aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1day.html">etl::chrono::day</a> literal representing a day of the month in the calendar.  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#a4847ea4260b5b202b578c17d63084aa8">More...</a><br /></td></tr>
<tr class="separator:a4847ea4260b5b202b578c17d63084aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af259e8983c5c9a8c67cf23ad8d93b741"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#af259e8983c5c9a8c67cf23ad8d93b741">operator&quot;&quot;_h</a> (unsigned long long h) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#aa604e90bcb67d1781a453bae7c48df85">etl::chrono::hours</a></td></tr>
<tr class="memdesc:af259e8983c5c9a8c67cf23ad8d93b741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing hours. Integer literal, returns exactly etl::chrono::hours(hrs).  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#af259e8983c5c9a8c67cf23ad8d93b741">More...</a><br /></td></tr>
<tr class="separator:af259e8983c5c9a8c67cf23ad8d93b741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf173450aaea802e3abf0e2a62315e3f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#abf173450aaea802e3abf0e2a62315e3f">operator&quot;&quot;_h</a> (long double h) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; long double, <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 3600, 1 &gt;&gt;</td></tr>
<tr class="memdesc:abf173450aaea802e3abf0e2a62315e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing hours. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#aa604e90bcb67d1781a453bae7c48df85" title="Signed integer type of at least 23 bits.">etl::chrono::hours</a>.  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#abf173450aaea802e3abf0e2a62315e3f">More...</a><br /></td></tr>
<tr class="separator:abf173450aaea802e3abf0e2a62315e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562a8614a008f75de13f9aa86715a51d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a562a8614a008f75de13f9aa86715a51d">operator&quot;&quot;_min</a> (unsigned long long m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#a5e9ae03c99fe1e3993f5658053537043">etl::chrono::minutes</a></td></tr>
<tr class="memdesc:a562a8614a008f75de13f9aa86715a51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing minutes. Integer literal, returns exactly etl::chrono::minutes(mins).  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#a562a8614a008f75de13f9aa86715a51d">More...</a><br /></td></tr>
<tr class="separator:a562a8614a008f75de13f9aa86715a51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29692ae001b1d7269cd4ed3aad6a8c80"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a29692ae001b1d7269cd4ed3aad6a8c80">operator&quot;&quot;_min</a> (long double m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; long double, <a class="el" href="structetl_1_1ratio.html">etl::ratio</a>&lt; 60, 1 &gt;&gt;</td></tr>
<tr class="memdesc:a29692ae001b1d7269cd4ed3aad6a8c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing minutes. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#a5e9ae03c99fe1e3993f5658053537043" title="Signed integer type of at least 29 bits.">etl::chrono::minutes</a>.  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#a29692ae001b1d7269cd4ed3aad6a8c80">More...</a><br /></td></tr>
<tr class="separator:a29692ae001b1d7269cd4ed3aad6a8c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6279af29ee2e857c794e7cb76dd6f168"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a6279af29ee2e857c794e7cb76dd6f168">operator&quot;&quot;_s</a> (unsigned long long m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#af54f550a26f87be6356dd53bf7f57943">etl::chrono::seconds</a></td></tr>
<tr class="memdesc:a6279af29ee2e857c794e7cb76dd6f168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing seconds. Integer literal, returns exactly etl::chrono::seconds(mins).  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#a6279af29ee2e857c794e7cb76dd6f168">More...</a><br /></td></tr>
<tr class="separator:a6279af29ee2e857c794e7cb76dd6f168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a70f7deb8345abdf86d83d8cb728a4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a93a70f7deb8345abdf86d83d8cb728a4">operator&quot;&quot;_s</a> (long double m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; long double &gt;</td></tr>
<tr class="memdesc:a93a70f7deb8345abdf86d83d8cb728a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing seconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#af54f550a26f87be6356dd53bf7f57943" title="Signed integer type of at least 35 bits.">etl::chrono::seconds</a>.  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#a93a70f7deb8345abdf86d83d8cb728a4">More...</a><br /></td></tr>
<tr class="separator:a93a70f7deb8345abdf86d83d8cb728a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8644fbcb9057be1a715c64434a21ba4a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a8644fbcb9057be1a715c64434a21ba4a">operator&quot;&quot;_ms</a> (unsigned long long m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#acdcd4aacfedf19ab2aa22fbf7dee3399">etl::chrono::milliseconds</a></td></tr>
<tr class="memdesc:a8644fbcb9057be1a715c64434a21ba4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing milliseconds. Integer literal, returns exactly etl::chrono::milliseconds(mins).  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#a8644fbcb9057be1a715c64434a21ba4a">More...</a><br /></td></tr>
<tr class="separator:a8644fbcb9057be1a715c64434a21ba4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb10e271592550fb371f1023a28a0e30"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#adb10e271592550fb371f1023a28a0e30">operator&quot;&quot;_ms</a> (long double m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; long double, <a class="el" href="namespaceetl.html#afc43923bf9757db3bbaa5a6e4d36a3c6">etl::milli</a> &gt;</td></tr>
<tr class="memdesc:adb10e271592550fb371f1023a28a0e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing milliseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#acdcd4aacfedf19ab2aa22fbf7dee3399" title="Signed integer type of at least 45 bits.">etl::chrono::milliseconds</a>.  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#adb10e271592550fb371f1023a28a0e30">More...</a><br /></td></tr>
<tr class="separator:adb10e271592550fb371f1023a28a0e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ef0829e29219b2ab6327f4de8a7c13"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a56ef0829e29219b2ab6327f4de8a7c13">operator&quot;&quot;_us</a> (unsigned long long m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#a88d49ec5589d6896acd1f1f79ee6e122">etl::chrono::microseconds</a></td></tr>
<tr class="memdesc:a56ef0829e29219b2ab6327f4de8a7c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing microseconds. Integer literal, returns exactly etl::chrono::microseconds(mins).  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#a56ef0829e29219b2ab6327f4de8a7c13">More...</a><br /></td></tr>
<tr class="separator:a56ef0829e29219b2ab6327f4de8a7c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9627a966c293803c6800e039705a129"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#aa9627a966c293803c6800e039705a129">operator&quot;&quot;_us</a> (long double m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; long double, <a class="el" href="namespaceetl.html#a56ee5013d725632677b4d1d93204c07b">etl::micro</a> &gt;</td></tr>
<tr class="memdesc:aa9627a966c293803c6800e039705a129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing microseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#a88d49ec5589d6896acd1f1f79ee6e122" title="Signed integer type of at least 55 bits.">etl::chrono::microseconds</a>.  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#aa9627a966c293803c6800e039705a129">More...</a><br /></td></tr>
<tr class="separator:aa9627a966c293803c6800e039705a129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27e56cd9d11bb474497b44ac055ab65"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#af27e56cd9d11bb474497b44ac055ab65">operator&quot;&quot;_ns</a> (unsigned long long m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#aa36b65d23c7b89bf766171af823f1f69">etl::chrono::nanoseconds</a></td></tr>
<tr class="memdesc:af27e56cd9d11bb474497b44ac055ab65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing nanoseconds. Integer literal, returns exactly etl::chrono::nanoseconds(mins).  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#af27e56cd9d11bb474497b44ac055ab65">More...</a><br /></td></tr>
<tr class="separator:af27e56cd9d11bb474497b44ac055ab65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb3a78ec03bd717efe7ae4f4f0e2d7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#ac6bb3a78ec03bd717efe7ae4f4f0e2d7">operator&quot;&quot;_ns</a> (long double m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; long double, <a class="el" href="namespaceetl.html#ab16ea857b72e93345fcd6fb255f7fe86">etl::nano</a> &gt;</td></tr>
<tr class="memdesc:ac6bb3a78ec03bd717efe7ae4f4f0e2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing nanoseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#aa36b65d23c7b89bf766171af823f1f69" title="Signed integer type of at least 64 bits.">etl::chrono::nanoseconds</a>.  <a href="namespaceetl_1_1literals_1_1chrono__literals.html#ac6bb3a78ec03bd717efe7ae4f4f0e2d7">More...</a><br /></td></tr>
<tr class="separator:ac6bb3a78ec03bd717efe7ae4f4f0e2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ace77006d897bb11f9e75fc01c6d54"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad9ace77006d897bb11f9e75fc01c6d54">acos</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ad9ace77006d897bb11f9e75fc01c6d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>.  <a href="namespaceetl.html#ad9ace77006d897bb11f9e75fc01c6d54">More...</a><br /></td></tr>
<tr class="separator:ad9ace77006d897bb11f9e75fc01c6d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d6dec7881376a3795507e224cfc794"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad6d6dec7881376a3795507e224cfc794">acosf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ad6d6dec7881376a3795507e224cfc794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>.  <a href="namespaceetl.html#ad6d6dec7881376a3795507e224cfc794">More...</a><br /></td></tr>
<tr class="separator:ad6d6dec7881376a3795507e224cfc794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4747095fd6649df58b77e797a7b6a4ae"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4747095fd6649df58b77e797a7b6a4ae">acos</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a4747095fd6649df58b77e797a7b6a4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>.  <a href="namespaceetl.html#a4747095fd6649df58b77e797a7b6a4ae">More...</a><br /></td></tr>
<tr class="separator:a4747095fd6649df58b77e797a7b6a4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab37e22cd4d9b76197860d41f6d61722"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aab37e22cd4d9b76197860d41f6d61722">acos</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:aab37e22cd4d9b76197860d41f6d61722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>.  <a href="namespaceetl.html#aab37e22cd4d9b76197860d41f6d61722">More...</a><br /></td></tr>
<tr class="separator:aab37e22cd4d9b76197860d41f6d61722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f170557969dafd889c9c4af8c86e6f7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1f170557969dafd889c9c4af8c86e6f7">acosl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a1f170557969dafd889c9c4af8c86e6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>.  <a href="namespaceetl.html#a1f170557969dafd889c9c4af8c86e6f7">More...</a><br /></td></tr>
<tr class="separator:a1f170557969dafd889c9c4af8c86e6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca6badc84ba20bc9540c1aecd9ed972"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a5ca6badc84ba20bc9540c1aecd9ed972"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5ca6badc84ba20bc9540c1aecd9ed972">acos</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a5ca6badc84ba20bc9540c1aecd9ed972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>.  <a href="namespaceetl.html#a5ca6badc84ba20bc9540c1aecd9ed972">More...</a><br /></td></tr>
<tr class="separator:a5ca6badc84ba20bc9540c1aecd9ed972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cae0f69c6df3ad62b9d18a2edfe8bd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a90cae0f69c6df3ad62b9d18a2edfe8bd">acosh</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a90cae0f69c6df3ad62b9d18a2edfe8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>.  <a href="namespaceetl.html#a90cae0f69c6df3ad62b9d18a2edfe8bd">More...</a><br /></td></tr>
<tr class="separator:a90cae0f69c6df3ad62b9d18a2edfe8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf8da6a971811befc7625a7c6a9c0bf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aadf8da6a971811befc7625a7c6a9c0bf">acoshf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:aadf8da6a971811befc7625a7c6a9c0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>.  <a href="namespaceetl.html#aadf8da6a971811befc7625a7c6a9c0bf">More...</a><br /></td></tr>
<tr class="separator:aadf8da6a971811befc7625a7c6a9c0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f78ba5c1b76fcd56f3de95d66338445"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3f78ba5c1b76fcd56f3de95d66338445">acosh</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a3f78ba5c1b76fcd56f3de95d66338445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>.  <a href="namespaceetl.html#a3f78ba5c1b76fcd56f3de95d66338445">More...</a><br /></td></tr>
<tr class="separator:a3f78ba5c1b76fcd56f3de95d66338445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d388cd651b91d71eeac81bec72bcf1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a24d388cd651b91d71eeac81bec72bcf1">acosh</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a24d388cd651b91d71eeac81bec72bcf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>.  <a href="namespaceetl.html#a24d388cd651b91d71eeac81bec72bcf1">More...</a><br /></td></tr>
<tr class="separator:a24d388cd651b91d71eeac81bec72bcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd4f8c867eb336638c2e85925a11ceb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8cd4f8c867eb336638c2e85925a11ceb">acoshl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a8cd4f8c867eb336638c2e85925a11ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>.  <a href="namespaceetl.html#a8cd4f8c867eb336638c2e85925a11ceb">More...</a><br /></td></tr>
<tr class="separator:a8cd4f8c867eb336638c2e85925a11ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa208046cad1bdd0cefca2833574c9dfa"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:aa208046cad1bdd0cefca2833574c9dfa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa208046cad1bdd0cefca2833574c9dfa">acosh</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:aa208046cad1bdd0cefca2833574c9dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>.  <a href="namespaceetl.html#aa208046cad1bdd0cefca2833574c9dfa">More...</a><br /></td></tr>
<tr class="separator:aa208046cad1bdd0cefca2833574c9dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fb71bd1279ffa3c0ac934adeec55b1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa3fb71bd1279ffa3c0ac934adeec55b1">asin</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:aa3fb71bd1279ffa3c0ac934adeec55b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>.  <a href="namespaceetl.html#aa3fb71bd1279ffa3c0ac934adeec55b1">More...</a><br /></td></tr>
<tr class="separator:aa3fb71bd1279ffa3c0ac934adeec55b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33eb37ff3fb73d04a8d0b6f1a8edf312"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a33eb37ff3fb73d04a8d0b6f1a8edf312">asinf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a33eb37ff3fb73d04a8d0b6f1a8edf312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>.  <a href="namespaceetl.html#a33eb37ff3fb73d04a8d0b6f1a8edf312">More...</a><br /></td></tr>
<tr class="separator:a33eb37ff3fb73d04a8d0b6f1a8edf312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5d32ddd2f8d6786e0f347bbfa9f453"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afd5d32ddd2f8d6786e0f347bbfa9f453">asin</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:afd5d32ddd2f8d6786e0f347bbfa9f453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>.  <a href="namespaceetl.html#afd5d32ddd2f8d6786e0f347bbfa9f453">More...</a><br /></td></tr>
<tr class="separator:afd5d32ddd2f8d6786e0f347bbfa9f453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74316d1000b469ad778ba8be2a7a837d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a74316d1000b469ad778ba8be2a7a837d">asin</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a74316d1000b469ad778ba8be2a7a837d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>.  <a href="namespaceetl.html#a74316d1000b469ad778ba8be2a7a837d">More...</a><br /></td></tr>
<tr class="separator:a74316d1000b469ad778ba8be2a7a837d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938272f1d29c45dfeab834395bca9635"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a938272f1d29c45dfeab834395bca9635">asinl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a938272f1d29c45dfeab834395bca9635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>.  <a href="namespaceetl.html#a938272f1d29c45dfeab834395bca9635">More...</a><br /></td></tr>
<tr class="separator:a938272f1d29c45dfeab834395bca9635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621a072ae9ca2d5a6e7156b82595c520"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a621a072ae9ca2d5a6e7156b82595c520"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a621a072ae9ca2d5a6e7156b82595c520">asin</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a621a072ae9ca2d5a6e7156b82595c520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>.  <a href="namespaceetl.html#a621a072ae9ca2d5a6e7156b82595c520">More...</a><br /></td></tr>
<tr class="separator:a621a072ae9ca2d5a6e7156b82595c520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8f020e1fb089580ce1ce2e92007d03"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aea8f020e1fb089580ce1ce2e92007d03">asinh</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:aea8f020e1fb089580ce1ce2e92007d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>.  <a href="namespaceetl.html#aea8f020e1fb089580ce1ce2e92007d03">More...</a><br /></td></tr>
<tr class="separator:aea8f020e1fb089580ce1ce2e92007d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac985377c2d80c7a118366794fd0e660a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac985377c2d80c7a118366794fd0e660a">asinhf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ac985377c2d80c7a118366794fd0e660a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>.  <a href="namespaceetl.html#ac985377c2d80c7a118366794fd0e660a">More...</a><br /></td></tr>
<tr class="separator:ac985377c2d80c7a118366794fd0e660a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922efdb95c11f4715bcbde248c8079d8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a922efdb95c11f4715bcbde248c8079d8">asinh</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a922efdb95c11f4715bcbde248c8079d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>.  <a href="namespaceetl.html#a922efdb95c11f4715bcbde248c8079d8">More...</a><br /></td></tr>
<tr class="separator:a922efdb95c11f4715bcbde248c8079d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13ae7860d3df16f57de06f8f8eac566"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad13ae7860d3df16f57de06f8f8eac566">asinh</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:ad13ae7860d3df16f57de06f8f8eac566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>.  <a href="namespaceetl.html#ad13ae7860d3df16f57de06f8f8eac566">More...</a><br /></td></tr>
<tr class="separator:ad13ae7860d3df16f57de06f8f8eac566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3742eb491fd2e6a7f8173cb7bbfd01be"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3742eb491fd2e6a7f8173cb7bbfd01be">asinhl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a3742eb491fd2e6a7f8173cb7bbfd01be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>.  <a href="namespaceetl.html#a3742eb491fd2e6a7f8173cb7bbfd01be">More...</a><br /></td></tr>
<tr class="separator:a3742eb491fd2e6a7f8173cb7bbfd01be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979329f95265c316f75cda198a8c6219"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a979329f95265c316f75cda198a8c6219"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a979329f95265c316f75cda198a8c6219">asinh</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a979329f95265c316f75cda198a8c6219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>.  <a href="namespaceetl.html#a979329f95265c316f75cda198a8c6219">More...</a><br /></td></tr>
<tr class="separator:a979329f95265c316f75cda198a8c6219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f8ad4a2909bbebbccfd140525f7c8f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a65f8ad4a2909bbebbccfd140525f7c8f">atan</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a65f8ad4a2909bbebbccfd140525f7c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>.  <a href="namespaceetl.html#a65f8ad4a2909bbebbccfd140525f7c8f">More...</a><br /></td></tr>
<tr class="separator:a65f8ad4a2909bbebbccfd140525f7c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953ddfaa8dc761bf2a3cae7cf03ec743"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a953ddfaa8dc761bf2a3cae7cf03ec743">atanf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a953ddfaa8dc761bf2a3cae7cf03ec743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>.  <a href="namespaceetl.html#a953ddfaa8dc761bf2a3cae7cf03ec743">More...</a><br /></td></tr>
<tr class="separator:a953ddfaa8dc761bf2a3cae7cf03ec743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dbb4af5e9f689d738347804fd05f90"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a11dbb4af5e9f689d738347804fd05f90">atan</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a11dbb4af5e9f689d738347804fd05f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>.  <a href="namespaceetl.html#a11dbb4af5e9f689d738347804fd05f90">More...</a><br /></td></tr>
<tr class="separator:a11dbb4af5e9f689d738347804fd05f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8a8b9108f9ce5f69505e9152a659d7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2b8a8b9108f9ce5f69505e9152a659d7">atan</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a2b8a8b9108f9ce5f69505e9152a659d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>.  <a href="namespaceetl.html#a2b8a8b9108f9ce5f69505e9152a659d7">More...</a><br /></td></tr>
<tr class="separator:a2b8a8b9108f9ce5f69505e9152a659d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422245244dbf22608b198e007417b9d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab422245244dbf22608b198e007417b9d">atanl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:ab422245244dbf22608b198e007417b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>.  <a href="namespaceetl.html#ab422245244dbf22608b198e007417b9d">More...</a><br /></td></tr>
<tr class="separator:ab422245244dbf22608b198e007417b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76f32464a65bbf8c839d67f702b2c81"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ab76f32464a65bbf8c839d67f702b2c81"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab76f32464a65bbf8c839d67f702b2c81">atan</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ab76f32464a65bbf8c839d67f702b2c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>.  <a href="namespaceetl.html#ab76f32464a65bbf8c839d67f702b2c81">More...</a><br /></td></tr>
<tr class="separator:ab76f32464a65bbf8c839d67f702b2c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2b99c8ac12b4ede3490b55bc38ace7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3d2b99c8ac12b4ede3490b55bc38ace7">atan2</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a3d2b99c8ac12b4ede3490b55bc38ace7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <a href="namespaceetl.html#a3d2b99c8ac12b4ede3490b55bc38ace7">More...</a><br /></td></tr>
<tr class="separator:a3d2b99c8ac12b4ede3490b55bc38ace7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b28d5ed840d65898bb4bc7663cc6813"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8b28d5ed840d65898bb4bc7663cc6813">atan2f</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a8b28d5ed840d65898bb4bc7663cc6813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <a href="namespaceetl.html#a8b28d5ed840d65898bb4bc7663cc6813">More...</a><br /></td></tr>
<tr class="separator:a8b28d5ed840d65898bb4bc7663cc6813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5900f3d1e6a74988a7f45cd04a3627ae"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5900f3d1e6a74988a7f45cd04a3627ae">atan2</a> (double x, double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a5900f3d1e6a74988a7f45cd04a3627ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <a href="namespaceetl.html#a5900f3d1e6a74988a7f45cd04a3627ae">More...</a><br /></td></tr>
<tr class="separator:a5900f3d1e6a74988a7f45cd04a3627ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6967d95f89156650197ea75f1f3ba7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2c6967d95f89156650197ea75f1f3ba7">atan2</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a2c6967d95f89156650197ea75f1f3ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <a href="namespaceetl.html#a2c6967d95f89156650197ea75f1f3ba7">More...</a><br /></td></tr>
<tr class="separator:a2c6967d95f89156650197ea75f1f3ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037863b294d960041c163520b22381e1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a037863b294d960041c163520b22381e1">atan2l</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a037863b294d960041c163520b22381e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <a href="namespaceetl.html#a037863b294d960041c163520b22381e1">More...</a><br /></td></tr>
<tr class="separator:a037863b294d960041c163520b22381e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12216cfa04c0976057427be27c64c696"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a12216cfa04c0976057427be27c64c696">atanh</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a12216cfa04c0976057427be27c64c696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>.  <a href="namespaceetl.html#a12216cfa04c0976057427be27c64c696">More...</a><br /></td></tr>
<tr class="separator:a12216cfa04c0976057427be27c64c696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8783263cfdd3d32199d0cc1257e0c04c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8783263cfdd3d32199d0cc1257e0c04c">atanhf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a8783263cfdd3d32199d0cc1257e0c04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>.  <a href="namespaceetl.html#a8783263cfdd3d32199d0cc1257e0c04c">More...</a><br /></td></tr>
<tr class="separator:a8783263cfdd3d32199d0cc1257e0c04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb11729ba246f5a4098bc553a292295"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aabb11729ba246f5a4098bc553a292295">atanh</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:aabb11729ba246f5a4098bc553a292295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>.  <a href="namespaceetl.html#aabb11729ba246f5a4098bc553a292295">More...</a><br /></td></tr>
<tr class="separator:aabb11729ba246f5a4098bc553a292295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6def40d7b11e3e930b6bc1927d8aff69"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6def40d7b11e3e930b6bc1927d8aff69">atanh</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a6def40d7b11e3e930b6bc1927d8aff69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>.  <a href="namespaceetl.html#a6def40d7b11e3e930b6bc1927d8aff69">More...</a><br /></td></tr>
<tr class="separator:a6def40d7b11e3e930b6bc1927d8aff69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6c389cab358ec81ddee4010aa8f450"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6e6c389cab358ec81ddee4010aa8f450">atanhl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a6e6c389cab358ec81ddee4010aa8f450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>.  <a href="namespaceetl.html#a6e6c389cab358ec81ddee4010aa8f450">More...</a><br /></td></tr>
<tr class="separator:a6e6c389cab358ec81ddee4010aa8f450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbab5667618a4498791559fed34db3b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a0dbab5667618a4498791559fed34db3b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0dbab5667618a4498791559fed34db3b">atanh</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a0dbab5667618a4498791559fed34db3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>.  <a href="namespaceetl.html#a0dbab5667618a4498791559fed34db3b">More...</a><br /></td></tr>
<tr class="separator:a0dbab5667618a4498791559fed34db3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd33d209fa34a26154dec7971f43ce9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aefd33d209fa34a26154dec7971f43ce9">beta</a> (double x, double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:aefd33d209fa34a26154dec7971f43ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the beta function of x and y. <a href="https://en.cppreference.com/w/cpp/numeric/special_functions/beta">https://en.cppreference.com/w/cpp/numeric/special_functions/beta</a>.  <a href="namespaceetl.html#aefd33d209fa34a26154dec7971f43ce9">More...</a><br /></td></tr>
<tr class="separator:aefd33d209fa34a26154dec7971f43ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb892bd770281574939e288765165ea"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5bb892bd770281574939e288765165ea">betaf</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a5bb892bd770281574939e288765165ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the beta function of x and y. <a href="https://en.cppreference.com/w/cpp/numeric/special_functions/beta">https://en.cppreference.com/w/cpp/numeric/special_functions/beta</a>.  <a href="namespaceetl.html#a5bb892bd770281574939e288765165ea">More...</a><br /></td></tr>
<tr class="separator:a5bb892bd770281574939e288765165ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1572e65836d75f30b200de7dd2cdc272"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1572e65836d75f30b200de7dd2cdc272">betal</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a1572e65836d75f30b200de7dd2cdc272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the beta function of x and y. <a href="https://en.cppreference.com/w/cpp/numeric/special_functions/beta">https://en.cppreference.com/w/cpp/numeric/special_functions/beta</a>.  <a href="namespaceetl.html#a1572e65836d75f30b200de7dd2cdc272">More...</a><br /></td></tr>
<tr class="separator:a1572e65836d75f30b200de7dd2cdc272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8714f7ac18944189736a0c986f88b950"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8714f7ac18944189736a0c986f88b950">ceil</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a8714f7ac18944189736a0c986f88b950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>.  <a href="namespaceetl.html#a8714f7ac18944189736a0c986f88b950">More...</a><br /></td></tr>
<tr class="separator:a8714f7ac18944189736a0c986f88b950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c45cc3c430eb3f9bfbbf4c573faefe"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae7c45cc3c430eb3f9bfbbf4c573faefe">ceilf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ae7c45cc3c430eb3f9bfbbf4c573faefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>.  <a href="namespaceetl.html#ae7c45cc3c430eb3f9bfbbf4c573faefe">More...</a><br /></td></tr>
<tr class="separator:ae7c45cc3c430eb3f9bfbbf4c573faefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199b60a1d291d73e6a88cb7688fcc6b7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a199b60a1d291d73e6a88cb7688fcc6b7">ceil</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a199b60a1d291d73e6a88cb7688fcc6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>.  <a href="namespaceetl.html#a199b60a1d291d73e6a88cb7688fcc6b7">More...</a><br /></td></tr>
<tr class="separator:a199b60a1d291d73e6a88cb7688fcc6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd0ff04f746f500187517b5b60f48a7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aacd0ff04f746f500187517b5b60f48a7">ceil</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:aacd0ff04f746f500187517b5b60f48a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>.  <a href="namespaceetl.html#aacd0ff04f746f500187517b5b60f48a7">More...</a><br /></td></tr>
<tr class="separator:aacd0ff04f746f500187517b5b60f48a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee2633ec94191433e72d07c9d85cee3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afee2633ec94191433e72d07c9d85cee3">ceill</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:afee2633ec94191433e72d07c9d85cee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>.  <a href="namespaceetl.html#afee2633ec94191433e72d07c9d85cee3">More...</a><br /></td></tr>
<tr class="separator:afee2633ec94191433e72d07c9d85cee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263d08d9bc4ecbeaaed9467440a5fd6b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a263d08d9bc4ecbeaaed9467440a5fd6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a263d08d9bc4ecbeaaed9467440a5fd6b">ceil</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a263d08d9bc4ecbeaaed9467440a5fd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>.  <a href="namespaceetl.html#a263d08d9bc4ecbeaaed9467440a5fd6b">More...</a><br /></td></tr>
<tr class="separator:a263d08d9bc4ecbeaaed9467440a5fd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17223939b148fdd815e90f732a5d2ed8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a17223939b148fdd815e90f732a5d2ed8">copysign</a> (float mag, float <a class="el" href="sgn_8hpp.html#a2d1c354640836f90c93cf33ac025b866">sgn</a>) -&gt; float</td></tr>
<tr class="memdesc:a17223939b148fdd815e90f732a5d2ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <a href="namespaceetl.html#a17223939b148fdd815e90f732a5d2ed8">More...</a><br /></td></tr>
<tr class="separator:a17223939b148fdd815e90f732a5d2ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a3b66b7eaf7fba405c4fabd12b9032"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a74a3b66b7eaf7fba405c4fabd12b9032">copysignf</a> (float mag, float <a class="el" href="sgn_8hpp.html#a2d1c354640836f90c93cf33ac025b866">sgn</a>) -&gt; float</td></tr>
<tr class="memdesc:a74a3b66b7eaf7fba405c4fabd12b9032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <a href="namespaceetl.html#a74a3b66b7eaf7fba405c4fabd12b9032">More...</a><br /></td></tr>
<tr class="separator:a74a3b66b7eaf7fba405c4fabd12b9032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9633a12193b92425f88a20c5f991da"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4c9633a12193b92425f88a20c5f991da">copysign</a> (double mag, double <a class="el" href="sgn_8hpp.html#a2d1c354640836f90c93cf33ac025b866">sgn</a>) -&gt; double</td></tr>
<tr class="memdesc:a4c9633a12193b92425f88a20c5f991da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <a href="namespaceetl.html#a4c9633a12193b92425f88a20c5f991da">More...</a><br /></td></tr>
<tr class="separator:a4c9633a12193b92425f88a20c5f991da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f0ba6ef64b11393c3807cdc25ecc2b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a12f0ba6ef64b11393c3807cdc25ecc2b">copysign</a> (long double mag, long double <a class="el" href="sgn_8hpp.html#a2d1c354640836f90c93cf33ac025b866">sgn</a>) -&gt; long double</td></tr>
<tr class="memdesc:a12f0ba6ef64b11393c3807cdc25ecc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <a href="namespaceetl.html#a12f0ba6ef64b11393c3807cdc25ecc2b">More...</a><br /></td></tr>
<tr class="separator:a12f0ba6ef64b11393c3807cdc25ecc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b8f4abe1c15892a342be040ed0e231"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a61b8f4abe1c15892a342be040ed0e231">copysignl</a> (long double mag, long double <a class="el" href="sgn_8hpp.html#a2d1c354640836f90c93cf33ac025b866">sgn</a>) -&gt; long double</td></tr>
<tr class="memdesc:a61b8f4abe1c15892a342be040ed0e231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <a href="namespaceetl.html#a61b8f4abe1c15892a342be040ed0e231">More...</a><br /></td></tr>
<tr class="separator:a61b8f4abe1c15892a342be040ed0e231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4906f1caf2586cc2563fc0faf2f7ea30"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4906f1caf2586cc2563fc0faf2f7ea30">cos</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a4906f1caf2586cc2563fc0faf2f7ea30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>.  <a href="namespaceetl.html#a4906f1caf2586cc2563fc0faf2f7ea30">More...</a><br /></td></tr>
<tr class="separator:a4906f1caf2586cc2563fc0faf2f7ea30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d17a837d13ea55344804cb5c64322c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a73d17a837d13ea55344804cb5c64322c">cosf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a73d17a837d13ea55344804cb5c64322c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>.  <a href="namespaceetl.html#a73d17a837d13ea55344804cb5c64322c">More...</a><br /></td></tr>
<tr class="separator:a73d17a837d13ea55344804cb5c64322c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6c7ef0dbdd2323343636f79a74f8af"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aab6c7ef0dbdd2323343636f79a74f8af">cos</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:aab6c7ef0dbdd2323343636f79a74f8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>.  <a href="namespaceetl.html#aab6c7ef0dbdd2323343636f79a74f8af">More...</a><br /></td></tr>
<tr class="separator:aab6c7ef0dbdd2323343636f79a74f8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07734dc481f156ef3959fb891782b58f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a07734dc481f156ef3959fb891782b58f">cos</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a07734dc481f156ef3959fb891782b58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>.  <a href="namespaceetl.html#a07734dc481f156ef3959fb891782b58f">More...</a><br /></td></tr>
<tr class="separator:a07734dc481f156ef3959fb891782b58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9df8dfe51ba4bb2b189f503a7cdd75"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aed9df8dfe51ba4bb2b189f503a7cdd75">cosl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:aed9df8dfe51ba4bb2b189f503a7cdd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>.  <a href="namespaceetl.html#aed9df8dfe51ba4bb2b189f503a7cdd75">More...</a><br /></td></tr>
<tr class="separator:aed9df8dfe51ba4bb2b189f503a7cdd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e34ec5e84f9fb625cf7ee93df783c4"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:af4e34ec5e84f9fb625cf7ee93df783c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af4e34ec5e84f9fb625cf7ee93df783c4">cos</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:af4e34ec5e84f9fb625cf7ee93df783c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>.  <a href="namespaceetl.html#af4e34ec5e84f9fb625cf7ee93df783c4">More...</a><br /></td></tr>
<tr class="separator:af4e34ec5e84f9fb625cf7ee93df783c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03b4314a7a0c72385ecb062322e815a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab03b4314a7a0c72385ecb062322e815a">cosh</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ab03b4314a7a0c72385ecb062322e815a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>.  <a href="namespaceetl.html#ab03b4314a7a0c72385ecb062322e815a">More...</a><br /></td></tr>
<tr class="separator:ab03b4314a7a0c72385ecb062322e815a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2950fdc398f70b0545b2721f57deff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4c2950fdc398f70b0545b2721f57deff">coshf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a4c2950fdc398f70b0545b2721f57deff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>.  <a href="namespaceetl.html#a4c2950fdc398f70b0545b2721f57deff">More...</a><br /></td></tr>
<tr class="separator:a4c2950fdc398f70b0545b2721f57deff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c430223db452246c909a258dac5d01"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a85c430223db452246c909a258dac5d01">cosh</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a85c430223db452246c909a258dac5d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>.  <a href="namespaceetl.html#a85c430223db452246c909a258dac5d01">More...</a><br /></td></tr>
<tr class="separator:a85c430223db452246c909a258dac5d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa686c109054fee0ccbe9233313fe5811"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa686c109054fee0ccbe9233313fe5811">cosh</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:aa686c109054fee0ccbe9233313fe5811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>.  <a href="namespaceetl.html#aa686c109054fee0ccbe9233313fe5811">More...</a><br /></td></tr>
<tr class="separator:aa686c109054fee0ccbe9233313fe5811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ea3e46f7aa043f3a6229e91281655d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a32ea3e46f7aa043f3a6229e91281655d">coshl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a32ea3e46f7aa043f3a6229e91281655d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>.  <a href="namespaceetl.html#a32ea3e46f7aa043f3a6229e91281655d">More...</a><br /></td></tr>
<tr class="separator:a32ea3e46f7aa043f3a6229e91281655d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0497aee842a4aa4f6a0d3c07af34bf27"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a0497aee842a4aa4f6a0d3c07af34bf27"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0497aee842a4aa4f6a0d3c07af34bf27">cosh</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a0497aee842a4aa4f6a0d3c07af34bf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>.  <a href="namespaceetl.html#a0497aee842a4aa4f6a0d3c07af34bf27">More...</a><br /></td></tr>
<tr class="separator:a0497aee842a4aa4f6a0d3c07af34bf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a87be7c2a7789cc2af84f5620b6ba0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a67a87be7c2a7789cc2af84f5620b6ba0">erf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a67a87be7c2a7789cc2af84f5620b6ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>.  <a href="namespaceetl.html#a67a87be7c2a7789cc2af84f5620b6ba0">More...</a><br /></td></tr>
<tr class="separator:a67a87be7c2a7789cc2af84f5620b6ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16b4888b71e83519b5ef69e90ea6956"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad16b4888b71e83519b5ef69e90ea6956">erff</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ad16b4888b71e83519b5ef69e90ea6956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>.  <a href="namespaceetl.html#ad16b4888b71e83519b5ef69e90ea6956">More...</a><br /></td></tr>
<tr class="separator:ad16b4888b71e83519b5ef69e90ea6956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf55df46265ad2dda32d84405c47185d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acf55df46265ad2dda32d84405c47185d">erf</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:acf55df46265ad2dda32d84405c47185d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>.  <a href="namespaceetl.html#acf55df46265ad2dda32d84405c47185d">More...</a><br /></td></tr>
<tr class="separator:acf55df46265ad2dda32d84405c47185d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ece4e3c2d0449f2cf42ca64c72eae5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a27ece4e3c2d0449f2cf42ca64c72eae5">erf</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a27ece4e3c2d0449f2cf42ca64c72eae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>.  <a href="namespaceetl.html#a27ece4e3c2d0449f2cf42ca64c72eae5">More...</a><br /></td></tr>
<tr class="separator:a27ece4e3c2d0449f2cf42ca64c72eae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843da4273caef9b48e4cdfc9b7c2c369"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a843da4273caef9b48e4cdfc9b7c2c369">erfl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a843da4273caef9b48e4cdfc9b7c2c369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>.  <a href="namespaceetl.html#a843da4273caef9b48e4cdfc9b7c2c369">More...</a><br /></td></tr>
<tr class="separator:a843da4273caef9b48e4cdfc9b7c2c369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f46c302ddbc1a6e7a6fea6cfdc3ae2"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ac4f46c302ddbc1a6e7a6fea6cfdc3ae2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac4f46c302ddbc1a6e7a6fea6cfdc3ae2">erf</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ac4f46c302ddbc1a6e7a6fea6cfdc3ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>.  <a href="namespaceetl.html#ac4f46c302ddbc1a6e7a6fea6cfdc3ae2">More...</a><br /></td></tr>
<tr class="separator:ac4f46c302ddbc1a6e7a6fea6cfdc3ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acc3b86f099266b7744b6cb388ed894"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9acc3b86f099266b7744b6cb388ed894">exp</a> (float v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a9acc3b86f099266b7744b6cb388ed894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>.  <a href="namespaceetl.html#a9acc3b86f099266b7744b6cb388ed894">More...</a><br /></td></tr>
<tr class="separator:a9acc3b86f099266b7744b6cb388ed894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb2a8337db1101a51fa8bf0c9c93aff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3bb2a8337db1101a51fa8bf0c9c93aff">expf</a> (float v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a3bb2a8337db1101a51fa8bf0c9c93aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>.  <a href="namespaceetl.html#a3bb2a8337db1101a51fa8bf0c9c93aff">More...</a><br /></td></tr>
<tr class="separator:a3bb2a8337db1101a51fa8bf0c9c93aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c94fca30d8f6813d56cd0db16e1f2af"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5c94fca30d8f6813d56cd0db16e1f2af">exp</a> (double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a5c94fca30d8f6813d56cd0db16e1f2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>.  <a href="namespaceetl.html#a5c94fca30d8f6813d56cd0db16e1f2af">More...</a><br /></td></tr>
<tr class="separator:a5c94fca30d8f6813d56cd0db16e1f2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f7208d978374f6fdc4b3caa77a5942"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a92f7208d978374f6fdc4b3caa77a5942">exp</a> (long double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a92f7208d978374f6fdc4b3caa77a5942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>.  <a href="namespaceetl.html#a92f7208d978374f6fdc4b3caa77a5942">More...</a><br /></td></tr>
<tr class="separator:a92f7208d978374f6fdc4b3caa77a5942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23063bd3e5e1848b1cd8f0adee2bdd0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad23063bd3e5e1848b1cd8f0adee2bdd0">expl</a> (long double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:ad23063bd3e5e1848b1cd8f0adee2bdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>.  <a href="namespaceetl.html#ad23063bd3e5e1848b1cd8f0adee2bdd0">More...</a><br /></td></tr>
<tr class="separator:ad23063bd3e5e1848b1cd8f0adee2bdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a06161d90cdf8b9af35ddf334a8db2d"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a8a06161d90cdf8b9af35ddf334a8db2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8a06161d90cdf8b9af35ddf334a8db2d">exp</a> (T v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a8a06161d90cdf8b9af35ddf334a8db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>.  <a href="namespaceetl.html#a8a06161d90cdf8b9af35ddf334a8db2d">More...</a><br /></td></tr>
<tr class="separator:a8a06161d90cdf8b9af35ddf334a8db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0241333848ee2ec2b8a53dc9ba0e19e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af0241333848ee2ec2b8a53dc9ba0e19e">fdim</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:af0241333848ee2ec2b8a53dc9ba0e19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if x≤y), returns +0.  <a href="namespaceetl.html#af0241333848ee2ec2b8a53dc9ba0e19e">More...</a><br /></td></tr>
<tr class="separator:af0241333848ee2ec2b8a53dc9ba0e19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e19893929bbc794be4206bec3f1ffa"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad8e19893929bbc794be4206bec3f1ffa">fdimf</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ad8e19893929bbc794be4206bec3f1ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if x≤y), returns +0.  <a href="namespaceetl.html#ad8e19893929bbc794be4206bec3f1ffa">More...</a><br /></td></tr>
<tr class="separator:ad8e19893929bbc794be4206bec3f1ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7954b159301cbd51a00f4159449458af"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7954b159301cbd51a00f4159449458af">fdim</a> (double x, double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a7954b159301cbd51a00f4159449458af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if x≤y), returns +0.  <a href="namespaceetl.html#a7954b159301cbd51a00f4159449458af">More...</a><br /></td></tr>
<tr class="separator:a7954b159301cbd51a00f4159449458af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b3f1bd599452cab3d60f96db64c0f7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a96b3f1bd599452cab3d60f96db64c0f7">fdim</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a96b3f1bd599452cab3d60f96db64c0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if x≤y), returns +0.  <a href="namespaceetl.html#a96b3f1bd599452cab3d60f96db64c0f7">More...</a><br /></td></tr>
<tr class="separator:a96b3f1bd599452cab3d60f96db64c0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7dc714d464e428c74c9f4082a93ea2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9f7dc714d464e428c74c9f4082a93ea2">fdiml</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a9f7dc714d464e428c74c9f4082a93ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if x≤y), returns +0.  <a href="namespaceetl.html#a9f7dc714d464e428c74c9f4082a93ea2">More...</a><br /></td></tr>
<tr class="separator:a9f7dc714d464e428c74c9f4082a93ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177bda599c52cf225f0288ec9043b8bb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a177bda599c52cf225f0288ec9043b8bb">floor</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a177bda599c52cf225f0288ec9043b8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>.  <a href="namespaceetl.html#a177bda599c52cf225f0288ec9043b8bb">More...</a><br /></td></tr>
<tr class="separator:a177bda599c52cf225f0288ec9043b8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e3263a0f395c13cab460b75b0f55ef"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac9e3263a0f395c13cab460b75b0f55ef">floorf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ac9e3263a0f395c13cab460b75b0f55ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>.  <a href="namespaceetl.html#ac9e3263a0f395c13cab460b75b0f55ef">More...</a><br /></td></tr>
<tr class="separator:ac9e3263a0f395c13cab460b75b0f55ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6604cf790ab829d40c3b4daa730c7c08"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6604cf790ab829d40c3b4daa730c7c08">floor</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a6604cf790ab829d40c3b4daa730c7c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>.  <a href="namespaceetl.html#a6604cf790ab829d40c3b4daa730c7c08">More...</a><br /></td></tr>
<tr class="separator:a6604cf790ab829d40c3b4daa730c7c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5790bd430f29dc6eeced561fa3a5c054"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5790bd430f29dc6eeced561fa3a5c054">floor</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a5790bd430f29dc6eeced561fa3a5c054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>.  <a href="namespaceetl.html#a5790bd430f29dc6eeced561fa3a5c054">More...</a><br /></td></tr>
<tr class="separator:a5790bd430f29dc6eeced561fa3a5c054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2443c1dedde3d2c7efcbffd1c5fa693"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab2443c1dedde3d2c7efcbffd1c5fa693">floorl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:ab2443c1dedde3d2c7efcbffd1c5fa693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>.  <a href="namespaceetl.html#ab2443c1dedde3d2c7efcbffd1c5fa693">More...</a><br /></td></tr>
<tr class="separator:ab2443c1dedde3d2c7efcbffd1c5fa693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61d4eb26e65da7afe6e0c669e78967b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:af61d4eb26e65da7afe6e0c669e78967b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af61d4eb26e65da7afe6e0c669e78967b">floor</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:af61d4eb26e65da7afe6e0c669e78967b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>.  <a href="namespaceetl.html#af61d4eb26e65da7afe6e0c669e78967b">More...</a><br /></td></tr>
<tr class="separator:af61d4eb26e65da7afe6e0c669e78967b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e7db11940223760db9220304003446"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a69e7db11940223760db9220304003446">fma</a> (float x, float y, float z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a69e7db11940223760db9220304003446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <a href="namespaceetl.html#a69e7db11940223760db9220304003446">More...</a><br /></td></tr>
<tr class="separator:a69e7db11940223760db9220304003446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1060e4829c9f215f998aa669f07907fe"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1060e4829c9f215f998aa669f07907fe">fmaf</a> (float x, float y, float z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a1060e4829c9f215f998aa669f07907fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <a href="namespaceetl.html#a1060e4829c9f215f998aa669f07907fe">More...</a><br /></td></tr>
<tr class="separator:a1060e4829c9f215f998aa669f07907fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa52aafdd0d75fd5757bc6048241627"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afaa52aafdd0d75fd5757bc6048241627">fma</a> (double x, double y, double z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:afaa52aafdd0d75fd5757bc6048241627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <a href="namespaceetl.html#afaa52aafdd0d75fd5757bc6048241627">More...</a><br /></td></tr>
<tr class="separator:afaa52aafdd0d75fd5757bc6048241627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b982d85defc10bdabb054f0f6da09a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a12b982d85defc10bdabb054f0f6da09a">fma</a> (long double x, long double y, long double z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a12b982d85defc10bdabb054f0f6da09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <a href="namespaceetl.html#a12b982d85defc10bdabb054f0f6da09a">More...</a><br /></td></tr>
<tr class="separator:a12b982d85defc10bdabb054f0f6da09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eeb30986666cfb17836f4a95c1ae432"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4eeb30986666cfb17836f4a95c1ae432">fmal</a> (long double x, long double y, long double z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a4eeb30986666cfb17836f4a95c1ae432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <a href="namespaceetl.html#a4eeb30986666cfb17836f4a95c1ae432">More...</a><br /></td></tr>
<tr class="separator:a4eeb30986666cfb17836f4a95c1ae432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbefc5ea76f13ee1827d6ece5530ddf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4cbefc5ea76f13ee1827d6ece5530ddf">fmax</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a4cbefc5ea76f13ee1827d6ece5530ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <a href="namespaceetl.html#a4cbefc5ea76f13ee1827d6ece5530ddf">More...</a><br /></td></tr>
<tr class="separator:a4cbefc5ea76f13ee1827d6ece5530ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20521caa4fff8d2a62c7d10d77041c20"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a20521caa4fff8d2a62c7d10d77041c20">fmaxf</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a20521caa4fff8d2a62c7d10d77041c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <a href="namespaceetl.html#a20521caa4fff8d2a62c7d10d77041c20">More...</a><br /></td></tr>
<tr class="separator:a20521caa4fff8d2a62c7d10d77041c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02198785b5008814ed4bc399d219bd05"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a02198785b5008814ed4bc399d219bd05">fmax</a> (double x, double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a02198785b5008814ed4bc399d219bd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <a href="namespaceetl.html#a02198785b5008814ed4bc399d219bd05">More...</a><br /></td></tr>
<tr class="separator:a02198785b5008814ed4bc399d219bd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccdc206cb2bbd9ede91a7368c9e5e28"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2ccdc206cb2bbd9ede91a7368c9e5e28">fmax</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a2ccdc206cb2bbd9ede91a7368c9e5e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <a href="namespaceetl.html#a2ccdc206cb2bbd9ede91a7368c9e5e28">More...</a><br /></td></tr>
<tr class="separator:a2ccdc206cb2bbd9ede91a7368c9e5e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81aa1fe211f2730e008f27a200e45394"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a81aa1fe211f2730e008f27a200e45394">fmaxl</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a81aa1fe211f2730e008f27a200e45394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <a href="namespaceetl.html#a81aa1fe211f2730e008f27a200e45394">More...</a><br /></td></tr>
<tr class="separator:a81aa1fe211f2730e008f27a200e45394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6dcbdef161930c194abe91e999fa5a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7b6dcbdef161930c194abe91e999fa5a">fmin</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a7b6dcbdef161930c194abe91e999fa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <a href="namespaceetl.html#a7b6dcbdef161930c194abe91e999fa5a">More...</a><br /></td></tr>
<tr class="separator:a7b6dcbdef161930c194abe91e999fa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97261b40d0dadb99feb19718529cb0a4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a97261b40d0dadb99feb19718529cb0a4">fminf</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a97261b40d0dadb99feb19718529cb0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <a href="namespaceetl.html#a97261b40d0dadb99feb19718529cb0a4">More...</a><br /></td></tr>
<tr class="separator:a97261b40d0dadb99feb19718529cb0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f5a59fa8f7da66f4b0e8fe9c75eaa8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab3f5a59fa8f7da66f4b0e8fe9c75eaa8">fmin</a> (double x, double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ab3f5a59fa8f7da66f4b0e8fe9c75eaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <a href="namespaceetl.html#ab3f5a59fa8f7da66f4b0e8fe9c75eaa8">More...</a><br /></td></tr>
<tr class="separator:ab3f5a59fa8f7da66f4b0e8fe9c75eaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7993c9e609fbaadfb6d3c8e2601edc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3b7993c9e609fbaadfb6d3c8e2601edc">fmin</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a3b7993c9e609fbaadfb6d3c8e2601edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <a href="namespaceetl.html#a3b7993c9e609fbaadfb6d3c8e2601edc">More...</a><br /></td></tr>
<tr class="separator:a3b7993c9e609fbaadfb6d3c8e2601edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48da4e487f08e68385af8cd0fd1d5ac"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af48da4e487f08e68385af8cd0fd1d5ac">fminl</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:af48da4e487f08e68385af8cd0fd1d5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <a href="namespaceetl.html#af48da4e487f08e68385af8cd0fd1d5ac">More...</a><br /></td></tr>
<tr class="separator:af48da4e487f08e68385af8cd0fd1d5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed8605479832389e41046ec57b9ebf3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1ed8605479832389e41046ec57b9ebf3">fmod</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a1ed8605479832389e41046ec57b9ebf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a>.  <a href="namespaceetl.html#a1ed8605479832389e41046ec57b9ebf3">More...</a><br /></td></tr>
<tr class="separator:a1ed8605479832389e41046ec57b9ebf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5edc9a4f5aaf05aaee40f53925a2907"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad5edc9a4f5aaf05aaee40f53925a2907">fmodf</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ad5edc9a4f5aaf05aaee40f53925a2907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a>.  <a href="namespaceetl.html#ad5edc9a4f5aaf05aaee40f53925a2907">More...</a><br /></td></tr>
<tr class="separator:ad5edc9a4f5aaf05aaee40f53925a2907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cfcffa563969a705bb10c8a19708f0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab8cfcffa563969a705bb10c8a19708f0">fmod</a> (double x, double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ab8cfcffa563969a705bb10c8a19708f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a>.  <a href="namespaceetl.html#ab8cfcffa563969a705bb10c8a19708f0">More...</a><br /></td></tr>
<tr class="separator:ab8cfcffa563969a705bb10c8a19708f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93062354e3cf23623c19cdf4e38e7379"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a93062354e3cf23623c19cdf4e38e7379">fmod</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a93062354e3cf23623c19cdf4e38e7379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a>.  <a href="namespaceetl.html#a93062354e3cf23623c19cdf4e38e7379">More...</a><br /></td></tr>
<tr class="separator:a93062354e3cf23623c19cdf4e38e7379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62dab0cf57549d61a2af609727b1a63"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae62dab0cf57549d61a2af609727b1a63">fmodl</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:ae62dab0cf57549d61a2af609727b1a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a>.  <a href="namespaceetl.html#ae62dab0cf57549d61a2af609727b1a63">More...</a><br /></td></tr>
<tr class="separator:ae62dab0cf57549d61a2af609727b1a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fcd9a9618412844bfb6cb9790394b3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a69fcd9a9618412844bfb6cb9790394b3">hypot</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a69fcd9a9618412844bfb6cb9790394b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <a href="namespaceetl.html#a69fcd9a9618412844bfb6cb9790394b3">More...</a><br /></td></tr>
<tr class="separator:a69fcd9a9618412844bfb6cb9790394b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48afde86c3996c23be30bae9346a7403"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a48afde86c3996c23be30bae9346a7403">hypotf</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a48afde86c3996c23be30bae9346a7403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <a href="namespaceetl.html#a48afde86c3996c23be30bae9346a7403">More...</a><br /></td></tr>
<tr class="separator:a48afde86c3996c23be30bae9346a7403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f30dc3ac97f258a80f04b8ea39336b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a71f30dc3ac97f258a80f04b8ea39336b">hypot</a> (double x, double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a71f30dc3ac97f258a80f04b8ea39336b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <a href="namespaceetl.html#a71f30dc3ac97f258a80f04b8ea39336b">More...</a><br /></td></tr>
<tr class="separator:a71f30dc3ac97f258a80f04b8ea39336b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdda7a6eb1bcb8686e3769837c959f07"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abdda7a6eb1bcb8686e3769837c959f07">hypot</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:abdda7a6eb1bcb8686e3769837c959f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <a href="namespaceetl.html#abdda7a6eb1bcb8686e3769837c959f07">More...</a><br /></td></tr>
<tr class="separator:abdda7a6eb1bcb8686e3769837c959f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aafdc892d2301b2f0a571692519ab0f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3aafdc892d2301b2f0a571692519ab0f">hypotl</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a3aafdc892d2301b2f0a571692519ab0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <a href="namespaceetl.html#a3aafdc892d2301b2f0a571692519ab0f">More...</a><br /></td></tr>
<tr class="separator:a3aafdc892d2301b2f0a571692519ab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946e30be3d028206c7b77b42a718d305"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a946e30be3d028206c7b77b42a718d305">hypot</a> (float x, float y, float z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a946e30be3d028206c7b77b42a718d305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation.  <a href="namespaceetl.html#a946e30be3d028206c7b77b42a718d305">More...</a><br /></td></tr>
<tr class="separator:a946e30be3d028206c7b77b42a718d305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b6df01c497a4410ee0c90dcac298cb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa8b6df01c497a4410ee0c90dcac298cb">hypot</a> (double x, double y, double z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:aa8b6df01c497a4410ee0c90dcac298cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation.  <a href="namespaceetl.html#aa8b6df01c497a4410ee0c90dcac298cb">More...</a><br /></td></tr>
<tr class="separator:aa8b6df01c497a4410ee0c90dcac298cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080df550166a2674a8353362f290a0b3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a080df550166a2674a8353362f290a0b3">hypot</a> (long double x, long double y, long double z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a080df550166a2674a8353362f290a0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation.  <a href="namespaceetl.html#a080df550166a2674a8353362f290a0b3">More...</a><br /></td></tr>
<tr class="separator:a080df550166a2674a8353362f290a0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bf904f99630edb18fcb3a07117779f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a80bf904f99630edb18fcb3a07117779f">isfinite</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; bool</td></tr>
<tr class="memdesc:a80bf904f99630edb18fcb3a07117779f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. <a href="https://en.cppreference.com/w/cpp/numeric/math/isfinite">https://en.cppreference.com/w/cpp/numeric/math/isfinite</a>.  <a href="namespaceetl.html#a80bf904f99630edb18fcb3a07117779f">More...</a><br /></td></tr>
<tr class="separator:a80bf904f99630edb18fcb3a07117779f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813ce51b2632847f81eed1858528ff8e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a813ce51b2632847f81eed1858528ff8e">isfinite</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; bool</td></tr>
<tr class="separator:a813ce51b2632847f81eed1858528ff8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33b9666e620117df47e7cd5c2faae53"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae33b9666e620117df47e7cd5c2faae53">isfinite</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; bool</td></tr>
<tr class="separator:ae33b9666e620117df47e7cd5c2faae53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ef6491e0baea008f09e77e8bdd1893"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a47ef6491e0baea008f09e77e8bdd1893">isinf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; bool</td></tr>
<tr class="memdesc:a47ef6491e0baea008f09e77e8bdd1893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a positive or negative infinity.  <a href="namespaceetl.html#a47ef6491e0baea008f09e77e8bdd1893">More...</a><br /></td></tr>
<tr class="separator:a47ef6491e0baea008f09e77e8bdd1893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd9c92fc417d48f3b71a556c288f34d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0bd9c92fc417d48f3b71a556c288f34d">isinf</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; bool</td></tr>
<tr class="separator:a0bd9c92fc417d48f3b71a556c288f34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac63899ba5cdbbcbe25e867baaa11c8a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aac63899ba5cdbbcbe25e867baaa11c8a">isinf</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; bool</td></tr>
<tr class="separator:aac63899ba5cdbbcbe25e867baaa11c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1a47d9c6cc8ec82135f104f9b5c5d6"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a5d1a47d9c6cc8ec82135f104f9b5c5d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5d1a47d9c6cc8ec82135f104f9b5c5d6">isinf</a> (<a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; bool</td></tr>
<tr class="separator:a5d1a47d9c6cc8ec82135f104f9b5c5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605d9e24e916cbbc8f38c7e377eb792d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a605d9e24e916cbbc8f38c7e377eb792d">isnan</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; bool</td></tr>
<tr class="memdesc:a605d9e24e916cbbc8f38c7e377eb792d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value.  <a href="namespaceetl.html#a605d9e24e916cbbc8f38c7e377eb792d">More...</a><br /></td></tr>
<tr class="separator:a605d9e24e916cbbc8f38c7e377eb792d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4da86e5987c4a4fc2368f5195645c3f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac4da86e5987c4a4fc2368f5195645c3f">isnan</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; bool</td></tr>
<tr class="separator:ac4da86e5987c4a4fc2368f5195645c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1b06749558d3368fe928aba61d3b46"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5b1b06749558d3368fe928aba61d3b46">isnan</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; bool</td></tr>
<tr class="separator:a5b1b06749558d3368fe928aba61d3b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e91eb4fc3291fad0f13f2c74c57cd8f"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a3e91eb4fc3291fad0f13f2c74c57cd8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3e91eb4fc3291fad0f13f2c74c57cd8f">isnan</a> (<a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; bool</td></tr>
<tr class="memdesc:a3e91eb4fc3291fad0f13f2c74c57cd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value. <a href="https://en.cppreference.com/w/cpp/numeric/math/isnan">https://en.cppreference.com/w/cpp/numeric/math/isnan</a>.  <a href="namespaceetl.html#a3e91eb4fc3291fad0f13f2c74c57cd8f">More...</a><br /></td></tr>
<tr class="separator:a3e91eb4fc3291fad0f13f2c74c57cd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb19442837ee1b2540b722ce1c342e"><td class="memTemplParams" colspan="2">template&lt;floating_point Float&gt; </td></tr>
<tr class="memitem:ac6bb19442837ee1b2540b722ce1c342e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac6bb19442837ee1b2540b722ce1c342e">lerp</a> (Float a, Float <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>, Float t) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Float</td></tr>
<tr class="memdesc:ac6bb19442837ee1b2540b722ce1c342e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a+t(b−a), i.e. the linear interpolation between a and b for the parameter t (or extrapolation, when t is outside the range [0,1]).  <a href="namespaceetl.html#ac6bb19442837ee1b2540b722ce1c342e">More...</a><br /></td></tr>
<tr class="separator:ac6bb19442837ee1b2540b722ce1c342e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9b7f32c9ebfadabdad501a192d828c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7c9b7f32c9ebfadabdad501a192d828c">lgamma</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a7c9b7f32c9ebfadabdad501a192d828c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <a href="namespaceetl.html#a7c9b7f32c9ebfadabdad501a192d828c">More...</a><br /></td></tr>
<tr class="separator:a7c9b7f32c9ebfadabdad501a192d828c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655f9724695ea0b1ec56bbc092789817"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a655f9724695ea0b1ec56bbc092789817">lgammaf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a655f9724695ea0b1ec56bbc092789817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <a href="namespaceetl.html#a655f9724695ea0b1ec56bbc092789817">More...</a><br /></td></tr>
<tr class="separator:a655f9724695ea0b1ec56bbc092789817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea2c01b0ca8e4e672c7797bc873547e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4ea2c01b0ca8e4e672c7797bc873547e">lgamma</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a4ea2c01b0ca8e4e672c7797bc873547e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <a href="namespaceetl.html#a4ea2c01b0ca8e4e672c7797bc873547e">More...</a><br /></td></tr>
<tr class="separator:a4ea2c01b0ca8e4e672c7797bc873547e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af7825a746fbacdf9c207c50b52328d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6af7825a746fbacdf9c207c50b52328d">lgamma</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a6af7825a746fbacdf9c207c50b52328d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <a href="namespaceetl.html#a6af7825a746fbacdf9c207c50b52328d">More...</a><br /></td></tr>
<tr class="separator:a6af7825a746fbacdf9c207c50b52328d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9644a8b5362db2ea680cbe5c99b06b1c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9644a8b5362db2ea680cbe5c99b06b1c">lgammal</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a9644a8b5362db2ea680cbe5c99b06b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <a href="namespaceetl.html#a9644a8b5362db2ea680cbe5c99b06b1c">More...</a><br /></td></tr>
<tr class="separator:a9644a8b5362db2ea680cbe5c99b06b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0343114e62c2670e654d329ab0e1bdd0"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a0343114e62c2670e654d329ab0e1bdd0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0343114e62c2670e654d329ab0e1bdd0">lgamma</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a0343114e62c2670e654d329ab0e1bdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <a href="namespaceetl.html#a0343114e62c2670e654d329ab0e1bdd0">More...</a><br /></td></tr>
<tr class="separator:a0343114e62c2670e654d329ab0e1bdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a169fd90c749bd105c7ed917785c555"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555">log</a> (float v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a4a169fd90c749bd105c7ed917785c555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <a href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555">More...</a><br /></td></tr>
<tr class="separator:a4a169fd90c749bd105c7ed917785c555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57095382e9dbd0566b08e4928b380a0b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a57095382e9dbd0566b08e4928b380a0b">logf</a> (float v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a57095382e9dbd0566b08e4928b380a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <a href="namespaceetl.html#a57095382e9dbd0566b08e4928b380a0b">More...</a><br /></td></tr>
<tr class="separator:a57095382e9dbd0566b08e4928b380a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572772bba893a4526620c49993f0ebfc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a572772bba893a4526620c49993f0ebfc">log</a> (double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a572772bba893a4526620c49993f0ebfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <a href="namespaceetl.html#a572772bba893a4526620c49993f0ebfc">More...</a><br /></td></tr>
<tr class="separator:a572772bba893a4526620c49993f0ebfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82265667a848fe03195c421e0d9fc14f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a82265667a848fe03195c421e0d9fc14f">log</a> (long double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a82265667a848fe03195c421e0d9fc14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <a href="namespaceetl.html#a82265667a848fe03195c421e0d9fc14f">More...</a><br /></td></tr>
<tr class="separator:a82265667a848fe03195c421e0d9fc14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e443c1bfefaffc909930e82ad506e9c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2e443c1bfefaffc909930e82ad506e9c">logl</a> (long double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a2e443c1bfefaffc909930e82ad506e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <a href="namespaceetl.html#a2e443c1bfefaffc909930e82ad506e9c">More...</a><br /></td></tr>
<tr class="separator:a2e443c1bfefaffc909930e82ad506e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901ea4277603b09bc1fd59c203d1a5bb"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a901ea4277603b09bc1fd59c203d1a5bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a901ea4277603b09bc1fd59c203d1a5bb">log</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a901ea4277603b09bc1fd59c203d1a5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <a href="namespaceetl.html#a901ea4277603b09bc1fd59c203d1a5bb">More...</a><br /></td></tr>
<tr class="separator:a901ea4277603b09bc1fd59c203d1a5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f12f27fcd6d0d687061563bf72ff1a1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7f12f27fcd6d0d687061563bf72ff1a1">log10</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a7f12f27fcd6d0d687061563bf72ff1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>.  <a href="namespaceetl.html#a7f12f27fcd6d0d687061563bf72ff1a1">More...</a><br /></td></tr>
<tr class="separator:a7f12f27fcd6d0d687061563bf72ff1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fee06d1d407f722148dab0c23494b7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a78fee06d1d407f722148dab0c23494b7">log10f</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a78fee06d1d407f722148dab0c23494b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>.  <a href="namespaceetl.html#a78fee06d1d407f722148dab0c23494b7">More...</a><br /></td></tr>
<tr class="separator:a78fee06d1d407f722148dab0c23494b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a3fb089d374229a5797e5bfef6ebf4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae4a3fb089d374229a5797e5bfef6ebf4">log10</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ae4a3fb089d374229a5797e5bfef6ebf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>.  <a href="namespaceetl.html#ae4a3fb089d374229a5797e5bfef6ebf4">More...</a><br /></td></tr>
<tr class="separator:ae4a3fb089d374229a5797e5bfef6ebf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a16ee742583cc34fd0d79feeb82c3c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a48a16ee742583cc34fd0d79feeb82c3c">log10</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a48a16ee742583cc34fd0d79feeb82c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>.  <a href="namespaceetl.html#a48a16ee742583cc34fd0d79feeb82c3c">More...</a><br /></td></tr>
<tr class="separator:a48a16ee742583cc34fd0d79feeb82c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacfe4fb5b126adc548949313389927b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acacfe4fb5b126adc548949313389927b">log10l</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:acacfe4fb5b126adc548949313389927b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>.  <a href="namespaceetl.html#acacfe4fb5b126adc548949313389927b">More...</a><br /></td></tr>
<tr class="separator:acacfe4fb5b126adc548949313389927b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f5caf83538c35d9898a64b78f3d19d"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ab1f5caf83538c35d9898a64b78f3d19d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab1f5caf83538c35d9898a64b78f3d19d">log10</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ab1f5caf83538c35d9898a64b78f3d19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>.  <a href="namespaceetl.html#ab1f5caf83538c35d9898a64b78f3d19d">More...</a><br /></td></tr>
<tr class="separator:ab1f5caf83538c35d9898a64b78f3d19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498813413a98af25e2555e2c54c3256a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a498813413a98af25e2555e2c54c3256a">log1p</a> (float v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a498813413a98af25e2555e2c54c3256a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <a href="namespaceetl.html#a498813413a98af25e2555e2c54c3256a">More...</a><br /></td></tr>
<tr class="separator:a498813413a98af25e2555e2c54c3256a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2b22c8715dcf83abd59bb75cb1cdde"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9b2b22c8715dcf83abd59bb75cb1cdde">log1pf</a> (float v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a9b2b22c8715dcf83abd59bb75cb1cdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <a href="namespaceetl.html#a9b2b22c8715dcf83abd59bb75cb1cdde">More...</a><br /></td></tr>
<tr class="separator:a9b2b22c8715dcf83abd59bb75cb1cdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf80a0d8a6fa5bfa402fc5423250e31f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaf80a0d8a6fa5bfa402fc5423250e31f">log1p</a> (double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:aaf80a0d8a6fa5bfa402fc5423250e31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <a href="namespaceetl.html#aaf80a0d8a6fa5bfa402fc5423250e31f">More...</a><br /></td></tr>
<tr class="separator:aaf80a0d8a6fa5bfa402fc5423250e31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20be7ea716031c69f74aebe909736eb7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a20be7ea716031c69f74aebe909736eb7">log1p</a> (long double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a20be7ea716031c69f74aebe909736eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <a href="namespaceetl.html#a20be7ea716031c69f74aebe909736eb7">More...</a><br /></td></tr>
<tr class="separator:a20be7ea716031c69f74aebe909736eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25518821ccfbec031fc0d965aa7270bd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a25518821ccfbec031fc0d965aa7270bd">log1pl</a> (long double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a25518821ccfbec031fc0d965aa7270bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <a href="namespaceetl.html#a25518821ccfbec031fc0d965aa7270bd">More...</a><br /></td></tr>
<tr class="separator:a25518821ccfbec031fc0d965aa7270bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae364b66bba492ce1f0d8cf6cc89926ed"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ae364b66bba492ce1f0d8cf6cc89926ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae364b66bba492ce1f0d8cf6cc89926ed">log1p</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ae364b66bba492ce1f0d8cf6cc89926ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <a href="namespaceetl.html#ae364b66bba492ce1f0d8cf6cc89926ed">More...</a><br /></td></tr>
<tr class="separator:ae364b66bba492ce1f0d8cf6cc89926ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187674def6f3f8cb678932d3bae9cbec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a187674def6f3f8cb678932d3bae9cbec">log2</a> (float v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a187674def6f3f8cb678932d3bae9cbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>.  <a href="namespaceetl.html#a187674def6f3f8cb678932d3bae9cbec">More...</a><br /></td></tr>
<tr class="separator:a187674def6f3f8cb678932d3bae9cbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032e2d84a89ad296cc05740845401979"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a032e2d84a89ad296cc05740845401979">log2f</a> (float v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a032e2d84a89ad296cc05740845401979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>.  <a href="namespaceetl.html#a032e2d84a89ad296cc05740845401979">More...</a><br /></td></tr>
<tr class="separator:a032e2d84a89ad296cc05740845401979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48c54e709d90829fb78c40b755c71c7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad48c54e709d90829fb78c40b755c71c7">log2</a> (double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ad48c54e709d90829fb78c40b755c71c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>.  <a href="namespaceetl.html#ad48c54e709d90829fb78c40b755c71c7">More...</a><br /></td></tr>
<tr class="separator:ad48c54e709d90829fb78c40b755c71c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32086c2c749843ddb53344256a91fce"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa32086c2c749843ddb53344256a91fce">log2</a> (long double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:aa32086c2c749843ddb53344256a91fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>.  <a href="namespaceetl.html#aa32086c2c749843ddb53344256a91fce">More...</a><br /></td></tr>
<tr class="separator:aa32086c2c749843ddb53344256a91fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fa117f9915cf0572aa57acab4fe659"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa3fa117f9915cf0572aa57acab4fe659">log2l</a> (long double v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:aa3fa117f9915cf0572aa57acab4fe659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>.  <a href="namespaceetl.html#aa3fa117f9915cf0572aa57acab4fe659">More...</a><br /></td></tr>
<tr class="separator:aa3fa117f9915cf0572aa57acab4fe659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c53fd481eb75ee3e6bc3ab5cd1b307f"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a9c53fd481eb75ee3e6bc3ab5cd1b307f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9c53fd481eb75ee3e6bc3ab5cd1b307f">log2</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a9c53fd481eb75ee3e6bc3ab5cd1b307f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>.  <a href="namespaceetl.html#a9c53fd481eb75ee3e6bc3ab5cd1b307f">More...</a><br /></td></tr>
<tr class="separator:a9c53fd481eb75ee3e6bc3ab5cd1b307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47ed33940ef738b996d13c4fe6b819a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad47ed33940ef738b996d13c4fe6b819a">lrint</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long</td></tr>
<tr class="memdesc:ad47ed33940ef738b996d13c4fe6b819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#ad47ed33940ef738b996d13c4fe6b819a">More...</a><br /></td></tr>
<tr class="separator:ad47ed33940ef738b996d13c4fe6b819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd52080b573db11d8e765f46f8e7765"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aedd52080b573db11d8e765f46f8e7765">lrintf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long</td></tr>
<tr class="memdesc:aedd52080b573db11d8e765f46f8e7765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#aedd52080b573db11d8e765f46f8e7765">More...</a><br /></td></tr>
<tr class="separator:aedd52080b573db11d8e765f46f8e7765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974d3c30726d8fcb3d66b335f97b2db0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a974d3c30726d8fcb3d66b335f97b2db0">lrint</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long</td></tr>
<tr class="memdesc:a974d3c30726d8fcb3d66b335f97b2db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#a974d3c30726d8fcb3d66b335f97b2db0">More...</a><br /></td></tr>
<tr class="separator:a974d3c30726d8fcb3d66b335f97b2db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d8ad90ada2dcf269313c7d4cb1d088"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad9d8ad90ada2dcf269313c7d4cb1d088">lrint</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long</td></tr>
<tr class="memdesc:ad9d8ad90ada2dcf269313c7d4cb1d088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#ad9d8ad90ada2dcf269313c7d4cb1d088">More...</a><br /></td></tr>
<tr class="separator:ad9d8ad90ada2dcf269313c7d4cb1d088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f3372f28a951d577490cd5afe08ff0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae9f3372f28a951d577490cd5afe08ff0">lrintl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long</td></tr>
<tr class="memdesc:ae9f3372f28a951d577490cd5afe08ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#ae9f3372f28a951d577490cd5afe08ff0">More...</a><br /></td></tr>
<tr class="separator:ae9f3372f28a951d577490cd5afe08ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197984681c0d3089f3809b6769021ac0"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a197984681c0d3089f3809b6769021ac0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a197984681c0d3089f3809b6769021ac0">lrint</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long</td></tr>
<tr class="memdesc:a197984681c0d3089f3809b6769021ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#a197984681c0d3089f3809b6769021ac0">More...</a><br /></td></tr>
<tr class="separator:a197984681c0d3089f3809b6769021ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad500c9f92de07b192872ebf1d8c85bbd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad500c9f92de07b192872ebf1d8c85bbd">llrint</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long long</td></tr>
<tr class="memdesc:ad500c9f92de07b192872ebf1d8c85bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#ad500c9f92de07b192872ebf1d8c85bbd">More...</a><br /></td></tr>
<tr class="separator:ad500c9f92de07b192872ebf1d8c85bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfebe6109cc6e6cdf8f6910ef52966f4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acfebe6109cc6e6cdf8f6910ef52966f4">llrintf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long long</td></tr>
<tr class="memdesc:acfebe6109cc6e6cdf8f6910ef52966f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#acfebe6109cc6e6cdf8f6910ef52966f4">More...</a><br /></td></tr>
<tr class="separator:acfebe6109cc6e6cdf8f6910ef52966f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae026db8a513ac677c58931204032ea87"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae026db8a513ac677c58931204032ea87">llrint</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long long</td></tr>
<tr class="memdesc:ae026db8a513ac677c58931204032ea87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#ae026db8a513ac677c58931204032ea87">More...</a><br /></td></tr>
<tr class="separator:ae026db8a513ac677c58931204032ea87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72786dec8ee1f7facc0e026e8793ea29"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a72786dec8ee1f7facc0e026e8793ea29">llrint</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long long</td></tr>
<tr class="memdesc:a72786dec8ee1f7facc0e026e8793ea29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#a72786dec8ee1f7facc0e026e8793ea29">More...</a><br /></td></tr>
<tr class="separator:a72786dec8ee1f7facc0e026e8793ea29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06be44ea5149be36d471ea497927242b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a06be44ea5149be36d471ea497927242b">llrintl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long long</td></tr>
<tr class="memdesc:a06be44ea5149be36d471ea497927242b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#a06be44ea5149be36d471ea497927242b">More...</a><br /></td></tr>
<tr class="separator:a06be44ea5149be36d471ea497927242b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfc54e2b11311c629c920867ab2f0cb"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:adcfc54e2b11311c629c920867ab2f0cb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adcfc54e2b11311c629c920867ab2f0cb">llrint</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long long</td></tr>
<tr class="memdesc:adcfc54e2b11311c629c920867ab2f0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <a href="namespaceetl.html#adcfc54e2b11311c629c920867ab2f0cb">More...</a><br /></td></tr>
<tr class="separator:adcfc54e2b11311c629c920867ab2f0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21120c1b64cbc4c4d446f0859a011d82"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a21120c1b64cbc4c4d446f0859a011d82">nanf</a> (char const *<a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a21120c1b64cbc4c4d446f0859a011d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the implementation-defined character string arg into the corresponding quiet NaN value.  <a href="namespaceetl.html#a21120c1b64cbc4c4d446f0859a011d82">More...</a><br /></td></tr>
<tr class="separator:a21120c1b64cbc4c4d446f0859a011d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0c6b512cfa1423e392e02430121c44"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7e0c6b512cfa1423e392e02430121c44">nan</a> (char const *<a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a7e0c6b512cfa1423e392e02430121c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the implementation-defined character string arg into the corresponding quiet NaN value.  <a href="namespaceetl.html#a7e0c6b512cfa1423e392e02430121c44">More...</a><br /></td></tr>
<tr class="separator:a7e0c6b512cfa1423e392e02430121c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae289a4c91b473e5e1302aa1b0142b48d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae289a4c91b473e5e1302aa1b0142b48d">nanl</a> (char const *<a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:ae289a4c91b473e5e1302aa1b0142b48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the implementation-defined character string arg into the corresponding quiet NaN value.  <a href="namespaceetl.html#ae289a4c91b473e5e1302aa1b0142b48d">More...</a><br /></td></tr>
<tr class="separator:ae289a4c91b473e5e1302aa1b0142b48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59be8945c5efec1cdc9860dd0a8f04ed"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a59be8945c5efec1cdc9860dd0a8f04ed">nextafter</a> (float from, float to) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a59be8945c5efec1cdc9860dd0a8f04ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next representable value of from in the direction of to. If from equals to, to is returned.  <a href="namespaceetl.html#a59be8945c5efec1cdc9860dd0a8f04ed">More...</a><br /></td></tr>
<tr class="separator:a59be8945c5efec1cdc9860dd0a8f04ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0420dd56139b0939734e1952cbb1c4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7c0420dd56139b0939734e1952cbb1c4">nextafterf</a> (float from, float to) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a7c0420dd56139b0939734e1952cbb1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next representable value of from in the direction of to. If from equals to, to is returned.  <a href="namespaceetl.html#a7c0420dd56139b0939734e1952cbb1c4">More...</a><br /></td></tr>
<tr class="separator:a7c0420dd56139b0939734e1952cbb1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f83e49db9982e87ce21075dc80cf9a5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3f83e49db9982e87ce21075dc80cf9a5">nextafter</a> (double from, double to) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a3f83e49db9982e87ce21075dc80cf9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next representable value of from in the direction of to. If from equals to, to is returned.  <a href="namespaceetl.html#a3f83e49db9982e87ce21075dc80cf9a5">More...</a><br /></td></tr>
<tr class="separator:a3f83e49db9982e87ce21075dc80cf9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c50dace9bf8c161755a654d025b1421"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6c50dace9bf8c161755a654d025b1421">pow</a> (float <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>, float <a class="el" href="namespaceetl.html#a9acc3b86f099266b7744b6cb388ed894">exp</a>) -&gt; float</td></tr>
<tr class="memdesc:a6c50dace9bf8c161755a654d025b1421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>.  <a href="namespaceetl.html#a6c50dace9bf8c161755a654d025b1421">More...</a><br /></td></tr>
<tr class="separator:a6c50dace9bf8c161755a654d025b1421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50df9a7ff64e02368510aff26def2e97"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a50df9a7ff64e02368510aff26def2e97">powf</a> (float <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>, float <a class="el" href="namespaceetl.html#a9acc3b86f099266b7744b6cb388ed894">exp</a>) -&gt; float</td></tr>
<tr class="memdesc:a50df9a7ff64e02368510aff26def2e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>.  <a href="namespaceetl.html#a50df9a7ff64e02368510aff26def2e97">More...</a><br /></td></tr>
<tr class="separator:a50df9a7ff64e02368510aff26def2e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab20e2642b65c1856de9ceff906cc3a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2ab20e2642b65c1856de9ceff906cc3a">pow</a> (double <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>, double <a class="el" href="namespaceetl.html#a9acc3b86f099266b7744b6cb388ed894">exp</a>) -&gt; double</td></tr>
<tr class="memdesc:a2ab20e2642b65c1856de9ceff906cc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>.  <a href="namespaceetl.html#a2ab20e2642b65c1856de9ceff906cc3a">More...</a><br /></td></tr>
<tr class="separator:a2ab20e2642b65c1856de9ceff906cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0f48eee9fb05aa553bc44ece921abe"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2b0f48eee9fb05aa553bc44ece921abe">pow</a> (long double <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>, long double <a class="el" href="namespaceetl.html#a9acc3b86f099266b7744b6cb388ed894">exp</a>) -&gt; long double</td></tr>
<tr class="memdesc:a2b0f48eee9fb05aa553bc44ece921abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>.  <a href="namespaceetl.html#a2b0f48eee9fb05aa553bc44ece921abe">More...</a><br /></td></tr>
<tr class="separator:a2b0f48eee9fb05aa553bc44ece921abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6011900d6daacd4ae59b01436a7b9f1b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6011900d6daacd4ae59b01436a7b9f1b">powl</a> (long double <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>, long double <a class="el" href="namespaceetl.html#a9acc3b86f099266b7744b6cb388ed894">exp</a>) -&gt; long double</td></tr>
<tr class="memdesc:a6011900d6daacd4ae59b01436a7b9f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>.  <a href="namespaceetl.html#a6011900d6daacd4ae59b01436a7b9f1b">More...</a><br /></td></tr>
<tr class="separator:a6011900d6daacd4ae59b01436a7b9f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e30624b74c2fca7355bc13cff7c57c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a77e30624b74c2fca7355bc13cff7c57c">pow</a> (float <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>, int iexp) -&gt; float</td></tr>
<tr class="memdesc:a77e30624b74c2fca7355bc13cff7c57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>.  <a href="namespaceetl.html#a77e30624b74c2fca7355bc13cff7c57c">More...</a><br /></td></tr>
<tr class="separator:a77e30624b74c2fca7355bc13cff7c57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbc8c440f669809de2fb38d14bd958a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4fbc8c440f669809de2fb38d14bd958a">pow</a> (double <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>, int iexp) -&gt; double</td></tr>
<tr class="memdesc:a4fbc8c440f669809de2fb38d14bd958a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>.  <a href="namespaceetl.html#a4fbc8c440f669809de2fb38d14bd958a">More...</a><br /></td></tr>
<tr class="separator:a4fbc8c440f669809de2fb38d14bd958a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b3dd1df06d2bf8daf01c17e169d36c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae4b3dd1df06d2bf8daf01c17e169d36c">pow</a> (long double <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>, int iexp) -&gt; long double</td></tr>
<tr class="memdesc:ae4b3dd1df06d2bf8daf01c17e169d36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>.  <a href="namespaceetl.html#ae4b3dd1df06d2bf8daf01c17e169d36c">More...</a><br /></td></tr>
<tr class="separator:ae4b3dd1df06d2bf8daf01c17e169d36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02a7e8321924bb554b336b84c2ee60d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad02a7e8321924bb554b336b84c2ee60d">remainder</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ad02a7e8321924bb554b336b84c2ee60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a>.  <a href="namespaceetl.html#ad02a7e8321924bb554b336b84c2ee60d">More...</a><br /></td></tr>
<tr class="separator:ad02a7e8321924bb554b336b84c2ee60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dd6c6fa125a008a2226c4f2a8b225f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a11dd6c6fa125a008a2226c4f2a8b225f">remainderf</a> (float x, float y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a11dd6c6fa125a008a2226c4f2a8b225f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a>.  <a href="namespaceetl.html#a11dd6c6fa125a008a2226c4f2a8b225f">More...</a><br /></td></tr>
<tr class="separator:a11dd6c6fa125a008a2226c4f2a8b225f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bce49452ed33940fa9b1c8d2585072"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad3bce49452ed33940fa9b1c8d2585072">remainder</a> (double x, double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ad3bce49452ed33940fa9b1c8d2585072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a>.  <a href="namespaceetl.html#ad3bce49452ed33940fa9b1c8d2585072">More...</a><br /></td></tr>
<tr class="separator:ad3bce49452ed33940fa9b1c8d2585072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999d51f2384d0b2fbfd76288906b3e2d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a999d51f2384d0b2fbfd76288906b3e2d">remainder</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a999d51f2384d0b2fbfd76288906b3e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a>.  <a href="namespaceetl.html#a999d51f2384d0b2fbfd76288906b3e2d">More...</a><br /></td></tr>
<tr class="separator:a999d51f2384d0b2fbfd76288906b3e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1521d8219ac8ccb84c5de502919411"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2f1521d8219ac8ccb84c5de502919411">remainderl</a> (long double x, long double y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a2f1521d8219ac8ccb84c5de502919411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a>.  <a href="namespaceetl.html#a2f1521d8219ac8ccb84c5de502919411">More...</a><br /></td></tr>
<tr class="separator:a2f1521d8219ac8ccb84c5de502919411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd8b50cafa711d52c60a19ca80dee8f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#accd8b50cafa711d52c60a19ca80dee8f">rint</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:accd8b50cafa711d52c60a19ca80dee8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <a href="namespaceetl.html#accd8b50cafa711d52c60a19ca80dee8f">More...</a><br /></td></tr>
<tr class="separator:accd8b50cafa711d52c60a19ca80dee8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285bdc5b020e3beb9ee509210e207dd5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a285bdc5b020e3beb9ee509210e207dd5">rintf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a285bdc5b020e3beb9ee509210e207dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <a href="namespaceetl.html#a285bdc5b020e3beb9ee509210e207dd5">More...</a><br /></td></tr>
<tr class="separator:a285bdc5b020e3beb9ee509210e207dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315cfa1d5908f72cf3aff4979a814dd3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a315cfa1d5908f72cf3aff4979a814dd3">rint</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a315cfa1d5908f72cf3aff4979a814dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <a href="namespaceetl.html#a315cfa1d5908f72cf3aff4979a814dd3">More...</a><br /></td></tr>
<tr class="separator:a315cfa1d5908f72cf3aff4979a814dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6deedd67292f24e059f4a0a6f62f1a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8c6deedd67292f24e059f4a0a6f62f1a">rint</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a8c6deedd67292f24e059f4a0a6f62f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <a href="namespaceetl.html#a8c6deedd67292f24e059f4a0a6f62f1a">More...</a><br /></td></tr>
<tr class="separator:a8c6deedd67292f24e059f4a0a6f62f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cb8315104a3f48b9fb3e304aa2a6dd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a36cb8315104a3f48b9fb3e304aa2a6dd">rintl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a36cb8315104a3f48b9fb3e304aa2a6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <a href="namespaceetl.html#a36cb8315104a3f48b9fb3e304aa2a6dd">More...</a><br /></td></tr>
<tr class="separator:a36cb8315104a3f48b9fb3e304aa2a6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6a250e98656b00833eb33ee493b12b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a1d6a250e98656b00833eb33ee493b12b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1d6a250e98656b00833eb33ee493b12b">rint</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a1d6a250e98656b00833eb33ee493b12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <a href="namespaceetl.html#a1d6a250e98656b00833eb33ee493b12b">More...</a><br /></td></tr>
<tr class="separator:a1d6a250e98656b00833eb33ee493b12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653865fab50c43932f405e8e140e1ced"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a653865fab50c43932f405e8e140e1ced">round</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a653865fab50c43932f405e8e140e1ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <a href="namespaceetl.html#a653865fab50c43932f405e8e140e1ced">More...</a><br /></td></tr>
<tr class="separator:a653865fab50c43932f405e8e140e1ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8200750f9da147ccc3c2f647156ed7bb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8200750f9da147ccc3c2f647156ed7bb">roundf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a8200750f9da147ccc3c2f647156ed7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <a href="namespaceetl.html#a8200750f9da147ccc3c2f647156ed7bb">More...</a><br /></td></tr>
<tr class="separator:a8200750f9da147ccc3c2f647156ed7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e261cc501d3a147de6d342131c222af"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7e261cc501d3a147de6d342131c222af">round</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a7e261cc501d3a147de6d342131c222af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <a href="namespaceetl.html#a7e261cc501d3a147de6d342131c222af">More...</a><br /></td></tr>
<tr class="separator:a7e261cc501d3a147de6d342131c222af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5029f46266d011b01975c90e160ab5d9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5029f46266d011b01975c90e160ab5d9">round</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a5029f46266d011b01975c90e160ab5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <a href="namespaceetl.html#a5029f46266d011b01975c90e160ab5d9">More...</a><br /></td></tr>
<tr class="separator:a5029f46266d011b01975c90e160ab5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec2b94f73e269d1e72241957410aa01"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3ec2b94f73e269d1e72241957410aa01">roundl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a3ec2b94f73e269d1e72241957410aa01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <a href="namespaceetl.html#a3ec2b94f73e269d1e72241957410aa01">More...</a><br /></td></tr>
<tr class="separator:a3ec2b94f73e269d1e72241957410aa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f6ec1f24e0018a43cc5a4017ad7305"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ae0f6ec1f24e0018a43cc5a4017ad7305"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae0f6ec1f24e0018a43cc5a4017ad7305">round</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ae0f6ec1f24e0018a43cc5a4017ad7305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <a href="namespaceetl.html#ae0f6ec1f24e0018a43cc5a4017ad7305">More...</a><br /></td></tr>
<tr class="separator:ae0f6ec1f24e0018a43cc5a4017ad7305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba0ce5c59de256a555eeaae79891ad0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5ba0ce5c59de256a555eeaae79891ad0">signbit</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a5ba0ce5c59de256a555eeaae79891ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <a href="namespaceetl.html#a5ba0ce5c59de256a555eeaae79891ad0">More...</a><br /></td></tr>
<tr class="separator:a5ba0ce5c59de256a555eeaae79891ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16ba0e54e5210e5103728c522ef59c1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae16ba0e54e5210e5103728c522ef59c1">signbit</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ae16ba0e54e5210e5103728c522ef59c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <a href="namespaceetl.html#ae16ba0e54e5210e5103728c522ef59c1">More...</a><br /></td></tr>
<tr class="separator:ae16ba0e54e5210e5103728c522ef59c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6394d0dfcf05ed36d1a93ed7384b3ab4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6394d0dfcf05ed36d1a93ed7384b3ab4">signbit</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a6394d0dfcf05ed36d1a93ed7384b3ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <a href="namespaceetl.html#a6394d0dfcf05ed36d1a93ed7384b3ab4">More...</a><br /></td></tr>
<tr class="separator:a6394d0dfcf05ed36d1a93ed7384b3ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3992e7303a218d44e01d6aae6b18a92"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae3992e7303a218d44e01d6aae6b18a92">sin</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ae3992e7303a218d44e01d6aae6b18a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>.  <a href="namespaceetl.html#ae3992e7303a218d44e01d6aae6b18a92">More...</a><br /></td></tr>
<tr class="separator:ae3992e7303a218d44e01d6aae6b18a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57bb2bd32cddffe62ba6a5c56f71189"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa57bb2bd32cddffe62ba6a5c56f71189">sinf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:aa57bb2bd32cddffe62ba6a5c56f71189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>.  <a href="namespaceetl.html#aa57bb2bd32cddffe62ba6a5c56f71189">More...</a><br /></td></tr>
<tr class="separator:aa57bb2bd32cddffe62ba6a5c56f71189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e32ccfd656cf4acc0e47b2b4b1d3b7d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9e32ccfd656cf4acc0e47b2b4b1d3b7d">sin</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a9e32ccfd656cf4acc0e47b2b4b1d3b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>.  <a href="namespaceetl.html#a9e32ccfd656cf4acc0e47b2b4b1d3b7d">More...</a><br /></td></tr>
<tr class="separator:a9e32ccfd656cf4acc0e47b2b4b1d3b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31420163d28801f6cb0eaffb9ebee8b7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a31420163d28801f6cb0eaffb9ebee8b7">sin</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a31420163d28801f6cb0eaffb9ebee8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>.  <a href="namespaceetl.html#a31420163d28801f6cb0eaffb9ebee8b7">More...</a><br /></td></tr>
<tr class="separator:a31420163d28801f6cb0eaffb9ebee8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0b05c4763f8e1661d067f91a5cbbec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8a0b05c4763f8e1661d067f91a5cbbec">sinl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a8a0b05c4763f8e1661d067f91a5cbbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>.  <a href="namespaceetl.html#a8a0b05c4763f8e1661d067f91a5cbbec">More...</a><br /></td></tr>
<tr class="separator:a8a0b05c4763f8e1661d067f91a5cbbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76d0c4880759c4f43e1719488834341"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:af76d0c4880759c4f43e1719488834341"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af76d0c4880759c4f43e1719488834341">sin</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:af76d0c4880759c4f43e1719488834341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>.  <a href="namespaceetl.html#af76d0c4880759c4f43e1719488834341">More...</a><br /></td></tr>
<tr class="separator:af76d0c4880759c4f43e1719488834341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ea280e9468d3bccca526a7cbc73651"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a81ea280e9468d3bccca526a7cbc73651">sinh</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a81ea280e9468d3bccca526a7cbc73651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>.  <a href="namespaceetl.html#a81ea280e9468d3bccca526a7cbc73651">More...</a><br /></td></tr>
<tr class="separator:a81ea280e9468d3bccca526a7cbc73651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2410ac3995142466f68376374b9d4ec3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2410ac3995142466f68376374b9d4ec3">sinhf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a2410ac3995142466f68376374b9d4ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>.  <a href="namespaceetl.html#a2410ac3995142466f68376374b9d4ec3">More...</a><br /></td></tr>
<tr class="separator:a2410ac3995142466f68376374b9d4ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134b303ad71ff97a362470bf0d51aeea"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a134b303ad71ff97a362470bf0d51aeea">sinh</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a134b303ad71ff97a362470bf0d51aeea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>.  <a href="namespaceetl.html#a134b303ad71ff97a362470bf0d51aeea">More...</a><br /></td></tr>
<tr class="separator:a134b303ad71ff97a362470bf0d51aeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac254ab46d592daba270994a02a06afbb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac254ab46d592daba270994a02a06afbb">sinh</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:ac254ab46d592daba270994a02a06afbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>.  <a href="namespaceetl.html#ac254ab46d592daba270994a02a06afbb">More...</a><br /></td></tr>
<tr class="separator:ac254ab46d592daba270994a02a06afbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d2c54a18b0472cabe0c5a66b6daf30"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab2d2c54a18b0472cabe0c5a66b6daf30">sinhl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:ab2d2c54a18b0472cabe0c5a66b6daf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>.  <a href="namespaceetl.html#ab2d2c54a18b0472cabe0c5a66b6daf30">More...</a><br /></td></tr>
<tr class="separator:ab2d2c54a18b0472cabe0c5a66b6daf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40d2d23c8e8fccf96b3b782e667c210"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ac40d2d23c8e8fccf96b3b782e667c210"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac40d2d23c8e8fccf96b3b782e667c210">sinh</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ac40d2d23c8e8fccf96b3b782e667c210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>.  <a href="namespaceetl.html#ac40d2d23c8e8fccf96b3b782e667c210">More...</a><br /></td></tr>
<tr class="separator:ac40d2d23c8e8fccf96b3b782e667c210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6d19ae1f2df5e1e7f62db7a939946d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2e6d19ae1f2df5e1e7f62db7a939946d">sqrt</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a2e6d19ae1f2df5e1e7f62db7a939946d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>.  <a href="namespaceetl.html#a2e6d19ae1f2df5e1e7f62db7a939946d">More...</a><br /></td></tr>
<tr class="separator:a2e6d19ae1f2df5e1e7f62db7a939946d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9f94a766a382b51806352f5e757526"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5f9f94a766a382b51806352f5e757526">sqrtf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a5f9f94a766a382b51806352f5e757526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>.  <a href="namespaceetl.html#a5f9f94a766a382b51806352f5e757526">More...</a><br /></td></tr>
<tr class="separator:a5f9f94a766a382b51806352f5e757526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e65e7903be2c1a9749a5249e6c790f8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7e65e7903be2c1a9749a5249e6c790f8">sqrt</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a7e65e7903be2c1a9749a5249e6c790f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>.  <a href="namespaceetl.html#a7e65e7903be2c1a9749a5249e6c790f8">More...</a><br /></td></tr>
<tr class="separator:a7e65e7903be2c1a9749a5249e6c790f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c22d86b18b9a040289d082be62c4ec7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5c22d86b18b9a040289d082be62c4ec7">sqrt</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a5c22d86b18b9a040289d082be62c4ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>.  <a href="namespaceetl.html#a5c22d86b18b9a040289d082be62c4ec7">More...</a><br /></td></tr>
<tr class="separator:a5c22d86b18b9a040289d082be62c4ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b08acd2af82eed59a672ca38721e263"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1b08acd2af82eed59a672ca38721e263">sqrtl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a1b08acd2af82eed59a672ca38721e263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>.  <a href="namespaceetl.html#a1b08acd2af82eed59a672ca38721e263">More...</a><br /></td></tr>
<tr class="separator:a1b08acd2af82eed59a672ca38721e263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb720e73aa27e1f9c5a3a2bc830bef84"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:acb720e73aa27e1f9c5a3a2bc830bef84"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acb720e73aa27e1f9c5a3a2bc830bef84">sqrt</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:acb720e73aa27e1f9c5a3a2bc830bef84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>.  <a href="namespaceetl.html#acb720e73aa27e1f9c5a3a2bc830bef84">More...</a><br /></td></tr>
<tr class="separator:acb720e73aa27e1f9c5a3a2bc830bef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e43e254d59d4cd608b1d9f1399167d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa3e43e254d59d4cd608b1d9f1399167d">tan</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:aa3e43e254d59d4cd608b1d9f1399167d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>.  <a href="namespaceetl.html#aa3e43e254d59d4cd608b1d9f1399167d">More...</a><br /></td></tr>
<tr class="separator:aa3e43e254d59d4cd608b1d9f1399167d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cd684aadcdf2df4696dd5c9ae99ea2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab7cd684aadcdf2df4696dd5c9ae99ea2">tanf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:ab7cd684aadcdf2df4696dd5c9ae99ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>.  <a href="namespaceetl.html#ab7cd684aadcdf2df4696dd5c9ae99ea2">More...</a><br /></td></tr>
<tr class="separator:ab7cd684aadcdf2df4696dd5c9ae99ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6be38a86dc3804ad690b2ea4f3c082"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2e6be38a86dc3804ad690b2ea4f3c082">tan</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a2e6be38a86dc3804ad690b2ea4f3c082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>.  <a href="namespaceetl.html#a2e6be38a86dc3804ad690b2ea4f3c082">More...</a><br /></td></tr>
<tr class="separator:a2e6be38a86dc3804ad690b2ea4f3c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf39aea93d6cef89e6b047068532251f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abf39aea93d6cef89e6b047068532251f">tan</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:abf39aea93d6cef89e6b047068532251f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>.  <a href="namespaceetl.html#abf39aea93d6cef89e6b047068532251f">More...</a><br /></td></tr>
<tr class="separator:abf39aea93d6cef89e6b047068532251f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8821d6a54a089020394afeddd92eb20c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8821d6a54a089020394afeddd92eb20c">tanl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a8821d6a54a089020394afeddd92eb20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>.  <a href="namespaceetl.html#a8821d6a54a089020394afeddd92eb20c">More...</a><br /></td></tr>
<tr class="separator:a8821d6a54a089020394afeddd92eb20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82108d39542689318c049d79b7a1443b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a82108d39542689318c049d79b7a1443b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a82108d39542689318c049d79b7a1443b">tan</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a82108d39542689318c049d79b7a1443b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>.  <a href="namespaceetl.html#a82108d39542689318c049d79b7a1443b">More...</a><br /></td></tr>
<tr class="separator:a82108d39542689318c049d79b7a1443b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a06c6155118cf0eea70d7f72e7ee26"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a94a06c6155118cf0eea70d7f72e7ee26">tanh</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a94a06c6155118cf0eea70d7f72e7ee26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>.  <a href="namespaceetl.html#a94a06c6155118cf0eea70d7f72e7ee26">More...</a><br /></td></tr>
<tr class="separator:a94a06c6155118cf0eea70d7f72e7ee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b71e15eca59ee5d5814c5df7de5f540"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0b71e15eca59ee5d5814c5df7de5f540">tanhf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a0b71e15eca59ee5d5814c5df7de5f540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>.  <a href="namespaceetl.html#a0b71e15eca59ee5d5814c5df7de5f540">More...</a><br /></td></tr>
<tr class="separator:a0b71e15eca59ee5d5814c5df7de5f540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338f420d3e517380454cff3e76c275de"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a338f420d3e517380454cff3e76c275de">tanh</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a338f420d3e517380454cff3e76c275de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>.  <a href="namespaceetl.html#a338f420d3e517380454cff3e76c275de">More...</a><br /></td></tr>
<tr class="separator:a338f420d3e517380454cff3e76c275de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa9bf0ccb082968efc0da1be519a4d3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abaa9bf0ccb082968efc0da1be519a4d3">tanh</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:abaa9bf0ccb082968efc0da1be519a4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>.  <a href="namespaceetl.html#abaa9bf0ccb082968efc0da1be519a4d3">More...</a><br /></td></tr>
<tr class="separator:abaa9bf0ccb082968efc0da1be519a4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770ad213930a5de35a7e4d8efbb65c16"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a770ad213930a5de35a7e4d8efbb65c16">tanhl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a770ad213930a5de35a7e4d8efbb65c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>.  <a href="namespaceetl.html#a770ad213930a5de35a7e4d8efbb65c16">More...</a><br /></td></tr>
<tr class="separator:a770ad213930a5de35a7e4d8efbb65c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de6b5cc89e28e1ba7eac7465f380fba"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a9de6b5cc89e28e1ba7eac7465f380fba"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9de6b5cc89e28e1ba7eac7465f380fba">tanh</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a9de6b5cc89e28e1ba7eac7465f380fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>.  <a href="namespaceetl.html#a9de6b5cc89e28e1ba7eac7465f380fba">More...</a><br /></td></tr>
<tr class="separator:a9de6b5cc89e28e1ba7eac7465f380fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304d035a3a2740c7fef43426fcf3b9cb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a304d035a3a2740c7fef43426fcf3b9cb">tgamma</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a304d035a3a2740c7fef43426fcf3b9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>.  <a href="namespaceetl.html#a304d035a3a2740c7fef43426fcf3b9cb">More...</a><br /></td></tr>
<tr class="separator:a304d035a3a2740c7fef43426fcf3b9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0533d6b346e372e13a35a00e4fe5ac"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aba0533d6b346e372e13a35a00e4fe5ac">tgammaf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:aba0533d6b346e372e13a35a00e4fe5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>.  <a href="namespaceetl.html#aba0533d6b346e372e13a35a00e4fe5ac">More...</a><br /></td></tr>
<tr class="separator:aba0533d6b346e372e13a35a00e4fe5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d14d3d27f8694d9d4b771100bd4c74e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8d14d3d27f8694d9d4b771100bd4c74e">tgamma</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a8d14d3d27f8694d9d4b771100bd4c74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>.  <a href="namespaceetl.html#a8d14d3d27f8694d9d4b771100bd4c74e">More...</a><br /></td></tr>
<tr class="separator:a8d14d3d27f8694d9d4b771100bd4c74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7455e948ac61779dbd3be0c44190e569"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7455e948ac61779dbd3be0c44190e569">tgamma</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a7455e948ac61779dbd3be0c44190e569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>.  <a href="namespaceetl.html#a7455e948ac61779dbd3be0c44190e569">More...</a><br /></td></tr>
<tr class="separator:a7455e948ac61779dbd3be0c44190e569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6252e2a52632b3b841f2b21455c2fa7a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6252e2a52632b3b841f2b21455c2fa7a">tgammal</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:a6252e2a52632b3b841f2b21455c2fa7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>.  <a href="namespaceetl.html#a6252e2a52632b3b841f2b21455c2fa7a">More...</a><br /></td></tr>
<tr class="separator:a6252e2a52632b3b841f2b21455c2fa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31c7fddeeebae7fde466c96fafadd4c"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ae31c7fddeeebae7fde466c96fafadd4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae31c7fddeeebae7fde466c96fafadd4c">tgamma</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:ae31c7fddeeebae7fde466c96fafadd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>.  <a href="namespaceetl.html#ae31c7fddeeebae7fde466c96fafadd4c">More...</a><br /></td></tr>
<tr class="separator:ae31c7fddeeebae7fde466c96fafadd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e4586e25e102b1dcd61e06b661ac2d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a77e4586e25e102b1dcd61e06b661ac2d">trunc</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a77e4586e25e102b1dcd61e06b661ac2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>.  <a href="namespaceetl.html#a77e4586e25e102b1dcd61e06b661ac2d">More...</a><br /></td></tr>
<tr class="separator:a77e4586e25e102b1dcd61e06b661ac2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5336aa0b394c2196ad1b8f15b2441b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9c5336aa0b394c2196ad1b8f15b2441b">truncf</a> (float <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:a9c5336aa0b394c2196ad1b8f15b2441b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>.  <a href="namespaceetl.html#a9c5336aa0b394c2196ad1b8f15b2441b">More...</a><br /></td></tr>
<tr class="separator:a9c5336aa0b394c2196ad1b8f15b2441b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8316f5c97f691318a53cf91fd135894"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa8316f5c97f691318a53cf91fd135894">trunc</a> (double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:aa8316f5c97f691318a53cf91fd135894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>.  <a href="namespaceetl.html#aa8316f5c97f691318a53cf91fd135894">More...</a><br /></td></tr>
<tr class="separator:aa8316f5c97f691318a53cf91fd135894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33b0697205c635cb1e294cfecbcfd46"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa33b0697205c635cb1e294cfecbcfd46">trunc</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:aa33b0697205c635cb1e294cfecbcfd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>.  <a href="namespaceetl.html#aa33b0697205c635cb1e294cfecbcfd46">More...</a><br /></td></tr>
<tr class="separator:aa33b0697205c635cb1e294cfecbcfd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86cd183532a15f7fb8fa893a9db7d44"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa86cd183532a15f7fb8fa893a9db7d44">truncl</a> (long double <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:aa86cd183532a15f7fb8fa893a9db7d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>.  <a href="namespaceetl.html#aa86cd183532a15f7fb8fa893a9db7d44">More...</a><br /></td></tr>
<tr class="separator:aa86cd183532a15f7fb8fa893a9db7d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9896e22ccd29baf6a2bca31d48f6e4b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:af9896e22ccd29baf6a2bca31d48f6e4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af9896e22ccd29baf6a2bca31d48f6e4b">trunc</a> (T <a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:af9896e22ccd29baf6a2bca31d48f6e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>.  <a href="namespaceetl.html#af9896e22ccd29baf6a2bca31d48f6e4b">More...</a><br /></td></tr>
<tr class="separator:af9896e22ccd29baf6a2bca31d48f6e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d038b8a789971cb7319f23919ae1d1f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1d038b8a789971cb7319f23919ae1d1f">is_eq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> cmp) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a1d038b8a789971cb7319f23919ae1d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83376b31eb27942ae5c71f06c91decc8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a83376b31eb27942ae5c71f06c91decc8">is_neq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> cmp) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a83376b31eb27942ae5c71f06c91decc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec1b19096d66a3614daa7bc0ec0c564"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9ec1b19096d66a3614daa7bc0ec0c564">is_lt</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> cmp) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a9ec1b19096d66a3614daa7bc0ec0c564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b3b676935f0ab36310d8f87b00da2d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a46b3b676935f0ab36310d8f87b00da2d">is_lteq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> cmp) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a46b3b676935f0ab36310d8f87b00da2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bd271610a81bd07da4d1f15f55ce2b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a52bd271610a81bd07da4d1f15f55ce2b">is_gt</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> cmp) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a52bd271610a81bd07da4d1f15f55ce2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff127460a7b71fec87f3156800a3972"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9ff127460a7b71fec87f3156800a3972">is_gteq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> cmp) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a9ff127460a7b71fec87f3156800a3972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77deb75e76886e1049e79b9acef5a4fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77deb75e76886e1049e79b9acef5a4fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a77deb75e76886e1049e79b9acef5a4fa">abs</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) -&gt; T</td></tr>
<tr class="separator:a77deb75e76886e1049e79b9acef5a4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06165982b4ed16fe2e57476b46f4ad08"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06165982b4ed16fe2e57476b46f4ad08"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T</td></tr>
<tr class="separator:a06165982b4ed16fe2e57476b46f4ad08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12078097d0f7a8a5b20b23d8c22a9ff2"><td class="memTemplParams" colspan="2">template&lt;typename Float &gt; </td></tr>
<tr class="memitem:a12078097d0f7a8a5b20b23d8c22a9ff2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a12078097d0f7a8a5b20b23d8c22a9ff2">arg</a> (Float f) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt; Float &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; Float &gt;&gt;</td></tr>
<tr class="separator:a12078097d0f7a8a5b20b23d8c22a9ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b71dddaa8945219c1a544cf165ef0c"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a58b71dddaa8945219c1a544cf165ef0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a58b71dddaa8945219c1a544cf165ef0c">arg</a> (Integer i) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; Integer &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; double &gt;&gt;</td></tr>
<tr class="separator:a58b71dddaa8945219c1a544cf165ef0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2348f97d6b5181e2a119bafbde11ba2"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename T &gt; </td></tr>
<tr class="memitem:aa2348f97d6b5181e2a119bafbde11ba2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa2348f97d6b5181e2a119bafbde11ba2">requires</a> (I&lt; 2) struct <a class="el" href="structetl_1_1tuple__element.html">tuple_element</a>&lt; I</td></tr>
<tr class="separator:aa2348f97d6b5181e2a119bafbde11ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93401bd9402632426cada76f529d6b9f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93401bd9402632426cada76f529d6b9f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a93401bd9402632426cada76f529d6b9f">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a93401bd9402632426cada76f529d6b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa112bbaeebf7afad6d876c4291b195c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa112bbaeebf7afad6d876c4291b195c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa112bbaeebf7afad6d876c4291b195c8">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:aa112bbaeebf7afad6d876c4291b195c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650bebf4618f883ada09c2039a4b725b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a650bebf4618f883ada09c2039a4b725b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a650bebf4618f883ada09c2039a4b725b">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a650bebf4618f883ada09c2039a4b725b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21b902b9c3ad85f752def9d8b61e99c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac21b902b9c3ad85f752def9d8b61e99c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac21b902b9c3ad85f752def9d8b61e99c">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, T const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ac21b902b9c3ad85f752def9d8b61e99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cbf5d3ec0e799c656a8c39087e0718"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4cbf5d3ec0e799c656a8c39087e0718"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac4cbf5d3ec0e799c656a8c39087e0718">operator+</a> (T const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ac4cbf5d3ec0e799c656a8c39087e0718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82931442d5539449fd23546e25bb86ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82931442d5539449fd23546e25bb86ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a82931442d5539449fd23546e25bb86ae">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a82931442d5539449fd23546e25bb86ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499c18a06cffd9fb9930ba800faa4801"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a499c18a06cffd9fb9930ba800faa4801"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a499c18a06cffd9fb9930ba800faa4801">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, T const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a499c18a06cffd9fb9930ba800faa4801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f5c49d6dab738f50f9729f5e38ffcb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48f5c49d6dab738f50f9729f5e38ffcb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a48f5c49d6dab738f50f9729f5e38ffcb">operator-</a> (T const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a48f5c49d6dab738f50f9729f5e38ffcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d31064099961389d855da11c34cd31"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62d31064099961389d855da11c34cd31"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a62d31064099961389d855da11c34cd31">operator*</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a62d31064099961389d855da11c34cd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dea59a34e6077f3bfdbf0bedc4bc6bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0dea59a34e6077f3bfdbf0bedc4bc6bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0dea59a34e6077f3bfdbf0bedc4bc6bf">operator*</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, T const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a0dea59a34e6077f3bfdbf0bedc4bc6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e69e867df1a1b9564f6825a59062b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9e69e867df1a1b9564f6825a59062b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae9e69e867df1a1b9564f6825a59062b8">operator*</a> (T const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ae9e69e867df1a1b9564f6825a59062b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e1ecd06afff7b886ff8690bf298584"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5e1ecd06afff7b886ff8690bf298584"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae5e1ecd06afff7b886ff8690bf298584">operator/</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ae5e1ecd06afff7b886ff8690bf298584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a73215990ea73911836054392d33c25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a73215990ea73911836054392d33c25"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9a73215990ea73911836054392d33c25">operator/</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, T const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a9a73215990ea73911836054392d33c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77987b5129ca33aaac1cc7f239d3f0ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77987b5129ca33aaac1cc7f239d3f0ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a77987b5129ca33aaac1cc7f239d3f0ba">operator/</a> (T const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a77987b5129ca33aaac1cc7f239d3f0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e6646ea6ece6aac46299e9d0ae0204"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2e6646ea6ece6aac46299e9d0ae0204"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae2e6646ea6ece6aac46299e9d0ae0204">operator==</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="separator:ae2e6646ea6ece6aac46299e9d0ae0204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dbf6c912f63446fe62ca363ce14874"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1dbf6c912f63446fe62ca363ce14874"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af1dbf6c912f63446fe62ca363ce14874">operator==</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, T const &amp;rhs) -&gt; bool</td></tr>
<tr class="separator:af1dbf6c912f63446fe62ca363ce14874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a8fc7be9c1bc3f843a73e0e4084a15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89a8fc7be9c1bc3f843a73e0e4084a15"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a89a8fc7be9c1bc3f843a73e0e4084a15">operator==</a> (T const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="separator:a89a8fc7be9c1bc3f843a73e0e4084a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19652b6d64df0961e5821c4df232fcc5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19652b6d64df0961e5821c4df232fcc5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a19652b6d64df0961e5821c4df232fcc5">operator!=</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="separator:a19652b6d64df0961e5821c4df232fcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4c2db5ab66a07bf724a38c83659acd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf4c2db5ab66a07bf724a38c83659acd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaf4c2db5ab66a07bf724a38c83659acd">operator!=</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, T const &amp;rhs) -&gt; bool</td></tr>
<tr class="separator:aaf4c2db5ab66a07bf724a38c83659acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1eb7312810a052d5df24b678a67965"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd1eb7312810a052d5df24b678a67965"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abd1eb7312810a052d5df24b678a67965">operator!=</a> (T const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="separator:abd1eb7312810a052d5df24b678a67965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ff15d018c17347ac61e95ac1a30764"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46ff15d018c17347ac61e95ac1a30764"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a46ff15d018c17347ac61e95ac1a30764">conj</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a46ff15d018c17347ac61e95ac1a30764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce7ac5a8dbb8ecf4841a23057e1126b"><td class="memTemplParams" colspan="2">template&lt;typename Float &gt; </td></tr>
<tr class="memitem:acce7ac5a8dbb8ecf4841a23057e1126b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acce7ac5a8dbb8ecf4841a23057e1126b">conj</a> (Float f) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt; Float &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; Float &gt;&gt;</td></tr>
<tr class="separator:acce7ac5a8dbb8ecf4841a23057e1126b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c80be7a4d685217616326a04620a45"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ae5c80be7a4d685217616326a04620a45"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae5c80be7a4d685217616326a04620a45">conj</a> (Integer i) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; Integer &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; double &gt;&gt;</td></tr>
<tr class="separator:ae5c80be7a4d685217616326a04620a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270bd6f09628db22fe5bd8b51dd0b715"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a270bd6f09628db22fe5bd8b51dd0b715"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a270bd6f09628db22fe5bd8b51dd0b715">cos</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a270bd6f09628db22fe5bd8b51dd0b715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46256752d5c736599fc58eff97661928"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46256752d5c736599fc58eff97661928"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a46256752d5c736599fc58eff97661928">cosh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a46256752d5c736599fc58eff97661928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f08cccdf78e0bd6d348c9650dac539"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af3f08cccdf78e0bd6d348c9650dac539"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af3f08cccdf78e0bd6d348c9650dac539">imag</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) -&gt; T</td></tr>
<tr class="separator:af3f08cccdf78e0bd6d348c9650dac539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1933c315d97e15c015707f12c7569b"><td class="memTemplParams" colspan="2">template&lt;typename Float &gt; </td></tr>
<tr class="memitem:afc1933c315d97e15c015707f12c7569b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afc1933c315d97e15c015707f12c7569b">imag</a> (Float) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt; Float &gt;, Float &gt;</td></tr>
<tr class="separator:afc1933c315d97e15c015707f12c7569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b5cb305b608dff6b0e0726fa3e9aa0"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ad4b5cb305b608dff6b0e0726fa3e9aa0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad4b5cb305b608dff6b0e0726fa3e9aa0">imag</a> (Integer) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; Integer &gt;, double &gt;</td></tr>
<tr class="separator:ad4b5cb305b608dff6b0e0726fa3e9aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dab176f001bd0087f3f8652eace5c93"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3dab176f001bd0087f3f8652eace5c93"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3dab176f001bd0087f3f8652eace5c93">log</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a3dab176f001bd0087f3f8652eace5c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb87c5a1d5623bb01299fd23324b1565"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb87c5a1d5623bb01299fd23324b1565"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abb87c5a1d5623bb01299fd23324b1565">log10</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:abb87c5a1d5623bb01299fd23324b1565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87ec2d3c345ee05d9ccf2b964c9158a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af87ec2d3c345ee05d9ccf2b964c9158a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af87ec2d3c345ee05d9ccf2b964c9158a">norm</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T</td></tr>
<tr class="separator:af87ec2d3c345ee05d9ccf2b964c9158a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bf99267593c4eb629576e903080e90"><td class="memTemplParams" colspan="2">template&lt;typename Float &gt; </td></tr>
<tr class="memitem:ab6bf99267593c4eb629576e903080e90"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab6bf99267593c4eb629576e903080e90">norm</a> (Float f) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt; Float &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; Float &gt;&gt;</td></tr>
<tr class="separator:ab6bf99267593c4eb629576e903080e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbeee9ca7179220480db518183c9501e"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:adbeee9ca7179220480db518183c9501e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adbeee9ca7179220480db518183c9501e">norm</a> (Integer i) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; Integer &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; double &gt;&gt;</td></tr>
<tr class="separator:adbeee9ca7179220480db518183c9501e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408755ab767193cae4b002c03906843a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a408755ab767193cae4b002c03906843a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a408755ab767193cae4b002c03906843a">polar</a> (T const &amp;r, T const &amp;theta=T()) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1complex.html">etl::complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a408755ab767193cae4b002c03906843a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef5852f3127713fd9350fb575a52096"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ef5852f3127713fd9350fb575a52096"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7ef5852f3127713fd9350fb575a52096">real</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) -&gt; T</td></tr>
<tr class="separator:a7ef5852f3127713fd9350fb575a52096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fac133cf1602f9bec2fd91ac8e93fbf"><td class="memTemplParams" colspan="2">template&lt;typename Float &gt; </td></tr>
<tr class="memitem:a0fac133cf1602f9bec2fd91ac8e93fbf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0fac133cf1602f9bec2fd91ac8e93fbf">real</a> (Float f) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt; Float &gt;, Float &gt;</td></tr>
<tr class="separator:a0fac133cf1602f9bec2fd91ac8e93fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371a4a57669e09596d80f1ff4198aae5"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a371a4a57669e09596d80f1ff4198aae5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a371a4a57669e09596d80f1ff4198aae5">real</a> (Integer i) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; Integer &gt;, double &gt;</td></tr>
<tr class="separator:a371a4a57669e09596d80f1ff4198aae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb16919c024711d1b7fbb969fb0f099"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7eb16919c024711d1b7fbb969fb0f099"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7eb16919c024711d1b7fbb969fb0f099">sin</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a7eb16919c024711d1b7fbb969fb0f099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6776dd33fc56dbf0aaf7a9c1ececb72c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6776dd33fc56dbf0aaf7a9c1ececb72c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6776dd33fc56dbf0aaf7a9c1ececb72c">sinh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a6776dd33fc56dbf0aaf7a9c1ececb72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9543be08a43b5b97cd0ed98b44932467"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9543be08a43b5b97cd0ed98b44932467"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9543be08a43b5b97cd0ed98b44932467">tan</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a9543be08a43b5b97cd0ed98b44932467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb57b849230e292fb874b066ae1eb6f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb57b849230e292fb874b066ae1eb6f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afb57b849230e292fb874b066ae1eb6f2">tanh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;z) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:afb57b849230e292fb874b066ae1eb6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f88510fb558792c06ba4d60e131fdd1"><td class="memTemplParams" colspan="2">template&lt;etl::integral Int&gt; </td></tr>
<tr class="memitem:a5f88510fb558792c06ba4d60e131fdd1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5f88510fb558792c06ba4d60e131fdd1">to_integer</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a></td></tr>
<tr class="memdesc:a5f88510fb558792c06ba4d60e131fdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return Int(b);</code>  <a href="namespaceetl.html#a5f88510fb558792c06ba4d60e131fdd1">More...</a><br /></td></tr>
<tr class="separator:a5f88510fb558792c06ba4d60e131fdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc904547fdea8181f43e29bdd2499a18"><td class="memTemplParams" colspan="2">template&lt;etl::integral Int&gt; </td></tr>
<tr class="memitem:afc904547fdea8181f43e29bdd2499a18"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afc904547fdea8181f43e29bdd2499a18">operator&lt;&lt;</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>, <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> <a class="el" href="namespaceetl.html#a3acb4483c815a6504bcca76ca33d7d0f">shift</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:afc904547fdea8181f43e29bdd2499a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift);</code>  <a href="namespaceetl.html#afc904547fdea8181f43e29bdd2499a18">More...</a><br /></td></tr>
<tr class="separator:afc904547fdea8181f43e29bdd2499a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3715f231cbbd499f1ae94cb720235a0a"><td class="memTemplParams" colspan="2">template&lt;etl::integral Int&gt; </td></tr>
<tr class="memitem:a3715f231cbbd499f1ae94cb720235a0a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3715f231cbbd499f1ae94cb720235a0a">operator&gt;&gt;</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>, <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> <a class="el" href="namespaceetl.html#a3acb4483c815a6504bcca76ca33d7d0f">shift</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:a3715f231cbbd499f1ae94cb720235a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift);</code>  <a href="namespaceetl.html#a3715f231cbbd499f1ae94cb720235a0a">More...</a><br /></td></tr>
<tr class="separator:a3715f231cbbd499f1ae94cb720235a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5333e22ae93bd22aa8bd647619966a"><td class="memTemplParams" colspan="2">template&lt;etl::integral Int&gt; </td></tr>
<tr class="memitem:afa5333e22ae93bd22aa8bd647619966a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afa5333e22ae93bd22aa8bd647619966a">operator&lt;&lt;=</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>, <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> <a class="el" href="namespaceetl.html#a3acb4483c815a6504bcca76ca33d7d0f">shift</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:afa5333e22ae93bd22aa8bd647619966a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return b = b &lt;&lt; shift;</code>  <a href="namespaceetl.html#afa5333e22ae93bd22aa8bd647619966a">More...</a><br /></td></tr>
<tr class="separator:afa5333e22ae93bd22aa8bd647619966a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071dbaa078a310d6e8bd2aa0eb028695"><td class="memTemplParams" colspan="2">template&lt;etl::integral Int&gt; </td></tr>
<tr class="memitem:a071dbaa078a310d6e8bd2aa0eb028695"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a071dbaa078a310d6e8bd2aa0eb028695">operator&gt;&gt;=</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>, <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> <a class="el" href="namespaceetl.html#a3acb4483c815a6504bcca76ca33d7d0f">shift</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a071dbaa078a310d6e8bd2aa0eb028695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return b = b &gt;&gt; shift;</code>  <a href="namespaceetl.html#a071dbaa078a310d6e8bd2aa0eb028695">More...</a><br /></td></tr>
<tr class="separator:a071dbaa078a310d6e8bd2aa0eb028695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1165be7031be3bc4b2ca83ab0f4da3d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab1165be7031be3bc4b2ca83ab0f4da3d">operator|</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:ab1165be7031be3bc4b2ca83ab0f4da3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) | static_cast&lt;unsigned int&gt;(rhs));</code>  <a href="namespaceetl.html#ab1165be7031be3bc4b2ca83ab0f4da3d">More...</a><br /></td></tr>
<tr class="separator:ab1165be7031be3bc4b2ca83ab0f4da3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49515e2d52191477551bdd9dada0ffe7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a49515e2d52191477551bdd9dada0ffe7">operator&amp;</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:a49515e2d52191477551bdd9dada0ffe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) &amp; static_cast&lt;unsigned int&gt;(rhs));</code>  <a href="namespaceetl.html#a49515e2d52191477551bdd9dada0ffe7">More...</a><br /></td></tr>
<tr class="separator:a49515e2d52191477551bdd9dada0ffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bf67065e04389a339bfcffa2d58de7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a52bf67065e04389a339bfcffa2d58de7">operator^</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:a52bf67065e04389a339bfcffa2d58de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) ^ static_cast&lt;unsigned int&gt;(rhs));</code>  <a href="namespaceetl.html#a52bf67065e04389a339bfcffa2d58de7">More...</a><br /></td></tr>
<tr class="separator:a52bf67065e04389a339bfcffa2d58de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb428553f8379a8f3920c202cd85993"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6cb428553f8379a8f3920c202cd85993">operator~</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:a6cb428553f8379a8f3920c202cd85993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(~static_cast&lt;unsigned int&gt;(b));</code>  <a href="namespaceetl.html#a6cb428553f8379a8f3920c202cd85993">More...</a><br /></td></tr>
<tr class="separator:a6cb428553f8379a8f3920c202cd85993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5809b0b530dbcedb43f8300cee97c4d7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5809b0b530dbcedb43f8300cee97c4d7">operator|=</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a5809b0b530dbcedb43f8300cee97c4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs | rhs;</code>  <a href="namespaceetl.html#a5809b0b530dbcedb43f8300cee97c4d7">More...</a><br /></td></tr>
<tr class="separator:a5809b0b530dbcedb43f8300cee97c4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe619a854c58b98dd311ab0411dd1870"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abe619a854c58b98dd311ab0411dd1870">operator&amp;=</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:abe619a854c58b98dd311ab0411dd1870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs &amp; rhs;</code>  <a href="namespaceetl.html#abe619a854c58b98dd311ab0411dd1870">More...</a><br /></td></tr>
<tr class="separator:abe619a854c58b98dd311ab0411dd1870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdab0f40108ae4c427a26dd401a81418"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acdab0f40108ae4c427a26dd401a81418">operator^=</a> (<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:acdab0f40108ae4c427a26dd401a81418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs ^ rhs;</code>  <a href="namespaceetl.html#acdab0f40108ae4c427a26dd401a81418">More...</a><br /></td></tr>
<tr class="separator:acdab0f40108ae4c427a26dd401a81418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70c570009ef313782a1d98cfdadb585"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af70c570009ef313782a1d98cfdadb585">atof</a> (char const *str) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:af70c570009ef313782a1d98cfdadb585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <a href="namespaceetl.html#af70c570009ef313782a1d98cfdadb585">More...</a><br /></td></tr>
<tr class="separator:af70c570009ef313782a1d98cfdadb585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7960c7c5d175e0f3618b82c78bcdb2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3c7960c7c5d175e0f3618b82c78bcdb2">atoi</a> (char const *str) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a3c7960c7c5d175e0f3618b82c78bcdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <a href="namespaceetl.html#a3c7960c7c5d175e0f3618b82c78bcdb2">More...</a><br /></td></tr>
<tr class="separator:a3c7960c7c5d175e0f3618b82c78bcdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f3cb11f38d582981fb054f50f8a39c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac7f3cb11f38d582981fb054f50f8a39c">atol</a> (char const *str) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long</td></tr>
<tr class="memdesc:ac7f3cb11f38d582981fb054f50f8a39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <a href="namespaceetl.html#ac7f3cb11f38d582981fb054f50f8a39c">More...</a><br /></td></tr>
<tr class="separator:ac7f3cb11f38d582981fb054f50f8a39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc340d657073dbc2d05ea36759ac0e4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afbc340d657073dbc2d05ea36759ac0e4">atoll</a> (char const *str) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long long</td></tr>
<tr class="memdesc:afbc340d657073dbc2d05ea36759ac0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <a href="namespaceetl.html#afbc340d657073dbc2d05ea36759ac0e4">More...</a><br /></td></tr>
<tr class="separator:afbc340d657073dbc2d05ea36759ac0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac545280f6ddc88082f02e4a7db6736"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1ac545280f6ddc88082f02e4a7db6736">div</a> (int x, int y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1div__t.html">div_t</a></td></tr>
<tr class="memdesc:a1ac545280f6ddc88082f02e4a7db6736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <a href="namespaceetl.html#a1ac545280f6ddc88082f02e4a7db6736">More...</a><br /></td></tr>
<tr class="separator:a1ac545280f6ddc88082f02e4a7db6736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b084ea5ad111474f8921643c3de3931"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1b084ea5ad111474f8921643c3de3931">labs</a> (long n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long</td></tr>
<tr class="memdesc:a1b084ea5ad111474f8921643c3de3931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <a href="namespaceetl.html#a1b084ea5ad111474f8921643c3de3931">More...</a><br /></td></tr>
<tr class="separator:a1b084ea5ad111474f8921643c3de3931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b5e9350f1530967470589c83376b30"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a43b5e9350f1530967470589c83376b30">div</a> (long x, long y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:a43b5e9350f1530967470589c83376b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <a href="namespaceetl.html#a43b5e9350f1530967470589c83376b30">More...</a><br /></td></tr>
<tr class="separator:a43b5e9350f1530967470589c83376b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b706a74e1efaf3c98804627fba671c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab7b706a74e1efaf3c98804627fba671c">ldiv</a> (long x, long y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:ab7b706a74e1efaf3c98804627fba671c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <a href="namespaceetl.html#ab7b706a74e1efaf3c98804627fba671c">More...</a><br /></td></tr>
<tr class="separator:ab7b706a74e1efaf3c98804627fba671c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c11a988c576e5879aa5b6517da8d3e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a03c11a988c576e5879aa5b6517da8d3e">llabs</a> (long long n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long long</td></tr>
<tr class="memdesc:a03c11a988c576e5879aa5b6517da8d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <a href="namespaceetl.html#a03c11a988c576e5879aa5b6517da8d3e">More...</a><br /></td></tr>
<tr class="separator:a03c11a988c576e5879aa5b6517da8d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea0cf9ba86f1635030cb6a8f03c88b0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3ea0cf9ba86f1635030cb6a8f03c88b0">div</a> (long long x, long long y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:a3ea0cf9ba86f1635030cb6a8f03c88b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <a href="namespaceetl.html#a3ea0cf9ba86f1635030cb6a8f03c88b0">More...</a><br /></td></tr>
<tr class="separator:a3ea0cf9ba86f1635030cb6a8f03c88b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6958cfa96164c754c7859d22d8e5a95"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac6958cfa96164c754c7859d22d8e5a95">lldiv</a> (long long x, long long y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:ac6958cfa96164c754c7859d22d8e5a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <a href="namespaceetl.html#ac6958cfa96164c754c7859d22d8e5a95">More...</a><br /></td></tr>
<tr class="separator:ac6958cfa96164c754c7859d22d8e5a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1305ac2417af24cbfd08da05eeb1c32d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1305ac2417af24cbfd08da05eeb1c32d">strtod</a> (char const *str, char const **<a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>=nullptr) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="memdesc:a1305ac2417af24cbfd08da05eeb1c32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <a href="namespaceetl.html#a1305ac2417af24cbfd08da05eeb1c32d">More...</a><br /></td></tr>
<tr class="separator:a1305ac2417af24cbfd08da05eeb1c32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4">strtof</a> (char const *str, char const **<a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>=nullptr) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="memdesc:aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <a href="namespaceetl.html#aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4">More...</a><br /></td></tr>
<tr class="separator:aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4892f7bf3b9db8e5a5b3476de9f04c07"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4892f7bf3b9db8e5a5b3476de9f04c07">strtol</a> (char const *str, char const **<a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, int <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long</td></tr>
<tr class="memdesc:a4892f7bf3b9db8e5a5b3476de9f04c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <a href="namespaceetl.html#a4892f7bf3b9db8e5a5b3476de9f04c07">More...</a><br /></td></tr>
<tr class="separator:a4892f7bf3b9db8e5a5b3476de9f04c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53416ace17ca278512fca91c7ba514a9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a53416ace17ca278512fca91c7ba514a9">strtoll</a> (char const *str, char const **<a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, int <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long long</td></tr>
<tr class="memdesc:a53416ace17ca278512fca91c7ba514a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <a href="namespaceetl.html#a53416ace17ca278512fca91c7ba514a9">More...</a><br /></td></tr>
<tr class="separator:a53416ace17ca278512fca91c7ba514a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b910e11532f3565d81bd36ff4e4c10"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af4b910e11532f3565d81bd36ff4e4c10">strtold</a> (char const *str, char const **<a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>=nullptr) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="memdesc:af4b910e11532f3565d81bd36ff4e4c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <a href="namespaceetl.html#af4b910e11532f3565d81bd36ff4e4c10">More...</a><br /></td></tr>
<tr class="separator:af4b910e11532f3565d81bd36ff4e4c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e80359aae6a19c6d0dc9aee1ba6fcb5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4e80359aae6a19c6d0dc9aee1ba6fcb5">strtoul</a> (char const *str, char const **<a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, int <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; unsigned long</td></tr>
<tr class="memdesc:a4e80359aae6a19c6d0dc9aee1ba6fcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <a href="namespaceetl.html#a4e80359aae6a19c6d0dc9aee1ba6fcb5">More...</a><br /></td></tr>
<tr class="separator:a4e80359aae6a19c6d0dc9aee1ba6fcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760b4a7bd2816e64811c98ac8e21e5c3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a760b4a7bd2816e64811c98ac8e21e5c3">strtoull</a> (char const *str, char const **<a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, int <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; unsigned long long</td></tr>
<tr class="memdesc:a760b4a7bd2816e64811c98ac8e21e5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <a href="namespaceetl.html#a760b4a7bd2816e64811c98ac8e21e5c3">More...</a><br /></td></tr>
<tr class="separator:a760b4a7bd2816e64811c98ac8e21e5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652d4e77b1294b6c89f3b26e64390c60"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a652d4e77b1294b6c89f3b26e64390c60">memchr</a> (void *ptr, int ch, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:a652d4e77b1294b6c89f3b26e64390c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr.  <a href="namespaceetl.html#a652d4e77b1294b6c89f3b26e64390c60">More...</a><br /></td></tr>
<tr class="separator:a652d4e77b1294b6c89f3b26e64390c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017dcc9819e43ade5bb455dda0ded667"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a017dcc9819e43ade5bb455dda0ded667">memchr</a> (void const *ptr, int ch, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> n) -&gt; void const *</td></tr>
<tr class="memdesc:a017dcc9819e43ade5bb455dda0ded667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr.  <a href="namespaceetl.html#a017dcc9819e43ade5bb455dda0ded667">More...</a><br /></td></tr>
<tr class="separator:a017dcc9819e43ade5bb455dda0ded667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7fa1c3f3f946c9269a7aa241e3efcf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1a7fa1c3f3f946c9269a7aa241e3efcf">memcpy</a> (void *dest, void const *src, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:a1a7fa1c3f3f946c9269a7aa241e3efcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="namespaceetl.html#abfee8229e9528f5285c42fde7abbe4b6" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead.  <a href="namespaceetl.html#a1a7fa1c3f3f946c9269a7aa241e3efcf">More...</a><br /></td></tr>
<tr class="separator:a1a7fa1c3f3f946c9269a7aa241e3efcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfee8229e9528f5285c42fde7abbe4b6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abfee8229e9528f5285c42fde7abbe4b6">memmove</a> (void *dest, void const *src, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; void *</td></tr>
<tr class="memdesc:abfee8229e9528f5285c42fde7abbe4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap.  <a href="namespaceetl.html#abfee8229e9528f5285c42fde7abbe4b6">More...</a><br /></td></tr>
<tr class="separator:abfee8229e9528f5285c42fde7abbe4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055dc327ea35a394f661ca98bf2b08ad"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a055dc327ea35a394f661ca98bf2b08ad">memset</a> (void *s, int c, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:a055dc327ea35a394f661ca98bf2b08ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the value of c (converted to an unsigned char) into each of the ﬁrst n characters of the object pointed to by s.  <a href="namespaceetl.html#a055dc327ea35a394f661ca98bf2b08ad">More...</a><br /></td></tr>
<tr class="separator:a055dc327ea35a394f661ca98bf2b08ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb9a3999d07c6ea33b804dc470d6db3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abbb9a3999d07c6ea33b804dc470d6db3">strcat</a> (char *dest, char const *src) -&gt; char *</td></tr>
<tr class="memdesc:abbb9a3999d07c6ea33b804dc470d6db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the character string pointed to by src to the end of the character string pointed to by dest. The character src[0] replaces the null terminator at the end of dest. The resulting byte string is null-terminated.  <a href="namespaceetl.html#abbb9a3999d07c6ea33b804dc470d6db3">More...</a><br /></td></tr>
<tr class="separator:abbb9a3999d07c6ea33b804dc470d6db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae924f4675f1be06ee9610b8998d20101"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae924f4675f1be06ee9610b8998d20101">strchr</a> (char const *str, int ch) -&gt; char const *</td></tr>
<tr class="memdesc:ae924f4675f1be06ee9610b8998d20101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <a href="namespaceetl.html#ae924f4675f1be06ee9610b8998d20101">More...</a><br /></td></tr>
<tr class="separator:ae924f4675f1be06ee9610b8998d20101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaf5ecef57c791ea8f5d102444af26f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afdaf5ecef57c791ea8f5d102444af26f">strchr</a> (char *str, int ch) -&gt; char *</td></tr>
<tr class="memdesc:afdaf5ecef57c791ea8f5d102444af26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <a href="namespaceetl.html#afdaf5ecef57c791ea8f5d102444af26f">More...</a><br /></td></tr>
<tr class="separator:afdaf5ecef57c791ea8f5d102444af26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b99355fef2ddb6740fbda691efe5591"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2b99355fef2ddb6740fbda691efe5591">strcmp</a> (char const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, char const *rhs) -&gt; int</td></tr>
<tr class="memdesc:a2b99355fef2ddb6740fbda691efe5591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the C string lhs to the C string rhs.  <a href="namespaceetl.html#a2b99355fef2ddb6740fbda691efe5591">More...</a><br /></td></tr>
<tr class="separator:a2b99355fef2ddb6740fbda691efe5591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72afd377245fa4f73d8c4c49b5e42fd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac72afd377245fa4f73d8c4c49b5e42fd">strcpy</a> (char *dest, char const *src) -&gt; char *</td></tr>
<tr class="memdesc:ac72afd377245fa4f73d8c4c49b5e42fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the character string pointed to by src, including the null terminator, to the character array whose first element is pointed to by dest.  <a href="namespaceetl.html#ac72afd377245fa4f73d8c4c49b5e42fd">More...</a><br /></td></tr>
<tr class="separator:ac72afd377245fa4f73d8c4c49b5e42fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b32f2701df8bd44d7cff9b1ea93c2c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a07b32f2701df8bd44d7cff9b1ea93c2c">strcspn</a> (char const *dest, char const *src) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></td></tr>
<tr class="memdesc:a07b32f2701df8bd44d7cff9b1ea93c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the byte string pointed to by dest, that consists of only the characters not found in byte string pointed to by src.  <a href="namespaceetl.html#a07b32f2701df8bd44d7cff9b1ea93c2c">More...</a><br /></td></tr>
<tr class="separator:a07b32f2701df8bd44d7cff9b1ea93c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52f9a0c2a72681b011673eb4d16997"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1f52f9a0c2a72681b011673eb4d16997">strlen</a> (char const *str) -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></td></tr>
<tr class="memdesc:a1f52f9a0c2a72681b011673eb4d16997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the C string str.  <a href="namespaceetl.html#a1f52f9a0c2a72681b011673eb4d16997">More...</a><br /></td></tr>
<tr class="separator:a1f52f9a0c2a72681b011673eb4d16997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a52c188c85f66642fdcd0b2a5c0f343"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3a52c188c85f66642fdcd0b2a5c0f343">strncat</a> (char *dest, char const *src, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> const <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; char *</td></tr>
<tr class="memdesc:a3a52c188c85f66642fdcd0b2a5c0f343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a byte string pointed to by src to a byte string pointed to by dest. At most count characters are copied. The resulting byte string is null-terminated.  <a href="namespaceetl.html#a3a52c188c85f66642fdcd0b2a5c0f343">More...</a><br /></td></tr>
<tr class="separator:a3a52c188c85f66642fdcd0b2a5c0f343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ea9bb99dc7df1c93691e27036d4e4c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a86ea9bb99dc7df1c93691e27036d4e4c">strncmp</a> (char const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, char const *rhs, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> const <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; int</td></tr>
<tr class="memdesc:a86ea9bb99dc7df1c93691e27036d4e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares at most count characters of two possibly null-terminated arrays. The comparison is done lexicographically. Characters following the null character are not compared.  <a href="namespaceetl.html#a86ea9bb99dc7df1c93691e27036d4e4c">More...</a><br /></td></tr>
<tr class="separator:a86ea9bb99dc7df1c93691e27036d4e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591fc182edd0e8beef7af369c2dd772f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a591fc182edd0e8beef7af369c2dd772f">strncpy</a> (char *dest, char const *src, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> const <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; char *</td></tr>
<tr class="memdesc:a591fc182edd0e8beef7af369c2dd772f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies at most count characters of the byte string pointed to by src (including the terminating null character) to character array pointed to by dest.  <a href="namespaceetl.html#a591fc182edd0e8beef7af369c2dd772f">More...</a><br /></td></tr>
<tr class="separator:a591fc182edd0e8beef7af369c2dd772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7504aaa95975de1bb831366bbd2c4c7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af7504aaa95975de1bb831366bbd2c4c7">strpbrk</a> (char const *dest, char const *breakset) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; char const *</td></tr>
<tr class="memdesc:af7504aaa95975de1bb831366bbd2c4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character.  <a href="namespaceetl.html#af7504aaa95975de1bb831366bbd2c4c7">More...</a><br /></td></tr>
<tr class="separator:af7504aaa95975de1bb831366bbd2c4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e3a1713cb32006d461f6cacaa45938"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa2e3a1713cb32006d461f6cacaa45938">strpbrk</a> (char *dest, char *breakset) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; char *</td></tr>
<tr class="memdesc:aa2e3a1713cb32006d461f6cacaa45938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character.  <a href="namespaceetl.html#aa2e3a1713cb32006d461f6cacaa45938">More...</a><br /></td></tr>
<tr class="separator:aa2e3a1713cb32006d461f6cacaa45938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1aa1bb3b20e18932c57369e8dd367ce"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa1aa1bb3b20e18932c57369e8dd367ce">strrchr</a> (char const *str, int ch) -&gt; char const *</td></tr>
<tr class="memdesc:aa1aa1bb3b20e18932c57369e8dd367ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <a href="namespaceetl.html#aa1aa1bb3b20e18932c57369e8dd367ce">More...</a><br /></td></tr>
<tr class="separator:aa1aa1bb3b20e18932c57369e8dd367ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f722dadf4562da90ec04a75000dca60"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5f722dadf4562da90ec04a75000dca60">strrchr</a> (char *str, int ch) -&gt; char *</td></tr>
<tr class="memdesc:a5f722dadf4562da90ec04a75000dca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <a href="namespaceetl.html#a5f722dadf4562da90ec04a75000dca60">More...</a><br /></td></tr>
<tr class="separator:a5f722dadf4562da90ec04a75000dca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef81a9b0d796d2bbac780bd021b75d5a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aef81a9b0d796d2bbac780bd021b75d5a">strspn</a> (char const *dest, char const *src) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></td></tr>
<tr class="memdesc:aef81a9b0d796d2bbac780bd021b75d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment (span) of the byte string pointed to by dest, that consists of only the characters found in byte string pointed to by src.  <a href="namespaceetl.html#aef81a9b0d796d2bbac780bd021b75d5a">More...</a><br /></td></tr>
<tr class="separator:aef81a9b0d796d2bbac780bd021b75d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda82eb09b8ee508deb730a58e8e1ad0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abda82eb09b8ee508deb730a58e8e1ad0">strstr</a> (char *haystack, char *needle) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; char *</td></tr>
<tr class="memdesc:abda82eb09b8ee508deb730a58e8e1ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared.  <a href="namespaceetl.html#abda82eb09b8ee508deb730a58e8e1ad0">More...</a><br /></td></tr>
<tr class="separator:abda82eb09b8ee508deb730a58e8e1ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dedeb847abd763b3016a290b6efd87e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0dedeb847abd763b3016a290b6efd87e">strstr</a> (char const *haystack, char const *needle) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; char const *</td></tr>
<tr class="memdesc:a0dedeb847abd763b3016a290b6efd87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared.  <a href="namespaceetl.html#a0dedeb847abd763b3016a290b6efd87e">More...</a><br /></td></tr>
<tr class="separator:a0dedeb847abd763b3016a290b6efd87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb64ccab832f8ed29a305df495394bd8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afb64ccab832f8ed29a305df495394bd8">wcscat</a> (wchar_t *dest, wchar_t const *src) -&gt; wchar_t *</td></tr>
<tr class="memdesc:afb64ccab832f8ed29a305df495394bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the wide string pointed to by src to the end of the wide string pointed to by dest. The wide character src[0] replaces the null terminator at the end of dest. The resulting wide string is null-terminated.  <a href="namespaceetl.html#afb64ccab832f8ed29a305df495394bd8">More...</a><br /></td></tr>
<tr class="separator:afb64ccab832f8ed29a305df495394bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f3717d1befc65ded1e73b0dc19405b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab4f3717d1befc65ded1e73b0dc19405b">wcschr</a> (wchar_t *str, int ch) -&gt; wchar_t *</td></tr>
<tr class="memdesc:ab4f3717d1befc65ded1e73b0dc19405b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide character ch in the wide string pointed to by str.  <a href="namespaceetl.html#ab4f3717d1befc65ded1e73b0dc19405b">More...</a><br /></td></tr>
<tr class="separator:ab4f3717d1befc65ded1e73b0dc19405b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc2ac1163d4f8e69b06785a16903b92"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afcc2ac1163d4f8e69b06785a16903b92">wcschr</a> (wchar_t const *str, int ch) -&gt; wchar_t const *</td></tr>
<tr class="memdesc:afcc2ac1163d4f8e69b06785a16903b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide character ch in the wide string pointed to by str.  <a href="namespaceetl.html#afcc2ac1163d4f8e69b06785a16903b92">More...</a><br /></td></tr>
<tr class="separator:afcc2ac1163d4f8e69b06785a16903b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dacca606e09097af1b0d48826fbbaf8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8dacca606e09097af1b0d48826fbbaf8">wcscmp</a> (wchar_t const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, wchar_t const *rhs) -&gt; int</td></tr>
<tr class="memdesc:a8dacca606e09097af1b0d48826fbbaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two null-terminated wide strings lexicographically.  <a href="namespaceetl.html#a8dacca606e09097af1b0d48826fbbaf8">More...</a><br /></td></tr>
<tr class="separator:a8dacca606e09097af1b0d48826fbbaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777b53d3246198c5cbf458e59cbd05bf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a777b53d3246198c5cbf458e59cbd05bf">wcscpy</a> (wchar_t *dest, wchar_t const *src) -&gt; wchar_t *</td></tr>
<tr class="memdesc:a777b53d3246198c5cbf458e59cbd05bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest.  <a href="namespaceetl.html#a777b53d3246198c5cbf458e59cbd05bf">More...</a><br /></td></tr>
<tr class="separator:a777b53d3246198c5cbf458e59cbd05bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a295816ea0a099202fb0dca32be52c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af4a295816ea0a099202fb0dca32be52c">wcscspn</a> (wchar_t const *dest, wchar_t const *src) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></td></tr>
<tr class="memdesc:af4a295816ea0a099202fb0dca32be52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters not found in wide string pointed to by src.  <a href="namespaceetl.html#af4a295816ea0a099202fb0dca32be52c">More...</a><br /></td></tr>
<tr class="separator:af4a295816ea0a099202fb0dca32be52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52365d01da2db57b4fd8ab457fde90d4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a52365d01da2db57b4fd8ab457fde90d4">wcslen</a> (wchar_t const *str) -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a></td></tr>
<tr class="memdesc:a52365d01da2db57b4fd8ab457fde90d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character.  <a href="namespaceetl.html#a52365d01da2db57b4fd8ab457fde90d4">More...</a><br /></td></tr>
<tr class="separator:a52365d01da2db57b4fd8ab457fde90d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d334b345c8ec3b4df9ed3017e1a0e9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a31d334b345c8ec3b4df9ed3017e1a0e9">wcsncat</a> (wchar_t *dest, wchar_t const *src, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> const <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; wchar_t *</td></tr>
<tr class="memdesc:a31d334b345c8ec3b4df9ed3017e1a0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends at most count wide characters from the wide string pointed to by src to the end of the character string pointed to by dest, stopping if the null terminator is copied. The wide character src[0] replaces the null terminator at the end of dest. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is count+1).  <a href="namespaceetl.html#a31d334b345c8ec3b4df9ed3017e1a0e9">More...</a><br /></td></tr>
<tr class="separator:a31d334b345c8ec3b4df9ed3017e1a0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cb809db1b2078c2f3a183d9cf15fe6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad6cb809db1b2078c2f3a183d9cf15fe6">wcsncmp</a> (wchar_t const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, wchar_t const *rhs, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; int</td></tr>
<tr class="memdesc:ad6cb809db1b2078c2f3a183d9cf15fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares at most count wide characters of two null-terminated wide strings. The comparison is done lexicographically.  <a href="namespaceetl.html#ad6cb809db1b2078c2f3a183d9cf15fe6">More...</a><br /></td></tr>
<tr class="separator:ad6cb809db1b2078c2f3a183d9cf15fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df6765439e9363b7bd6b29c16e9ad1e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3df6765439e9363b7bd6b29c16e9ad1e">wcsncpy</a> (wchar_t *dest, wchar_t const *src, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> const <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; wchar_t *</td></tr>
<tr class="memdesc:a3df6765439e9363b7bd6b29c16e9ad1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies at most count characters of the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest.  <a href="namespaceetl.html#a3df6765439e9363b7bd6b29c16e9ad1e">More...</a><br /></td></tr>
<tr class="separator:a3df6765439e9363b7bd6b29c16e9ad1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543232e434a1cf41ac373bb986dd6761"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a543232e434a1cf41ac373bb986dd6761">wcspbrk</a> (wchar_t *dest, wchar_t *breakset) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; wchar_t *</td></tr>
<tr class="memdesc:a543232e434a1cf41ac373bb986dd6761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str.  <a href="namespaceetl.html#a543232e434a1cf41ac373bb986dd6761">More...</a><br /></td></tr>
<tr class="separator:a543232e434a1cf41ac373bb986dd6761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b719c7d907c831543f6a36d7c03c358"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8b719c7d907c831543f6a36d7c03c358">wcspbrk</a> (wchar_t const *dest, wchar_t const *breakset) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; wchar_t const *</td></tr>
<tr class="memdesc:a8b719c7d907c831543f6a36d7c03c358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str.  <a href="namespaceetl.html#a8b719c7d907c831543f6a36d7c03c358">More...</a><br /></td></tr>
<tr class="separator:a8b719c7d907c831543f6a36d7c03c358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cde920ef4c8b78dad83887cf67520dd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5cde920ef4c8b78dad83887cf67520dd">wcsrchr</a> (wchar_t *str, int ch) -&gt; wchar_t *</td></tr>
<tr class="memdesc:a5cde920ef4c8b78dad83887cf67520dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the wide character ch in the wide string pointed to by str.  <a href="namespaceetl.html#a5cde920ef4c8b78dad83887cf67520dd">More...</a><br /></td></tr>
<tr class="separator:a5cde920ef4c8b78dad83887cf67520dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b66e9eebb616eadbab0b3001b1e9660"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1b66e9eebb616eadbab0b3001b1e9660">wcsrchr</a> (wchar_t const *str, int ch) -&gt; wchar_t const *</td></tr>
<tr class="memdesc:a1b66e9eebb616eadbab0b3001b1e9660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the wide character ch in the wide string pointed to by str.  <a href="namespaceetl.html#a1b66e9eebb616eadbab0b3001b1e9660">More...</a><br /></td></tr>
<tr class="separator:a1b66e9eebb616eadbab0b3001b1e9660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c979220a7a1ae7a993a34cce85292a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a51c979220a7a1ae7a993a34cce85292a">wcsspn</a> (wchar_t const *dest, wchar_t const *src) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></td></tr>
<tr class="memdesc:a51c979220a7a1ae7a993a34cce85292a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters found in wide string pointed to by src.  <a href="namespaceetl.html#a51c979220a7a1ae7a993a34cce85292a">More...</a><br /></td></tr>
<tr class="separator:a51c979220a7a1ae7a993a34cce85292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32485447cbd1674e0686656279ec028c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a32485447cbd1674e0686656279ec028c">wcsstr</a> (wchar_t *haystack, wchar_t *needle) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; wchar_t *</td></tr>
<tr class="memdesc:a32485447cbd1674e0686656279ec028c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared.  <a href="namespaceetl.html#a32485447cbd1674e0686656279ec028c">More...</a><br /></td></tr>
<tr class="separator:a32485447cbd1674e0686656279ec028c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074c0611a936348d0a6ca7ddc93df74a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a074c0611a936348d0a6ca7ddc93df74a">wcsstr</a> (wchar_t const *haystack, wchar_t const *needle) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; wchar_t const *</td></tr>
<tr class="memdesc:a074c0611a936348d0a6ca7ddc93df74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared.  <a href="namespaceetl.html#a074c0611a936348d0a6ca7ddc93df74a">More...</a><br /></td></tr>
<tr class="separator:a074c0611a936348d0a6ca7ddc93df74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e196f654f32975356c8fba3537a39de"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2e196f654f32975356c8fba3537a39de">wmemchr</a> (wchar_t *ptr, wchar_t ch, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; wchar_t *</td></tr>
<tr class="memdesc:a2e196f654f32975356c8fba3537a39de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr.  <a href="namespaceetl.html#a2e196f654f32975356c8fba3537a39de">More...</a><br /></td></tr>
<tr class="separator:a2e196f654f32975356c8fba3537a39de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae467dc0a0abf29b78d47c3b475ecb5ba"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae467dc0a0abf29b78d47c3b475ecb5ba">wmemchr</a> (wchar_t const *ptr, wchar_t ch, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; wchar_t const *</td></tr>
<tr class="memdesc:ae467dc0a0abf29b78d47c3b475ecb5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr.  <a href="namespaceetl.html#ae467dc0a0abf29b78d47c3b475ecb5ba">More...</a><br /></td></tr>
<tr class="separator:ae467dc0a0abf29b78d47c3b475ecb5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379cf75ba2d4c066193884e36556cf04"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a379cf75ba2d4c066193884e36556cf04">wmemcmp</a> (wchar_t const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, wchar_t const *rhs, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a379cf75ba2d4c066193884e36556cf04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first count wide characters of the wide character arrays pointed to by lhs and rhs. The comparison is done lexicographically.  <a href="namespaceetl.html#a379cf75ba2d4c066193884e36556cf04">More...</a><br /></td></tr>
<tr class="separator:a379cf75ba2d4c066193884e36556cf04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d687ebc1e3e94aa01302127c3eb8400"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1d687ebc1e3e94aa01302127c3eb8400">wmemcpy</a> (wchar_t *dest, wchar_t const *src, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; wchar_t *</td></tr>
<tr class="memdesc:a1d687ebc1e3e94aa01302127c3eb8400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. If the objects overlap, the behavior is undefined. If count is zero, the function does nothing.  <a href="namespaceetl.html#a1d687ebc1e3e94aa01302127c3eb8400">More...</a><br /></td></tr>
<tr class="separator:a1d687ebc1e3e94aa01302127c3eb8400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cdeb9c67af4a7dfe7cc7ab4c88e390"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a87cdeb9c67af4a7dfe7cc7ab4c88e390">wmemmove</a> (wchar_t *dest, wchar_t const *src, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; wchar_t *</td></tr>
<tr class="memdesc:a87cdeb9c67af4a7dfe7cc7ab4c88e390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest.  <a href="namespaceetl.html#a87cdeb9c67af4a7dfe7cc7ab4c88e390">More...</a><br /></td></tr>
<tr class="separator:a87cdeb9c67af4a7dfe7cc7ab4c88e390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a108d16f8cd8006676972370a2b2ed"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a24a108d16f8cd8006676972370a2b2ed">wmemset</a> (wchar_t *dest, wchar_t ch, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; wchar_t *</td></tr>
<tr class="memdesc:a24a108d16f8cd8006676972370a2b2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the wide character ch into each of the first count wide characters of the wide character array pointed to by dest.  <a href="namespaceetl.html#a24a108d16f8cd8006676972370a2b2ed">More...</a><br /></td></tr>
<tr class="separator:a24a108d16f8cd8006676972370a2b2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf33590c450c820a71740fa96d4fd8bf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adf33590c450c820a71740fa96d4fd8bf">iswalnum</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:adf33590c450c820a71740fa96d4fd8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an alphanumeric character, i.e. either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphanumeric character specific to the current locale.  <a href="namespaceetl.html#adf33590c450c820a71740fa96d4fd8bf">More...</a><br /></td></tr>
<tr class="separator:adf33590c450c820a71740fa96d4fd8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bb7228a1ec4507b17c3800ae7edaad"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a50bb7228a1ec4507b17c3800ae7edaad">iswalpha</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a50bb7228a1ec4507b17c3800ae7edaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphabetic character specific to the current locale.  <a href="namespaceetl.html#a50bb7228a1ec4507b17c3800ae7edaad">More...</a><br /></td></tr>
<tr class="separator:a50bb7228a1ec4507b17c3800ae7edaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8266a2249c1038e8be09fc34571aa3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ace8266a2249c1038e8be09fc34571aa3">iswblank</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:ace8266a2249c1038e8be09fc34571aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (0x20) and horizontal tab (0x09) are blank characters.  <a href="namespaceetl.html#ace8266a2249c1038e8be09fc34571aa3">More...</a><br /></td></tr>
<tr class="separator:ace8266a2249c1038e8be09fc34571aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16fb2c6452c7d592f75fad4c301f65f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa16fb2c6452c7d592f75fad4c301f65f">iswcntrl</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:aa16fb2c6452c7d592f75fad4c301f65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a control character, i.e. codes 0x00-0x1F and 0x7F and any control characters specific to the current locale.  <a href="namespaceetl.html#aa16fb2c6452c7d592f75fad4c301f65f">More...</a><br /></td></tr>
<tr class="separator:aa16fb2c6452c7d592f75fad4c301f65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a984673da6b8253c14ef105d4ecabe"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a91a984673da6b8253c14ef105d4ecabe">iswdigit</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a91a984673da6b8253c14ef105d4ecabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.  <a href="namespaceetl.html#a91a984673da6b8253c14ef105d4ecabe">More...</a><br /></td></tr>
<tr class="separator:a91a984673da6b8253c14ef105d4ecabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f830b2cf289299d90d426cdec407ee"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af1f830b2cf289299d90d426cdec407ee">iswgraph</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:af1f830b2cf289299d90d426cdec407ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character has a graphical representation, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~) or any graphical character specific to the current C locale.  <a href="namespaceetl.html#af1f830b2cf289299d90d426cdec407ee">More...</a><br /></td></tr>
<tr class="separator:af1f830b2cf289299d90d426cdec407ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eb7b15acffae2d169a7eaed66d9ba8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a18eb7b15acffae2d169a7eaed66d9ba8">iswlower</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a18eb7b15acffae2d169a7eaed66d9ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a lowercase letter, i.e. one of abcdefghijklmnopqrstuvwxyz or any lowercase letter specific to the current locale.  <a href="namespaceetl.html#a18eb7b15acffae2d169a7eaed66d9ba8">More...</a><br /></td></tr>
<tr class="separator:a18eb7b15acffae2d169a7eaed66d9ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c5da6eb3f6bb1409caaf48fe877d11"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a92c5da6eb3f6bb1409caaf48fe877d11">iswprint</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a92c5da6eb3f6bb1409caaf48fe877d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character can be printed, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~), space or any printable character specific to the current C locale.  <a href="namespaceetl.html#a92c5da6eb3f6bb1409caaf48fe877d11">More...</a><br /></td></tr>
<tr class="separator:a92c5da6eb3f6bb1409caaf48fe877d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0e85b2a576c543e973d860e1c1295f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ace0e85b2a576c543e973d860e1c1295f">iswpunct</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:ace0e85b2a576c543e973d860e1c1295f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a punctuation character, i.e. it is one of !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~ or any punctuation character specific to the current locale.  <a href="namespaceetl.html#ace0e85b2a576c543e973d860e1c1295f">More...</a><br /></td></tr>
<tr class="separator:ace0e85b2a576c543e973d860e1c1295f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dbfeff185b4dad6a13d3c3e891f366"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a38dbfeff185b4dad6a13d3c3e891f366">iswspace</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a38dbfeff185b4dad6a13d3c3e891f366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:  <a href="namespaceetl.html#a38dbfeff185b4dad6a13d3c3e891f366">More...</a><br /></td></tr>
<tr class="separator:a38dbfeff185b4dad6a13d3c3e891f366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31f677c72798a1e14ebb84dc2672e21"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae31f677c72798a1e14ebb84dc2672e21">iswupper</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:ae31f677c72798a1e14ebb84dc2672e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an uppercase letter, i.e. one of ABCDEFGHIJKLMNOPQRSTUVWXYZ or any uppercase letter specific to the current locale.  <a href="namespaceetl.html#ae31f677c72798a1e14ebb84dc2672e21">More...</a><br /></td></tr>
<tr class="separator:ae31f677c72798a1e14ebb84dc2672e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac809578dc97747348dcc5795cbfa86ff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac809578dc97747348dcc5795cbfa86ff">iswxdigit</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:ac809578dc97747348dcc5795cbfa86ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of 0123456789abcdefABCDEF.  <a href="namespaceetl.html#ac809578dc97747348dcc5795cbfa86ff">More...</a><br /></td></tr>
<tr class="separator:ac809578dc97747348dcc5795cbfa86ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84de6738bfdc87aa9da8b107db172a43"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a84de6738bfdc87aa9da8b107db172a43">towlower</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a></td></tr>
<tr class="memdesc:a84de6738bfdc87aa9da8b107db172a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given wide character to lowercase, if possible.  <a href="namespaceetl.html#a84de6738bfdc87aa9da8b107db172a43">More...</a><br /></td></tr>
<tr class="separator:a84de6738bfdc87aa9da8b107db172a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9a0766e4327d94f39e77acc5a88bbc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0a9a0766e4327d94f39e77acc5a88bbc">towupper</a> (<a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a> ch) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a></td></tr>
<tr class="memdesc:a0a9a0766e4327d94f39e77acc5a88bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given wide character to uppercase, if possible.  <a href="namespaceetl.html#a0a9a0766e4327d94f39e77acc5a88bbc">More...</a><br /></td></tr>
<tr class="separator:a0a9a0766e4327d94f39e77acc5a88bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf97f58690e1661fa4c536e2a89c9b52"><td class="memTemplParams" colspan="2">template&lt;typename Exception &gt; </td></tr>
<tr class="memitem:aaf97f58690e1661fa4c536e2a89c9b52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#abb156b0e852ad82749ae42934d3b4dbf">TETL_NO_INLINE</a> <a class="el" href="attributes_8hpp.html#af0eb4be3e44a6a8a9235265e12ad89a7">TETL_COLD</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaf97f58690e1661fa4c536e2a89c9b52">raise</a> (char const *msg) -&gt; void</td></tr>
<tr class="separator:aaf97f58690e1661fa4c536e2a89c9b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11c4b54fda6c14f1df7ee9acbb8990b"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:af11c4b54fda6c14f1df7ee9acbb8990b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af11c4b54fda6c14f1df7ee9acbb8990b">unexpected</a> (E) -&gt; <a class="el" href="structetl_1_1unexpected.html">unexpected</a>&lt; E &gt;</td></tr>
<tr class="separator:af11c4b54fda6c14f1df7ee9acbb8990b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4a29ac6268a32d655a572bc728d561"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:a2e4a29ac6268a32d655a572bc728d561"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2e4a29ac6268a32d655a572bc728d561">operator==</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;x, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;y) -&gt; bool</td></tr>
<tr class="separator:a2e4a29ac6268a32d655a572bc728d561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb7776985e823982b6dd579ea9446a5"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:adbb7776985e823982b6dd579ea9446a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adbb7776985e823982b6dd579ea9446a5">operator!=</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;x, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;y) -&gt; bool</td></tr>
<tr class="separator:adbb7776985e823982b6dd579ea9446a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9846352e3d467e86fb4172d2637104"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:a0f9846352e3d467e86fb4172d2637104"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0f9846352e3d467e86fb4172d2637104">operator&lt;</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;x, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;y) -&gt; bool</td></tr>
<tr class="separator:a0f9846352e3d467e86fb4172d2637104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f945b742cbe77cd2922aca6e578b56"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:ac0f945b742cbe77cd2922aca6e578b56"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac0f945b742cbe77cd2922aca6e578b56">operator&gt;</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;x, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;y) -&gt; bool</td></tr>
<tr class="separator:ac0f945b742cbe77cd2922aca6e578b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105dc9103728fcd8f416fecb9b356558"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:a105dc9103728fcd8f416fecb9b356558"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a105dc9103728fcd8f416fecb9b356558">operator&lt;=</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;x, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;y) -&gt; bool</td></tr>
<tr class="separator:a105dc9103728fcd8f416fecb9b356558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c01f47f59173080b54d4233235e144"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:ad9c01f47f59173080b54d4233235e144"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad9c01f47f59173080b54d4233235e144">operator&gt;=</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;x, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;y) -&gt; bool</td></tr>
<tr class="separator:ad9c01f47f59173080b54d4233235e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1cbfaeb551a2e0c9a49d4bb500bc98"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:a2d1cbfaeb551a2e0c9a49d4bb500bc98"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2d1cbfaeb551a2e0c9a49d4bb500bc98">swap</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; &amp;x, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; &amp;y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(x.swap(y))) -&gt; void</td></tr>
<tr class="separator:a2d1cbfaeb551a2e0c9a49d4bb500bc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd52266a9a948c41abe1558e71ac0c95"><td class="memTemplParams" colspan="2">template&lt;typename OutputIt , typename... Args&gt; </td></tr>
<tr class="memitem:afd52266a9a948c41abe1558e71ac0c95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afd52266a9a948c41abe1558e71ac0c95">format_to</a> (OutputIt out, <a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a> fmt, Args const &amp;... args) -&gt; OutputIt</td></tr>
<tr class="memdesc:afd52266a9a948c41abe1558e71ac0c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format args according to the format string fmt, and write the result to the output iterator out.  <a href="namespaceetl.html#afd52266a9a948c41abe1558e71ac0c95">More...</a><br /></td></tr>
<tr class="separator:afd52266a9a948c41abe1558e71ac0c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca222d51d5032dd1702938d3a603d705"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename... Args&gt; </td></tr>
<tr class="memitem:aca222d51d5032dd1702938d3a603d705"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aca222d51d5032dd1702938d3a603d705">format_to_n</a> (OutputIter out, <a class="el" href="namespaceetl.html#a0e4d7671919f2ad18da41013ecd9dde4">diff_t</a>&lt; OutputIter &gt; n, <a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a> fmt, Args const &amp;... args) -&gt; <a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a>&lt; OutputIter &gt;</td></tr>
<tr class="memdesc:aca222d51d5032dd1702938d3a603d705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format args according to the format string fmt, and write the result to the output iterator out. At most n characters are written.  <a href="namespaceetl.html#aca222d51d5032dd1702938d3a603d705">More...</a><br /></td></tr>
<tr class="separator:aca222d51d5032dd1702938d3a603d705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa401a56ff8788d235f9da9eae62db565"><td class="memTemplParams" colspan="2">template&lt;typename Context  = etl::format_context, typename... Args&gt; </td></tr>
<tr class="memitem:aa401a56ff8788d235f9da9eae62db565"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa401a56ff8788d235f9da9eae62db565">make_format_args</a> (Args &amp;&amp;... args) -&gt; detail::format_arg_store&lt; Context, Args... &gt;</td></tr>
<tr class="separator:aa401a56ff8788d235f9da9eae62db565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b34548f40179d322193dd18148c65c5"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2b34548f40179d322193dd18148c65c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2b34548f40179d322193dd18148c65c5">make_wformat_args</a> (Args &amp;&amp;... args) -&gt; detail::format_arg_store&lt; <a class="el" href="namespaceetl.html#a7d6b3a02733a03dc5fb0cdcd3c1f7928">wformat_context</a>, Args... &gt;</td></tr>
<tr class="separator:a2b34548f40179d322193dd18148c65c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd3b8fb66cfa5b161911b9be0d00726"><td class="memTemplParams" colspan="2">template&lt;typename OutputIt &gt; </td></tr>
<tr class="memitem:aacd3b8fb66cfa5b161911b9be0d00726"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aacd3b8fb66cfa5b161911b9be0d00726">vformat_to</a> (OutputIt out, <a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">string_view</a> fmt, <a class="el" href="namespaceetl.html#ac9fa9df1563f429e510c612727c974ee">format_args</a> args) -&gt; OutputIt</td></tr>
<tr class="separator:aacd3b8fb66cfa5b161911b9be0d00726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817e57a985d0eab0156aa074d1928761"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename... BoundArgs&gt; </td></tr>
<tr class="memitem:a817e57a985d0eab0156aa074d1928761"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a817e57a985d0eab0156aa074d1928761">bind_front</a> (Func &amp;&amp;func, BoundArgs &amp;&amp;... boundArgs)</td></tr>
<tr class="memdesc:a817e57a985d0eab0156aa074d1928761"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function template bind_front generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with its first sizeof...(Args) parameters bound to args. In other words, bind_front(f, bound_args...)(call_args...) is equivalent to invoke(f, bound_args..., call_args....).  <a href="namespaceetl.html#a817e57a985d0eab0156aa074d1928761">More...</a><br /></td></tr>
<tr class="separator:a817e57a985d0eab0156aa074d1928761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3b5926a2945bf5dfa04525b2b3a11b"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:afb3b5926a2945bf5dfa04525b2b3a11b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afb3b5926a2945bf5dfa04525b2b3a11b">function_ref</a> (R(*)(Args...)) -&gt; <a class="el" href="structetl_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt;</td></tr>
<tr class="separator:afb3b5926a2945bf5dfa04525b2b3a11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2b9f9a58bfd2eb7843bc6d4993f6e4"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a0a2b9f9a58bfd2eb7843bc6d4993f6e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0a2b9f9a58bfd2eb7843bc6d4993f6e4">swap</a> (<a class="el" href="structetl_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; void</td></tr>
<tr class="memdesc:a0a2b9f9a58bfd2eb7843bc6d4993f6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the values of lhs and rhs. Equivalent to lhs.swap(rhs).  <a href="namespaceetl.html#a0a2b9f9a58bfd2eb7843bc6d4993f6e4">More...</a><br /></td></tr>
<tr class="separator:a0a2b9f9a58bfd2eb7843bc6d4993f6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d8f8d75e5381d2407570b4d97eaf0a"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args, size_t Capacity, size_t Alignment&gt; </td></tr>
<tr class="memitem:a47d8f8d75e5381d2407570b4d97eaf0a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a47d8f8d75e5381d2407570b4d97eaf0a">swap</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; void</td></tr>
<tr class="memdesc:a47d8f8d75e5381d2407570b4d97eaf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5" title="Specializes the swap algorithm for array. Swaps the contents of lhs and rhs.">etl::swap</a> algorithm for <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs).  <a href="namespaceetl.html#a47d8f8d75e5381d2407570b4d97eaf0a">More...</a><br /></td></tr>
<tr class="separator:a47d8f8d75e5381d2407570b4d97eaf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba26643439d5c5c17e5ef7c933528775"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args, size_t Capacity, size_t Alignment&gt; </td></tr>
<tr class="memitem:aba26643439d5c5c17e5ef7c933528775"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aba26643439d5c5c17e5ef7c933528775">operator==</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; const &amp;f, <a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">nullptr_t</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:aba26643439d5c5c17e5ef7c933528775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <a href="namespaceetl.html#aba26643439d5c5c17e5ef7c933528775">More...</a><br /></td></tr>
<tr class="separator:aba26643439d5c5c17e5ef7c933528775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8c2f711706013a2f8a700a95963fd4"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args, size_t Capacity, size_t Alignment&gt; </td></tr>
<tr class="memitem:aac8c2f711706013a2f8a700a95963fd4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aac8c2f711706013a2f8a700a95963fd4">operator!=</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; const &amp;f, <a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">nullptr_t</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:aac8c2f711706013a2f8a700a95963fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <a href="namespaceetl.html#aac8c2f711706013a2f8a700a95963fd4">More...</a><br /></td></tr>
<tr class="separator:aac8c2f711706013a2f8a700a95963fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785630c163ba404876a31053f863b666"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args, size_t Capacity, size_t Alignment&gt; </td></tr>
<tr class="memitem:a785630c163ba404876a31053f863b666"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a785630c163ba404876a31053f863b666">operator==</a> (<a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">nullptr_t</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; const &amp;f) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a785630c163ba404876a31053f863b666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <a href="namespaceetl.html#a785630c163ba404876a31053f863b666">More...</a><br /></td></tr>
<tr class="separator:a785630c163ba404876a31053f863b666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ee6cdf5477e76b8281dd0e20976012"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args, size_t Capacity, size_t Alignment&gt; </td></tr>
<tr class="memitem:a71ee6cdf5477e76b8281dd0e20976012"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a71ee6cdf5477e76b8281dd0e20976012">operator!=</a> (<a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">nullptr_t</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; const &amp;f) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a71ee6cdf5477e76b8281dd0e20976012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <a href="namespaceetl.html#a71ee6cdf5477e76b8281dd0e20976012">More...</a><br /></td></tr>
<tr class="separator:a71ee6cdf5477e76b8281dd0e20976012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd726a99d25fb6e96ef3527de8a0164"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Args&gt; </td></tr>
<tr class="memitem:a0bd726a99d25fb6e96ef3527de8a0164"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0bd726a99d25fb6e96ef3527de8a0164">invoke</a> (F &amp;&amp;f, Args &amp;&amp;... args) -&gt; <a class="el" href="namespaceetl.html#a93ed3feabd9624cf09aa604f49155cc2">etl::invoke_result_t</a>&lt; F, Args... &gt;</td></tr>
<tr class="separator:a0bd726a99d25fb6e96ef3527de8a0164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098cf0c6342ba8a4438b83a411d96c11"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F , typename... Args&gt; </td></tr>
<tr class="memitem:a098cf0c6342ba8a4438b83a411d96c11"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a098cf0c6342ba8a4438b83a411d96c11">requires</a> (<a class="el" href="namespaceetl.html#af8a1ef24a3b6eb7a38ad1307015c2c09">etl::is_invocable_r_v</a>&lt; R, F, Args... &gt;) const expr auto invoke_r(F &amp;&amp;f</td></tr>
<tr class="separator:a098cf0c6342ba8a4438b83a411d96c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136cfc6ce9aad022f9c169063db9ed4a"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a136cfc6ce9aad022f9c169063db9ed4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a136cfc6ce9aad022f9c169063db9ed4a">not_fn</a> (F &amp;&amp;f) -&gt; detail::not_fn_t&lt; <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">etl::decay_t</a>&lt; F &gt;&gt;</td></tr>
<tr class="separator:a136cfc6ce9aad022f9c169063db9ed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfabb170ba259721f7f4c19febd88c5"><td class="memTemplParams" colspan="2">template&lt;auto ConstFn&gt; </td></tr>
<tr class="memitem:a3cfabb170ba259721f7f4c19febd88c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3cfabb170ba259721f7f4c19febd88c5">not_fn</a> () <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; detail::stateless_not_fn&lt; ConstFn &gt;</td></tr>
<tr class="separator:a3cfabb170ba259721f7f4c19febd88c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba1ef9fae68ae0f78265ecaa8a3d598"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeba1ef9fae68ae0f78265ecaa8a3d598"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aeba1ef9fae68ae0f78265ecaa8a3d598">reference_wrapper</a> (T &amp;) -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td></tr>
<tr class="separator:aeba1ef9fae68ae0f78265ecaa8a3d598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481b27ca7cd9de96cb435adc8a761b2a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a481b27ca7cd9de96cb435adc8a761b2a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a481b27ca7cd9de96cb435adc8a761b2a">ref</a> (T &amp;t) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a481b27ca7cd9de96cb435adc8a761b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result.  <a href="namespaceetl.html#a481b27ca7cd9de96cb435adc8a761b2a">More...</a><br /></td></tr>
<tr class="separator:a481b27ca7cd9de96cb435adc8a761b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f67da318f2742930e9485ebba9b075b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f67da318f2742930e9485ebba9b075b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1f67da318f2742930e9485ebba9b075b">ref</a> (<a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt; t) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a1f67da318f2742930e9485ebba9b075b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result.  <a href="namespaceetl.html#a1f67da318f2742930e9485ebba9b075b">More...</a><br /></td></tr>
<tr class="separator:a1f67da318f2742930e9485ebba9b075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00752f4906d9b6f07d99ee2eb2719a09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00752f4906d9b6f07d99ee2eb2719a09"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a00752f4906d9b6f07d99ee2eb2719a09">cref</a> (T const &amp;t) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T const &gt;</td></tr>
<tr class="memdesc:a00752f4906d9b6f07d99ee2eb2719a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. module Utility.  <a href="namespaceetl.html#a00752f4906d9b6f07d99ee2eb2719a09">More...</a><br /></td></tr>
<tr class="separator:a00752f4906d9b6f07d99ee2eb2719a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb738286bec1789f1f3c417e6e5e600"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfb738286bec1789f1f3c417e6e5e600"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abfb738286bec1789f1f3c417e6e5e600">cref</a> (<a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt; t) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T const &gt;</td></tr>
<tr class="separator:abfb738286bec1789f1f3c417e6e5e600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a6667d8776c1662f72e69e5b6a6ae2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82a6667d8776c1662f72e69e5b6a6ae2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a82a6667d8776c1662f72e69e5b6a6ae2">cref</a> (T const &amp;&amp;)=delete</td></tr>
<tr class="separator:a82a6667d8776c1662f72e69e5b6a6ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45065b143a47fb9249bda8d57ccca63"><td class="memTemplParams" colspan="2">template&lt;typename It , typename Distance &gt; </td></tr>
<tr class="memitem:ac45065b143a47fb9249bda8d57ccca63"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac45065b143a47fb9249bda8d57ccca63">advance</a> (It &amp;it, Distance n) -&gt; void</td></tr>
<tr class="memdesc:ac45065b143a47fb9249bda8d57ccca63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments given iterator it by n elements. If n is negative, the iterator is decremented. In this case, InputIt must meet the requirements of LegacyBidirectionalIterator, otherwise the behavior is undefined.  <a href="namespaceetl.html#ac45065b143a47fb9249bda8d57ccca63">More...</a><br /></td></tr>
<tr class="separator:ac45065b143a47fb9249bda8d57ccca63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ea18354d7bfc7358bf9c13004f0233"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ab4ea18354d7bfc7358bf9c13004f0233"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab4ea18354d7bfc7358bf9c13004f0233">back_inserter</a> (Container &amp;container) -&gt; <a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt; Container &gt;</td></tr>
<tr class="memdesc:ab4ea18354d7bfc7358bf9c13004f0233"><td class="mdescLeft">&#160;</td><td class="mdescRight">back_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">back_insert_iterator</a> for the container c with the type deduced from the type of the argument.  <a href="namespaceetl.html#ab4ea18354d7bfc7358bf9c13004f0233">More...</a><br /></td></tr>
<tr class="separator:ab4ea18354d7bfc7358bf9c13004f0233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3031e070c39546444bdd5fda57ead3d2"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a3031e070c39546444bdd5fda57ead3d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2">begin</a> (C &amp;c) -&gt; decltype(c.begin())</td></tr>
<tr class="memdesc:a3031e070c39546444bdd5fda57ead3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the given container c or array array. These templates rely on <code>C::begin()</code> having a reasonable implementation. Returns exactly c.begin(), which is typically an iterator to the beginning of the sequence represented by c. If C is a standard Container, this returns <code>C::iterator</code> when c is not const-qualified, and <code>C::const_iterator</code> otherwise. Custom overloads of begin may be provided for classes that do not expose a suitable <a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">begin()</a> member function, yet can be iterated.  <a href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2">More...</a><br /></td></tr>
<tr class="separator:a3031e070c39546444bdd5fda57ead3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a601a1d87c13d9bcf1d4b0e2cf6c1c"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a62a601a1d87c13d9bcf1d4b0e2cf6c1c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a62a601a1d87c13d9bcf1d4b0e2cf6c1c">begin</a> (C const &amp;c) -&gt; decltype(c.begin())</td></tr>
<tr class="separator:a62a601a1d87c13d9bcf1d4b0e2cf6c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0330eb79a39a00af31e79ece021f90f"><td class="memTemplParams" colspan="2">template&lt;typename T , etl::size_t N&gt; </td></tr>
<tr class="memitem:ab0330eb79a39a00af31e79ece021f90f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f">begin</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T *</td></tr>
<tr class="separator:ab0330eb79a39a00af31e79ece021f90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085b23b10e801da02c5711b10f67141e"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a085b23b10e801da02c5711b10f67141e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a085b23b10e801da02c5711b10f67141e">cbegin</a> (C const &amp;c) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2">begin</a>(c))) -&gt; decltype(<a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2">begin</a>(c))</td></tr>
<tr class="separator:a085b23b10e801da02c5711b10f67141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259846a061a975e4b40bc6f370701ac6"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a259846a061a975e4b40bc6f370701ac6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a259846a061a975e4b40bc6f370701ac6">data</a> (C &amp;c) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(c.data())) -&gt; decltype(c.data())</td></tr>
<tr class="memdesc:a259846a061a975e4b40bc6f370701ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the block of memory containing the elements of the container.  <a href="namespaceetl.html#a259846a061a975e4b40bc6f370701ac6">More...</a><br /></td></tr>
<tr class="separator:a259846a061a975e4b40bc6f370701ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76360f238bdab5ae903a7b8b987ab5ac"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a76360f238bdab5ae903a7b8b987ab5ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a76360f238bdab5ae903a7b8b987ab5ac">data</a> (C const &amp;c) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(c.data())) -&gt; decltype(c.data())</td></tr>
<tr class="separator:a76360f238bdab5ae903a7b8b987ab5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94411a453e2a44d4e6b6bf3160b4cf0"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ad94411a453e2a44d4e6b6bf3160b4cf0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad94411a453e2a44d4e6b6bf3160b4cf0">data</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T *</td></tr>
<tr class="separator:ad94411a453e2a44d4e6b6bf3160b4cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af296e322933205aa92418d74103df68c"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:af296e322933205aa92418d74103df68c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af296e322933205aa92418d74103df68c">distance</a> (It first, It <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; It &gt;::difference_type</td></tr>
<tr class="memdesc:af296e322933205aa92418d74103df68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of hops from first to last.  <a href="namespaceetl.html#af296e322933205aa92418d74103df68c">More...</a><br /></td></tr>
<tr class="separator:af296e322933205aa92418d74103df68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a91f34436b98eaaeaf7e4ae5e19afa"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ab0a91f34436b98eaaeaf7e4ae5e19afa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab0a91f34436b98eaaeaf7e4ae5e19afa">empty</a> (C const &amp;c) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(c.empty())) -&gt; decltype(c.empty())</td></tr>
<tr class="memdesc:ab0a91f34436b98eaaeaf7e4ae5e19afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given container is empty.  <a href="namespaceetl.html#ab0a91f34436b98eaaeaf7e4ae5e19afa">More...</a><br /></td></tr>
<tr class="separator:ab0a91f34436b98eaaeaf7e4ae5e19afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3868c40892e752ac869410ba4b0f0407"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a3868c40892e752ac869410ba4b0f0407"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3868c40892e752ac869410ba4b0f0407">empty</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a3868c40892e752ac869410ba4b0f0407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9eb859a31968a9179b29b638cd054b"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:abf9eb859a31968a9179b29b638cd054b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abf9eb859a31968a9179b29b638cd054b">end</a> (C &amp;c) -&gt; decltype(c.end())</td></tr>
<tr class="memdesc:abf9eb859a31968a9179b29b638cd054b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on.  <a href="namespaceetl.html#abf9eb859a31968a9179b29b638cd054b">More...</a><br /></td></tr>
<tr class="separator:abf9eb859a31968a9179b29b638cd054b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd63b79cae3d16f47089c029f77e7152"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:acd63b79cae3d16f47089c029f77e7152"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acd63b79cae3d16f47089c029f77e7152">end</a> (C const &amp;c) -&gt; decltype(c.end())</td></tr>
<tr class="separator:acd63b79cae3d16f47089c029f77e7152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5d203d41447f951c386a27ef969327"><td class="memTemplParams" colspan="2">template&lt;typename T , etl::size_t N&gt; </td></tr>
<tr class="memitem:a6f5d203d41447f951c386a27ef969327"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6f5d203d41447f951c386a27ef969327">end</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T *</td></tr>
<tr class="separator:a6f5d203d41447f951c386a27ef969327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41acb03578faec2a550c4830c1dd2071"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a41acb03578faec2a550c4830c1dd2071"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a41acb03578faec2a550c4830c1dd2071">cend</a> (C const &amp;c) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#abf9eb859a31968a9179b29b638cd054b">end</a>(c))) -&gt; decltype(<a class="el" href="namespaceetl.html#abf9eb859a31968a9179b29b638cd054b">end</a>(c))</td></tr>
<tr class="separator:a41acb03578faec2a550c4830c1dd2071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba99d783e3591913ef343af35fa0c7a"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a7ba99d783e3591913ef343af35fa0c7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7ba99d783e3591913ef343af35fa0c7a">front_inserter</a> (Container &amp;c) -&gt; <a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a>&lt; Container &gt;</td></tr>
<tr class="memdesc:a7ba99d783e3591913ef343af35fa0c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">front_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> for the container c with the type deduced from the type of the argument.  <a href="namespaceetl.html#a7ba99d783e3591913ef343af35fa0c7a">More...</a><br /></td></tr>
<tr class="separator:a7ba99d783e3591913ef343af35fa0c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad833bc2bd06b05dd97d5c1ede8dde609"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ad833bc2bd06b05dd97d5c1ede8dde609"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad833bc2bd06b05dd97d5c1ede8dde609">full</a> (C const &amp;c) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(c.full())) -&gt; decltype(c.full())</td></tr>
<tr class="memdesc:ad833bc2bd06b05dd97d5c1ede8dde609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given container is full.  <a href="namespaceetl.html#ad833bc2bd06b05dd97d5c1ede8dde609">More...</a><br /></td></tr>
<tr class="separator:ad833bc2bd06b05dd97d5c1ede8dde609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd013eaad14533bf9fba4c179c07fb1"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:adfd013eaad14533bf9fba4c179c07fb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adfd013eaad14533bf9fba4c179c07fb1">full</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:adfd013eaad14533bf9fba4c179c07fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eceb5be7f1b46a92d50cb5790ef23fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5eceb5be7f1b46a92d50cb5790ef23fa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5eceb5be7f1b46a92d50cb5790ef23fa">requires</a> (not detail::has_difference_type&lt; T &gt;) and requires(T const &amp;a</td></tr>
<tr class="separator:a5eceb5be7f1b46a92d50cb5790ef23fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7891ee1f2ce336c151274551bef111d1"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:a7891ee1f2ce336c151274551bef111d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7891ee1f2ce336c151274551bef111d1">next</a> (InputIt it, typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; InputIt &gt;::difference_type n=1) -&gt; InputIt</td></tr>
<tr class="memdesc:a7891ee1f2ce336c151274551bef111d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nth successor of iterator it.  <a href="namespaceetl.html#a7891ee1f2ce336c151274551bef111d1">More...</a><br /></td></tr>
<tr class="separator:a7891ee1f2ce336c151274551bef111d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd767893eec07cc5b92348b4bb72ee8"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt &gt; </td></tr>
<tr class="memitem:a3dd767893eec07cc5b92348b4bb72ee8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3dd767893eec07cc5b92348b4bb72ee8">prev</a> (BidirIt it, typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; BidirIt &gt;::difference_type n=1) -&gt; BidirIt</td></tr>
<tr class="memdesc:a3dd767893eec07cc5b92348b4bb72ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nth predecessor of iterator it.  <a href="namespaceetl.html#a3dd767893eec07cc5b92348b4bb72ee8">More...</a><br /></td></tr>
<tr class="separator:a3dd767893eec07cc5b92348b4bb72ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31aadf1fc327da2eaac11d7e6e8617a8"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a31aadf1fc327da2eaac11d7e6e8617a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a31aadf1fc327da2eaac11d7e6e8617a8">rbegin</a> (Container &amp;c) -&gt; decltype(c.rbegin())</td></tr>
<tr class="memdesc:a31aadf1fc327da2eaac11d7e6e8617a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-beginning of the given container.  <a href="namespaceetl.html#a31aadf1fc327da2eaac11d7e6e8617a8">More...</a><br /></td></tr>
<tr class="separator:a31aadf1fc327da2eaac11d7e6e8617a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f3dc4db837147a9d8d28d3f18b40f5"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a12f3dc4db837147a9d8d28d3f18b40f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a12f3dc4db837147a9d8d28d3f18b40f5">rbegin</a> (Container const &amp;c) -&gt; decltype(c.rbegin())</td></tr>
<tr class="separator:a12f3dc4db837147a9d8d28d3f18b40f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cec4638c522ca6b45b99da908aa1b7"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a36cec4638c522ca6b45b99da908aa1b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a36cec4638c522ca6b45b99da908aa1b7">rbegin</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; T * &gt;</td></tr>
<tr class="separator:a36cec4638c522ca6b45b99da908aa1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cf5b617456b93d23184aaa8495c411"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a39cf5b617456b93d23184aaa8495c411"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a39cf5b617456b93d23184aaa8495c411">crbegin</a> (Container const &amp;c) -&gt; decltype(<a class="el" href="namespaceetl.html#a31aadf1fc327da2eaac11d7e6e8617a8">rbegin</a>(c))</td></tr>
<tr class="separator:a39cf5b617456b93d23184aaa8495c411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db12aaf2a7b1819d28995d635d91954"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a3db12aaf2a7b1819d28995d635d91954"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3db12aaf2a7b1819d28995d635d91954">rend</a> (Container &amp;c) -&gt; decltype(c.rend())</td></tr>
<tr class="memdesc:a3db12aaf2a7b1819d28995d635d91954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-end of the given container.  <a href="namespaceetl.html#a3db12aaf2a7b1819d28995d635d91954">More...</a><br /></td></tr>
<tr class="separator:a3db12aaf2a7b1819d28995d635d91954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75830ae03ce26ca2ea7289cc7d83a761"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a75830ae03ce26ca2ea7289cc7d83a761"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a75830ae03ce26ca2ea7289cc7d83a761">rend</a> (Container const &amp;c) -&gt; decltype(c.rend())</td></tr>
<tr class="separator:a75830ae03ce26ca2ea7289cc7d83a761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d4f59f901468f3a8d07e91a27e2ae2"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a94d4f59f901468f3a8d07e91a27e2ae2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a94d4f59f901468f3a8d07e91a27e2ae2">rend</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; T * &gt;</td></tr>
<tr class="separator:a94d4f59f901468f3a8d07e91a27e2ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04738c0a8b5aa6e0211bbd7a4aa586e7"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a04738c0a8b5aa6e0211bbd7a4aa586e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a04738c0a8b5aa6e0211bbd7a4aa586e7">crend</a> (Container const &amp;c) -&gt; decltype(<a class="el" href="namespaceetl.html#a3db12aaf2a7b1819d28995d635d91954">rend</a>(c))</td></tr>
<tr class="memdesc:a04738c0a8b5aa6e0211bbd7a4aa586e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-end of the given container.  <a href="namespaceetl.html#a04738c0a8b5aa6e0211bbd7a4aa586e7">More...</a><br /></td></tr>
<tr class="separator:a04738c0a8b5aa6e0211bbd7a4aa586e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fd86ba568b1c1665502fcb72ed4327"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a56fd86ba568b1c1665502fcb72ed4327"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a56fd86ba568b1c1665502fcb72ed4327">make_reverse_iterator</a> (Iter i) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter &gt;</td></tr>
<tr class="memdesc:a56fd86ba568b1c1665502fcb72ed4327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function template that constructs a <a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">etl::reverse_iterator</a> for the given iterator i (which must be a LegacyBidirectionalIterator) with the type deduced from the type of the argument.  <a href="namespaceetl.html#a56fd86ba568b1c1665502fcb72ed4327">More...</a><br /></td></tr>
<tr class="separator:a56fd86ba568b1c1665502fcb72ed4327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed8eb1bf308acc967006e8073f5a132"><td class="memTemplParams" colspan="2">template&lt;typename Iter1 , typename Iter2 &gt; </td></tr>
<tr class="memitem:a6ed8eb1bf308acc967006e8073f5a132"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6ed8eb1bf308acc967006e8073f5a132">operator==</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a6ed8eb1bf308acc967006e8073f5a132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <a href="namespaceetl.html#a6ed8eb1bf308acc967006e8073f5a132">More...</a><br /></td></tr>
<tr class="separator:a6ed8eb1bf308acc967006e8073f5a132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35badce959782a6ae934df29db1e063"><td class="memTemplParams" colspan="2">template&lt;typename Iter1 , typename Iter2 &gt; </td></tr>
<tr class="memitem:ab35badce959782a6ae934df29db1e063"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab35badce959782a6ae934df29db1e063">operator!=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ab35badce959782a6ae934df29db1e063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <a href="namespaceetl.html#ab35badce959782a6ae934df29db1e063">More...</a><br /></td></tr>
<tr class="separator:ab35badce959782a6ae934df29db1e063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354acf1f357eacd402309c32fd4d5508"><td class="memTemplParams" colspan="2">template&lt;typename Iter1 , typename Iter2 &gt; </td></tr>
<tr class="memitem:a354acf1f357eacd402309c32fd4d5508"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a354acf1f357eacd402309c32fd4d5508">operator&lt;</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a354acf1f357eacd402309c32fd4d5508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <a href="namespaceetl.html#a354acf1f357eacd402309c32fd4d5508">More...</a><br /></td></tr>
<tr class="separator:a354acf1f357eacd402309c32fd4d5508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c13e3aeec42ad159690a49c03ea7f19"><td class="memTemplParams" colspan="2">template&lt;typename Iter1 , typename Iter2 &gt; </td></tr>
<tr class="memitem:a6c13e3aeec42ad159690a49c03ea7f19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6c13e3aeec42ad159690a49c03ea7f19">operator&lt;=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a6c13e3aeec42ad159690a49c03ea7f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <a href="namespaceetl.html#a6c13e3aeec42ad159690a49c03ea7f19">More...</a><br /></td></tr>
<tr class="separator:a6c13e3aeec42ad159690a49c03ea7f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ba00e40d7921ce12fde9c0c231e4c2"><td class="memTemplParams" colspan="2">template&lt;typename Iter1 , typename Iter2 &gt; </td></tr>
<tr class="memitem:ac1ba00e40d7921ce12fde9c0c231e4c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac1ba00e40d7921ce12fde9c0c231e4c2">operator&gt;</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ac1ba00e40d7921ce12fde9c0c231e4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <a href="namespaceetl.html#ac1ba00e40d7921ce12fde9c0c231e4c2">More...</a><br /></td></tr>
<tr class="separator:ac1ba00e40d7921ce12fde9c0c231e4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2457527f749e948ff13abbd95621c9"><td class="memTemplParams" colspan="2">template&lt;typename Iter1 , typename Iter2 &gt; </td></tr>
<tr class="memitem:a9a2457527f749e948ff13abbd95621c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9a2457527f749e948ff13abbd95621c9">operator&gt;=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a9a2457527f749e948ff13abbd95621c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <a href="namespaceetl.html#a9a2457527f749e948ff13abbd95621c9">More...</a><br /></td></tr>
<tr class="separator:a9a2457527f749e948ff13abbd95621c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341ce51287200d6d284558bf674303a1"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a341ce51287200d6d284558bf674303a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a341ce51287200d6d284558bf674303a1">operator+</a> (typename <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iter &gt;::difference_type n, <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iter &gt; const &amp;it) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(it.base() - n)) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iter &gt;</td></tr>
<tr class="memdesc:a341ce51287200d6d284558bf674303a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator it incremented by n.  <a href="namespaceetl.html#a341ce51287200d6d284558bf674303a1">More...</a><br /></td></tr>
<tr class="separator:a341ce51287200d6d284558bf674303a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07adb06319a1e865f85ac0caed0820a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator1 , typename Iterator2 &gt; </td></tr>
<tr class="memitem:ae07adb06319a1e865f85ac0caed0820a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae07adb06319a1e865f85ac0caed0820a">operator-</a> (<a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator1 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator2 &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(rhs.base() - lhs.base())) -&gt; decltype(rhs.base() - lhs.base())</td></tr>
<tr class="memdesc:ae07adb06319a1e865f85ac0caed0820a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between two iterator adaptors.  <a href="namespaceetl.html#ae07adb06319a1e865f85ac0caed0820a">More...</a><br /></td></tr>
<tr class="separator:ae07adb06319a1e865f85ac0caed0820a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3008e042f920b06e2a67b1aa31a1803"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:af3008e042f920b06e2a67b1aa31a1803"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af3008e042f920b06e2a67b1aa31a1803">size</a> (C const &amp;c) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(c.size())) -&gt; decltype(c.size())</td></tr>
<tr class="memdesc:af3008e042f920b06e2a67b1aa31a1803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the given container c or array array. Returns c.size(), converted to the return type if necessary.  <a href="namespaceetl.html#af3008e042f920b06e2a67b1aa31a1803">More...</a><br /></td></tr>
<tr class="separator:af3008e042f920b06e2a67b1aa31a1803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e3325c99005cfa2cad0752fe472c61"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ab2e3325c99005cfa2cad0752fe472c61"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab2e3325c99005cfa2cad0752fe472c61">size</a> (T const (&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a></td></tr>
<tr class="separator:ab2e3325c99005cfa2cad0752fe472c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bf10a91479176562a6e66eda74a85f"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a81bf10a91479176562a6e66eda74a85f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a81bf10a91479176562a6e66eda74a85f">ssize</a> (C const &amp;c) -&gt; <a class="el" href="namespaceetl.html#aa474dd82a788a57735f0603b85954c37">common_type_t</a>&lt; <a class="el" href="namespaceetl.html#a955e0d5a5e84e9e394bf38a95c8ce380">ptrdiff_t</a>, <a class="el" href="namespaceetl.html#abffe34c79351f871acb3e0438b2ad488">make_signed_t</a>&lt; decltype(c.size())&gt;&gt;</td></tr>
<tr class="separator:a81bf10a91479176562a6e66eda74a85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfe3fbc79d8c1cf42b007bed4267257"><td class="memTemplParams" colspan="2">template&lt;typename T , ptrdiff_t N&gt; </td></tr>
<tr class="memitem:abdfe3fbc79d8c1cf42b007bed4267257"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abdfe3fbc79d8c1cf42b007bed4267257">ssize</a> (T const (&amp;<a class="el" href="structetl_1_1array.html">array</a>)[static_cast&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> &gt;(N)]) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a955e0d5a5e84e9e394bf38a95c8ce380">ptrdiff_t</a></td></tr>
<tr class="separator:abdfe3fbc79d8c1cf42b007bed4267257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f4f3470cc94fc51e21ebfa58e3292a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a29f4f3470cc94fc51e21ebfa58e3292a">abs</a> (int n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; int</td></tr>
<tr class="memdesc:a29f4f3470cc94fc51e21ebfa58e3292a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <a href="namespaceetl.html#a29f4f3470cc94fc51e21ebfa58e3292a">More...</a><br /></td></tr>
<tr class="separator:a29f4f3470cc94fc51e21ebfa58e3292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67112d360fce8458db9b33c097b809b5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a67112d360fce8458db9b33c097b809b5">abs</a> (long n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long</td></tr>
<tr class="separator:a67112d360fce8458db9b33c097b809b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f2cb4cae4a97ae3b4736ff1aa6b176"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a28f2cb4cae4a97ae3b4736ff1aa6b176">abs</a> (long long n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long long</td></tr>
<tr class="separator:a28f2cb4cae4a97ae3b4736ff1aa6b176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528fb6eadbb2c38e178a60155197d6ac"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a528fb6eadbb2c38e178a60155197d6ac">abs</a> (float n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="separator:a528fb6eadbb2c38e178a60155197d6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5868e5a9aa938b596cd0d8d04d3ecb96"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5868e5a9aa938b596cd0d8d04d3ecb96">abs</a> (double n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="separator:a5868e5a9aa938b596cd0d8d04d3ecb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1dae41b3151e867f898e88be2e250b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1b1dae41b3151e867f898e88be2e250b">abs</a> (long double n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="separator:a1b1dae41b3151e867f898e88be2e250b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f57c390bca894ba9abb01107b367fb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa3f57c390bca894ba9abb01107b367fb">fabs</a> (float n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="separator:aa3f57c390bca894ba9abb01107b367fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934ff8b65786c53d2df66654258fb9d4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a934ff8b65786c53d2df66654258fb9d4">fabsf</a> (float n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; float</td></tr>
<tr class="separator:a934ff8b65786c53d2df66654258fb9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc8c16e1d3253b423b905f31cf7267b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aebc8c16e1d3253b423b905f31cf7267b">fabs</a> (double n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; double</td></tr>
<tr class="separator:aebc8c16e1d3253b423b905f31cf7267b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab973f9ba5bac126e950c7ff7e1b45dcb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab973f9ba5bac126e950c7ff7e1b45dcb">fabs</a> (long double n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="separator:ab973f9ba5bac126e950c7ff7e1b45dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57fa73cac5bc77be92e61c2cea2fa4b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af57fa73cac5bc77be92e61c2cea2fa4b">fabsl</a> (long double n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; long double</td></tr>
<tr class="separator:af57fa73cac5bc77be92e61c2cea2fa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d6a400b03bbbcc87b81f9a8f70a4e5"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a68d6a400b03bbbcc87b81f9a8f70a4e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a68d6a400b03bbbcc87b81f9a8f70a4e5">ilog2</a> (<a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> x) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a></td></tr>
<tr class="separator:a68d6a400b03bbbcc87b81f9a8f70a4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbcb6eba04cb025fe9ca378236adee0"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a4cbcb6eba04cb025fe9ca378236adee0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4cbcb6eba04cb025fe9ca378236adee0">ipow</a> (<a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>, <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> exponent) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a></td></tr>
<tr class="separator:a4cbcb6eba04cb025fe9ca378236adee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dd0445f4a32857d03ee0b802a2af19"><td class="memTemplParams" colspan="2">template&lt;auto Base&gt; </td></tr>
<tr class="memitem:a80dd0445f4a32857d03ee0b802a2af19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a80dd0445f4a32857d03ee0b802a2af19">ipow</a> (decltype(Base) exponent) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; decltype(Base)</td></tr>
<tr class="separator:a80dd0445f4a32857d03ee0b802a2af19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f47998ffec36802839b7fed6d45cfa"><td class="memTemplParams" colspan="2">template&lt;typename... Integrals&gt; </td></tr>
<tr class="memitem:a07f47998ffec36802839b7fed6d45cfa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a07f47998ffec36802839b7fed6d45cfa">requires</a> (<a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">etl::is_convertible_v</a>&lt; Integrals, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> &gt; and ...) <a class="el" href="structetl_1_1extents.html">extents</a>(Integrals...) -&gt; <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>((Integrals(), <a class="el" href="namespaceetl.html#ae174223df490e6263d4648a86326c902">etl::dynamic_extent</a>))... &gt;</td></tr>
<tr class="separator:a07f47998ffec36802839b7fed6d45cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c58fbe86b83c9dcf5d5f8b2782586c5"><td class="memTemplParams" colspan="2">template&lt;typename CArray &gt; </td></tr>
<tr class="memitem:a7c58fbe86b83c9dcf5d5f8b2782586c5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7c58fbe86b83c9dcf5d5f8b2782586c5">requires</a> (<a class="el" href="namespaceetl.html#afaa46050181985a6156a6c800c86a7d8">is_array_v</a>&lt; CArray &gt; &amp;&amp;<a class="el" href="namespaceetl.html#a4229d4171b460abc833736d622ce9745">rank_v</a>&lt; CArray &gt;==1) <a class="el" href="structetl_1_1mdspan.html">mdspan</a>(CArray &amp;) -&gt; <a class="el" href="structetl_1_1mdspan.html">mdspan</a>&lt; <a class="el" href="namespaceetl.html#a96e53fc126f7c9ebf9901856b9c2db22">remove_all_extents_t</a>&lt; CArray &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>, <a class="el" href="namespaceetl.html#a115f1cea7fc27ee979afae4871d03a03">extent_v</a>&lt; CArray, 0 &gt;&gt;&gt;</td></tr>
<tr class="separator:a7c58fbe86b83c9dcf5d5f8b2782586c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af302385ee3f32bd28048db514b905a0c"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:af302385ee3f32bd28048db514b905a0c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af302385ee3f32bd28048db514b905a0c">requires</a> (<a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a>&lt; <a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt; Pointer &gt;&gt;) <a class="el" href="structetl_1_1mdspan.html">mdspan</a>(Pointer &amp;&amp;) -&gt; <a class="el" href="structetl_1_1mdspan.html">mdspan</a>&lt; <a class="el" href="namespaceetl.html#a5e186a746241ab4cfcf810655e8f7844">remove_pointer_t</a>&lt; <a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt; Pointer &gt;&gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> &gt;&gt;</td></tr>
<tr class="separator:af302385ee3f32bd28048db514b905a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efcf240a782c1116a4eb4782739d7f9"><td class="memTemplParams" colspan="2">template&lt;typename ElementType , typename... Integrals&gt; </td></tr>
<tr class="memitem:a8efcf240a782c1116a4eb4782739d7f9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8efcf240a782c1116a4eb4782739d7f9">requires</a> ((<a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">is_convertible_v</a>&lt; Integrals, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> &gt; &amp;&amp;...) &amp;&amp;sizeof...(Integrals) &gt; 0) explicit <a class="el" href="structetl_1_1mdspan.html">mdspan</a>(ElementType *</td></tr>
<tr class="separator:a8efcf240a782c1116a4eb4782739d7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dd62784f99a4dc21c558bb26790faf"><td class="memTemplParams" colspan="2">template&lt;typename ElementType , typename IndexType , size_t... ExtentsPack&gt; </td></tr>
<tr class="memitem:a03dd62784f99a4dc21c558bb26790faf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a03dd62784f99a4dc21c558bb26790faf">mdspan</a> (ElementType *, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; IndexType, ExtentsPack... &gt; const &amp;) -&gt; <a class="el" href="structetl_1_1mdspan.html">mdspan</a>&lt; ElementType, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; IndexType, ExtentsPack... &gt;&gt;</td></tr>
<tr class="separator:a03dd62784f99a4dc21c558bb26790faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca494e42ded1eb56cf815c645ab4bfe"><td class="memTemplParams" colspan="2">template&lt;typename ElementType , typename MappingType &gt; </td></tr>
<tr class="memitem:a7ca494e42ded1eb56cf815c645ab4bfe"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7ca494e42ded1eb56cf815c645ab4bfe">mdspan</a> (ElementType *, MappingType const &amp;) -&gt; <a class="el" href="structetl_1_1mdspan.html">mdspan</a>&lt; ElementType, typename MappingType::extents_type, typename MappingType::layout_type &gt;</td></tr>
<tr class="separator:a7ca494e42ded1eb56cf815c645ab4bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536af133718ba537fce35662e803b0e7"><td class="memTemplParams" colspan="2">template&lt;typename MappingType , typename AccessorType &gt; </td></tr>
<tr class="memitem:a536af133718ba537fce35662e803b0e7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a536af133718ba537fce35662e803b0e7">mdspan</a> (typename AccessorType::data_handle_type const &amp;, MappingType const &amp;, AccessorType const &amp;) -&gt; <a class="el" href="structetl_1_1mdspan.html">mdspan</a>&lt; typename AccessorType::element_type, typename MappingType::extents_type, typename MappingType::layout_type, AccessorType &gt;</td></tr>
<tr class="separator:a536af133718ba537fce35662e803b0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94f2f8d645ecda437b8b417399a808a"><td class="memTemplParams" colspan="2">template&lt;typename OffsetType , typename ExtentType , typename StrideType &gt; </td></tr>
<tr class="memitem:aa94f2f8d645ecda437b8b417399a808a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa94f2f8d645ecda437b8b417399a808a">strided_slice</a> (OffsetType, ExtentType, StrideType) -&gt; <a class="el" href="structetl_1_1strided__slice.html">strided_slice</a>&lt; OffsetType, ExtentType, StrideType &gt;</td></tr>
<tr class="separator:aa94f2f8d645ecda437b8b417399a808a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c233c3cfa75e4228eaaa7664506dbc7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c233c3cfa75e4228eaaa7664506dbc7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7c233c3cfa75e4228eaaa7664506dbc7">requires</a> (<a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">is_object_v</a>&lt; T &gt;) const expr auto <a class="el" href="namespaceetl.html#a13856fe74510e89b04a2310cbc9bde59">addressof</a>(T &amp;<a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T *</td></tr>
<tr class="memdesc:a7c233c3cfa75e4228eaaa7664506dbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;.  <a href="namespaceetl.html#a7c233c3cfa75e4228eaaa7664506dbc7">More...</a><br /></td></tr>
<tr class="separator:a7c233c3cfa75e4228eaaa7664506dbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3edffa6af6cd6422babaa5014a3edfe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3edffa6af6cd6422babaa5014a3edfe"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab3edffa6af6cd6422babaa5014a3edfe">requires</a> (not <a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">is_object_v</a>&lt; T &gt;) const expr auto <a class="el" href="namespaceetl.html#a13856fe74510e89b04a2310cbc9bde59">addressof</a>(T &amp;<a class="el" href="namespaceetl.html#a06165982b4ed16fe2e57476b46f4ad08">arg</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T *</td></tr>
<tr class="separator:ab3edffa6af6cd6422babaa5014a3edfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13856fe74510e89b04a2310cbc9bde59"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a13856fe74510e89b04a2310cbc9bde59"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a13856fe74510e89b04a2310cbc9bde59">addressof</a> (T const &amp;&amp;)=delete</td></tr>
<tr class="separator:a13856fe74510e89b04a2310cbc9bde59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3d4ba5bde672b48bdaa4fd9eec249e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afb3d4ba5bde672b48bdaa4fd9eec249e">align</a> (<a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> alignment, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> <a class="el" href="namespaceetl.html#a0db1ad433c808f8aabe48a2061e633dc">size</a>, void *&amp;ptr, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> &amp;space) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; void *</td></tr>
<tr class="memdesc:afb3d4ba5bde672b48bdaa4fd9eec249e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned.  <a href="namespaceetl.html#afb3d4ba5bde672b48bdaa4fd9eec249e">More...</a><br /></td></tr>
<tr class="separator:afb3d4ba5bde672b48bdaa4fd9eec249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe56da868069c04217458df6422d084"><td class="memTemplParams" colspan="2">template&lt;etl::size_t N, typename T &gt; </td></tr>
<tr class="memitem:abfe56da868069c04217458df6422d084"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abfe56da868069c04217458df6422d084">assume_aligned</a> (T *ptr) -&gt; T *</td></tr>
<tr class="memdesc:abfe56da868069c04217458df6422d084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the implementation that the object ptr points to is aligned to at least N. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of assume_aligned.  <a href="namespaceetl.html#abfe56da868069c04217458df6422d084">More...</a><br /></td></tr>
<tr class="separator:abfe56da868069c04217458df6422d084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85baa0db208bd4de142559c20735f41"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args, typename  = decltype(::new(etl::declval&lt;void*&gt;()) T(etl::declval&lt;Args&gt;()...))&gt; </td></tr>
<tr class="memitem:aa85baa0db208bd4de142559c20735f41"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa85baa0db208bd4de142559c20735f41">construct_at</a> (T *p, Args &amp;&amp;... args) -&gt; T *</td></tr>
<tr class="memdesc:aa85baa0db208bd4de142559c20735f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a T object initialized with arguments args... at given address p.  <a href="namespaceetl.html#aa85baa0db208bd4de142559c20735f41">More...</a><br /></td></tr>
<tr class="separator:aa85baa0db208bd4de142559c20735f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44bc4884adc1e9dc20ddf2363f3da66"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:ab44bc4884adc1e9dc20ddf2363f3da66"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab44bc4884adc1e9dc20ddf2363f3da66">destroy</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; void</td></tr>
<tr class="memdesc:ab44bc4884adc1e9dc20ddf2363f3da66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the objects in the range [first, last).  <a href="namespaceetl.html#ab44bc4884adc1e9dc20ddf2363f3da66">More...</a><br /></td></tr>
<tr class="separator:ab44bc4884adc1e9dc20ddf2363f3da66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1709580f4bcc18d6efb2b7e4d5c1b728">destroy_at</a> (T *p) -&gt; void</td></tr>
<tr class="memdesc:a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not an array type, calls the destructor of the object pointed to by p, as if by p-&gt;~T(). If T is an array type, recursively destroys elements of *p in order, as if by calling destroy(begin(*p), end(*p)).  <a href="namespaceetl.html#a1709580f4bcc18d6efb2b7e4d5c1b728">More...</a><br /></td></tr>
<tr class="separator:a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440d38af8f9b00df3d5c1369450ba44a"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Size &gt; </td></tr>
<tr class="memitem:a440d38af8f9b00df3d5c1369450ba44a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a440d38af8f9b00df3d5c1369450ba44a">destroy_n</a> (ForwardIt first, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> n) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a440d38af8f9b00df3d5c1369450ba44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the n objects in the range starting at first.  <a href="namespaceetl.html#a440d38af8f9b00df3d5c1369450ba44a">More...</a><br /></td></tr>
<tr class="separator:a440d38af8f9b00df3d5c1369450ba44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa686fb94d6fbf9538a40cf4040a6ac81"><td class="memTemplParams" colspan="2">template&lt;typename Ptr &gt; </td></tr>
<tr class="memitem:aa686fb94d6fbf9538a40cf4040a6ac81"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa686fb94d6fbf9538a40cf4040a6ac81">to_address</a> (Ptr const &amp;ptr) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a></td></tr>
<tr class="memdesc:aa686fb94d6fbf9538a40cf4040a6ac81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the address represented by p without forming a reference to the object pointed to by p.  <a href="namespaceetl.html#aa686fb94d6fbf9538a40cf4040a6ac81">More...</a><br /></td></tr>
<tr class="separator:aa686fb94d6fbf9538a40cf4040a6ac81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9c482d4902a3f7e3af12f0e66963ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f9c482d4902a3f7e3af12f0e66963ed"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5f9c482d4902a3f7e3af12f0e66963ed">requires</a> (not <a class="el" href="namespaceetl.html#aec3b44fa05f956c1efc4f34af98bd1f0">is_function_v</a>&lt; T &gt;) const expr auto <a class="el" href="namespaceetl.html#aa686fb94d6fbf9538a40cf4040a6ac81">to_address</a>(T *ptr) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T *</td></tr>
<tr class="memdesc:a5f9c482d4902a3f7e3af12f0e66963ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the address represented by p without forming a reference to the object pointed to by p.  <a href="namespaceetl.html#a5f9c482d4902a3f7e3af12f0e66963ed">More...</a><br /></td></tr>
<tr class="separator:a5f9c482d4902a3f7e3af12f0e66963ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9b77066dce89b6c75251e5179805f6"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:aac9b77066dce89b6c75251e5179805f6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aac9b77066dce89b6c75251e5179805f6">uninitialized_fill</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; void</td></tr>
<tr class="separator:aac9b77066dce89b6c75251e5179805f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b0627d3000daa570306e2c95d25db1"><td class="memTemplParams" colspan="2">template&lt;typename Mutex &gt; </td></tr>
<tr class="memitem:a66b0627d3000daa570306e2c95d25db1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a66b0627d3000daa570306e2c95d25db1">swap</a> (<a class="el" href="structetl_1_1unique__lock.html">unique_lock</a>&lt; Mutex &gt; &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1unique__lock.html">unique_lock</a>&lt; Mutex &gt; &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(lhs.swap(rhs)))</td></tr>
<tr class="memdesc:a66b0627d3000daa570306e2c95d25db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">unique_lock</a>. Exchanges the state of lhs with that of rhs.  <a href="namespaceetl.html#a66b0627d3000daa570306e2c95d25db1">More...</a><br /></td></tr>
<tr class="separator:a66b0627d3000daa570306e2c95d25db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a594a7b7fb202c9a1b6d82115e7a172e3">abs</a> (Type input) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Type</td></tr>
<tr class="memdesc:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value.  <a href="namespaceetl.html#a594a7b7fb202c9a1b6d82115e7a172e3">More...</a><br /></td></tr>
<tr class="separator:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe443a26a34b79fc921c4583df576333"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Type &gt; </td></tr>
<tr class="memitem:afe443a26a34b79fc921c4583df576333"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afe443a26a34b79fc921c4583df576333">accumulate</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Type init) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Type</td></tr>
<tr class="memdesc:afe443a26a34b79fc921c4583df576333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the given value init and the elements in the range <code>[first, last)</code>. <a href="https://en.cppreference.com/w/cpp/algorithm/accumulate">https://en.cppreference.com/w/cpp/algorithm/accumulate</a>.  <a href="namespaceetl.html#afe443a26a34b79fc921c4583df576333">More...</a><br /></td></tr>
<tr class="separator:afe443a26a34b79fc921c4583df576333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9413959b7ee39d393e7c35ad2cd78294"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Type , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a9413959b7ee39d393e7c35ad2cd78294"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9413959b7ee39d393e7c35ad2cd78294">accumulate</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Type init, BinaryOperation op) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Type</td></tr>
<tr class="separator:a9413959b7ee39d393e7c35ad2cd78294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8090c84a226cdc13d3b2a1420e1d8e4f"><td class="memTemplParams" colspan="2">template&lt;etl::standard_integer Int&gt; </td></tr>
<tr class="memitem:a8090c84a226cdc13d3b2a1420e1d8e4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8090c84a226cdc13d3b2a1420e1d8e4f">add_sat</a> (<a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> x, <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> y) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a></td></tr>
<tr class="separator:a8090c84a226cdc13d3b2a1420e1d8e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdf06dcb6cdb229ddf2f001f7063d82"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a4cdf06dcb6cdb229ddf2f001f7063d82"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4cdf06dcb6cdb229ddf2f001f7063d82">adjacent_difference</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination, BinaryOperation op) -&gt; OutputIt</td></tr>
<tr class="memdesc:a4cdf06dcb6cdb229ddf2f001f7063d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between the second and the first of each adjacent pair of elements of the range [first, last) and writes them to the range beginning at destination + 1. An unmodified copy of *first is written to *destination.  <a href="namespaceetl.html#a4cdf06dcb6cdb229ddf2f001f7063d82">More...</a><br /></td></tr>
<tr class="separator:a4cdf06dcb6cdb229ddf2f001f7063d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233e4dea3a5bcb4fa4018e9110735184"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:a233e4dea3a5bcb4fa4018e9110735184"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a233e4dea3a5bcb4fa4018e9110735184">adjacent_difference</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="separator:a233e4dea3a5bcb4fa4018e9110735184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65cd6f8748c172eab6ee36130dca3c3"><td class="memTemplParams" colspan="2">template&lt;typename M , typename N &gt; </td></tr>
<tr class="memitem:ab65cd6f8748c172eab6ee36130dca3c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab65cd6f8748c172eab6ee36130dca3c3">gcd</a> (M m, N n) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#aa474dd82a788a57735f0603b85954c37">etl::common_type_t</a>&lt; M, N &gt;</td></tr>
<tr class="memdesc:ab65cd6f8748c172eab6ee36130dca3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of the integers m and n.  <a href="namespaceetl.html#ab65cd6f8748c172eab6ee36130dca3c3">More...</a><br /></td></tr>
<tr class="separator:ab65cd6f8748c172eab6ee36130dca3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b02b91109bd6987f6dd8c0cfe583d5"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename T &gt; </td></tr>
<tr class="memitem:a42b02b91109bd6987f6dd8c0cfe583d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a42b02b91109bd6987f6dd8c0cfe583d5">inner_product</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, T init) -&gt; T</td></tr>
<tr class="memdesc:a42b02b91109bd6987f6dd8c0cfe583d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes inner product (i.e. sum of products) or performs ordered map/reduce operation on the range [first1, last1) and the range beginning at first2.  <a href="namespaceetl.html#a42b02b91109bd6987f6dd8c0cfe583d5">More...</a><br /></td></tr>
<tr class="separator:a42b02b91109bd6987f6dd8c0cfe583d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0039bdc9a6970a2089121ae3ee285b1"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename T , typename BinaryOperation1 , typename BinaryOperation2 &gt; </td></tr>
<tr class="memitem:ae0039bdc9a6970a2089121ae3ee285b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae0039bdc9a6970a2089121ae3ee285b1">inner_product</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, T init, BinaryOperation1 op1, BinaryOperation2 op2) -&gt; T</td></tr>
<tr class="separator:ae0039bdc9a6970a2089121ae3ee285b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44562b8c2da2eb5f51eb8e98d09ea697"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:a44562b8c2da2eb5f51eb8e98d09ea697"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a44562b8c2da2eb5f51eb8e98d09ea697">iota</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T <a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; void</td></tr>
<tr class="memdesc:a44562b8c2da2eb5f51eb8e98d09ea697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the range [first, last) with sequentially increasing values, starting with value and repetitively evaluating ++value.  <a href="namespaceetl.html#a44562b8c2da2eb5f51eb8e98d09ea697">More...</a><br /></td></tr>
<tr class="separator:a44562b8c2da2eb5f51eb8e98d09ea697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7559b6c18305a231bf5af00443a906"><td class="memTemplParams" colspan="2">template&lt;typename M , typename N &gt; </td></tr>
<tr class="memitem:aef7559b6c18305a231bf5af00443a906"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aef7559b6c18305a231bf5af00443a906">requires</a> (<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; M &gt; and not <a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">is_same_v</a>&lt; M, bool &gt; and <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; N &gt; and not <a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">is_same_v</a>&lt; N, bool &gt;) const expr auto <a class="el" href="__3rd__party_2gcem_2gcem__incl_2lcm_8hpp.html#a9be5068bc30f716f906a455a4151bdf8">lcm</a>(M m</td></tr>
<tr class="memdesc:aef7559b6c18305a231bf5af00443a906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common multiple of the integers m and n.  <a href="namespaceetl.html#aef7559b6c18305a231bf5af00443a906">More...</a><br /></td></tr>
<tr class="separator:aef7559b6c18305a231bf5af00443a906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78c67d300e374415b47132bd5343d85"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:ad78c67d300e374415b47132bd5343d85"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad78c67d300e374415b47132bd5343d85">requires</a> (<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> &gt; and not <a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>, bool &gt;) const expr auto <a class="el" href="namespaceetl.html#a9de23ef1f08847d45765eaaab59f46d5">midpoint</a>(<a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> a</td></tr>
<tr class="memdesc:ad78c67d300e374415b47132bd5343d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns half the sum of a + b. If the sum is odd, the result is rounded towards a.  <a href="namespaceetl.html#ad78c67d300e374415b47132bd5343d85">More...</a><br /></td></tr>
<tr class="separator:ad78c67d300e374415b47132bd5343d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a32ee33ef899f2d5ae610d855574a4"><td class="memItemLeft" align="right" valign="top">return a&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a41a32ee33ef899f2d5ae610d855574a4">static_cast&lt; Int &gt;</a> (<a class="el" href="structetl_1_1half.html">half</a>)</td></tr>
<tr class="separator:a41a32ee33ef899f2d5ae610d855574a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de23ef1f08847d45765eaaab59f46d5"><td class="memTemplParams" colspan="2">template&lt;etl::floating_point Float&gt; </td></tr>
<tr class="memitem:a9de23ef1f08847d45765eaaab59f46d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9de23ef1f08847d45765eaaab59f46d5">midpoint</a> (Float a, Float <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Float</td></tr>
<tr class="separator:a9de23ef1f08847d45765eaaab59f46d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f46f4ff5229e07caab2a4bfbb7562a0"><td class="memTemplParams" colspan="2">template&lt;typename Ptr &gt; </td></tr>
<tr class="memitem:a4f46f4ff5229e07caab2a4bfbb7562a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr <a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">etl::is_pointer_v</a>&lt; Ptr &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4f46f4ff5229e07caab2a4bfbb7562a0">midpoint</a> (Ptr a, Ptr <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Ptr</td></tr>
<tr class="memdesc:a4f46f4ff5229e07caab2a4bfbb7562a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">\synopsis_return Ptr  <a href="namespaceetl.html#a4f46f4ff5229e07caab2a4bfbb7562a0">More...</a><br /></td></tr>
<tr class="separator:a4f46f4ff5229e07caab2a4bfbb7562a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717726a2fed08cececaa93b504419300"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a717726a2fed08cececaa93b504419300"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a717726a2fed08cececaa93b504419300">partial_sum</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination, BinaryOperation op) -&gt; OutputIt</td></tr>
<tr class="memdesc:a717726a2fed08cececaa93b504419300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial sums of the elements in the subranges of the range [first, last) and writes them to the range beginning at destination. This version uses the given binary function op, both applying <a class="el" href="namespaceetl.html#a1b8df3814fc65f04932c2f0d09a56107" title="Moves the elements in the range [first, last), to another range beginning at destination,...">etl::move</a> to their operands on the left hand side.  <a href="namespaceetl.html#a717726a2fed08cececaa93b504419300">More...</a><br /></td></tr>
<tr class="separator:a717726a2fed08cececaa93b504419300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d274a25ea5a88eb47898c8832795e3e"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:a8d274a25ea5a88eb47898c8832795e3e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8d274a25ea5a88eb47898c8832795e3e">partial_sum</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="separator:a8d274a25ea5a88eb47898c8832795e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c6438ff40771d562eba2df365db32b"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T , typename BinaryOp &gt; </td></tr>
<tr class="memitem:a84c6438ff40771d562eba2df365db32b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a84c6438ff40771d562eba2df365db32b">reduce</a> (InputIter first, InputIter <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T init, BinaryOp op) -&gt; T</td></tr>
<tr class="memdesc:a84c6438ff40771d562eba2df365db32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="namespaceetl.html#afe443a26a34b79fc921c4583df576333" title="Computes the sum of the given value init and the elements in the range [first, last)....">etl::accumulate</a>. <a href="https://en.cppreference.com/w/cpp/algorithm/reduce">https://en.cppreference.com/w/cpp/algorithm/reduce</a>.  <a href="namespaceetl.html#a84c6438ff40771d562eba2df365db32b">More...</a><br /></td></tr>
<tr class="separator:a84c6438ff40771d562eba2df365db32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19beb246e0b495f1af0e0dda7ba07ce"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T &gt; </td></tr>
<tr class="memitem:af19beb246e0b495f1af0e0dda7ba07ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af19beb246e0b495f1af0e0dda7ba07ce">reduce</a> (InputIter first, InputIter <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T init) -&gt; T</td></tr>
<tr class="separator:af19beb246e0b495f1af0e0dda7ba07ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714efac01ef228fff45d4f6ab456dfb6"><td class="memTemplParams" colspan="2">template&lt;typename InputIter &gt; </td></tr>
<tr class="memitem:a714efac01ef228fff45d4f6ab456dfb6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a714efac01ef228fff45d4f6ab456dfb6">reduce</a> (InputIter first, InputIter <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; InputIter &gt;::value_type</td></tr>
<tr class="separator:a714efac01ef228fff45d4f6ab456dfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b53df67d4efc55fb568a2445a29931"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25b53df67d4efc55fb568a2445a29931"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a25b53df67d4efc55fb568a2445a29931">make_optional</a> (T &amp;&amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt; <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">etl::decay_t</a>&lt; T &gt;&gt;</td></tr>
<tr class="memdesc:a25b53df67d4efc55fb568a2445a29931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object from value.  <a href="namespaceetl.html#a25b53df67d4efc55fb568a2445a29931">More...</a><br /></td></tr>
<tr class="separator:a25b53df67d4efc55fb568a2445a29931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596e87d0c3bd7cc7e9d514639b141b04"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a596e87d0c3bd7cc7e9d514639b141b04"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a596e87d0c3bd7cc7e9d514639b141b04">make_optional</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a596e87d0c3bd7cc7e9d514639b141b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object constructed in-place from args...  <a href="namespaceetl.html#a596e87d0c3bd7cc7e9d514639b141b04">More...</a><br /></td></tr>
<tr class="separator:a596e87d0c3bd7cc7e9d514639b141b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75cac911cf6d9b9b3b37254bc227e53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae75cac911cf6d9b9b3b37254bc227e53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae75cac911cf6d9b9b3b37254bc227e53">optional</a> (T) -&gt; <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt;</td></tr>
<tr class="separator:ae75cac911cf6d9b9b3b37254bc227e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292197c3724e916aa8255a622fac6917"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a292197c3724e916aa8255a622fac6917"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a292197c3724e916aa8255a622fac6917">requires</a> (<a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">is_move_constructible_v</a>&lt; T &gt; &amp;&amp;<a class="el" href="namespaceetl.html#a46cb1671f31576cce07cf1bac1e99f7c">is_swappable_v</a>&lt; T &gt;) const expr auto <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5">swap</a>(<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a></td></tr>
<tr class="memdesc:a292197c3724e916aa8255a622fac6917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5" title="Specializes the swap algorithm for array. Swaps the contents of lhs and rhs.">etl::swap</a> algorithm for <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs).  <a href="namespaceetl.html#a292197c3724e916aa8255a622fac6917">More...</a><br /></td></tr>
<tr class="separator:a292197c3724e916aa8255a622fac6917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c716c7d4cedeee80b97e63863bb824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a25c716c7d4cedeee80b97e63863bb824">noexcept</a> (noexcept(lhs.swap(rhs))) -&gt; void</td></tr>
<tr class="separator:a25c716c7d4cedeee80b97e63863bb824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1cc2f7a422e0cadab9361b16f7e875"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5d1cc2f7a422e0cadab9361b16f7e875"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5d1cc2f7a422e0cadab9361b16f7e875">operator==</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a5d1cc2f7a422e0cadab9361b16f7e875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="namespaceetl.html#a5d1cc2f7a422e0cadab9361b16f7e875">More...</a><br /></td></tr>
<tr class="separator:a5d1cc2f7a422e0cadab9361b16f7e875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0199291e596a6580c028a4fbb4c1a439"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a0199291e596a6580c028a4fbb4c1a439"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0199291e596a6580c028a4fbb4c1a439">operator!=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a0199291e596a6580c028a4fbb4c1a439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="namespaceetl.html#a0199291e596a6580c028a4fbb4c1a439">More...</a><br /></td></tr>
<tr class="separator:a0199291e596a6580c028a4fbb4c1a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dad36bf3c15c14d239e80047211e27"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad2dad36bf3c15c14d239e80047211e27"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad2dad36bf3c15c14d239e80047211e27">operator&lt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ad2dad36bf3c15c14d239e80047211e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="namespaceetl.html#ad2dad36bf3c15c14d239e80047211e27">More...</a><br /></td></tr>
<tr class="separator:ad2dad36bf3c15c14d239e80047211e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa8cfb4c68d3b5bf2a12e64973a9ee892">operator&gt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="namespaceetl.html#aa8cfb4c68d3b5bf2a12e64973a9ee892">More...</a><br /></td></tr>
<tr class="separator:aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6d41e110c97a6f118fac996337da06"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:abc6d41e110c97a6f118fac996337da06"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abc6d41e110c97a6f118fac996337da06">operator&lt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:abc6d41e110c97a6f118fac996337da06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="namespaceetl.html#abc6d41e110c97a6f118fac996337da06">More...</a><br /></td></tr>
<tr class="separator:abc6d41e110c97a6f118fac996337da06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd1c4702ae19a08b1aa3f03807f1267"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4cd1c4702ae19a08b1aa3f03807f1267"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4cd1c4702ae19a08b1aa3f03807f1267">operator&gt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a4cd1c4702ae19a08b1aa3f03807f1267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="namespaceetl.html#a4cd1c4702ae19a08b1aa3f03807f1267">More...</a><br /></td></tr>
<tr class="separator:a4cd1c4702ae19a08b1aa3f03807f1267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb0eb100ae57232d484215f1b4315d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbb0eb100ae57232d484215f1b4315d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afbb0eb100ae57232d484215f1b4315d6">operator==</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:afbb0eb100ae57232d484215f1b4315d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#afbb0eb100ae57232d484215f1b4315d6">More...</a><br /></td></tr>
<tr class="separator:afbb0eb100ae57232d484215f1b4315d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bdc0584358e44c777f1ff6dd845026"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55bdc0584358e44c777f1ff6dd845026"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a55bdc0584358e44c777f1ff6dd845026">operator==</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a55bdc0584358e44c777f1ff6dd845026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#a55bdc0584358e44c777f1ff6dd845026">More...</a><br /></td></tr>
<tr class="separator:a55bdc0584358e44c777f1ff6dd845026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e737d88ff2f1d432403026a91a24766"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e737d88ff2f1d432403026a91a24766"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8e737d88ff2f1d432403026a91a24766">operator!=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a8e737d88ff2f1d432403026a91a24766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#a8e737d88ff2f1d432403026a91a24766">More...</a><br /></td></tr>
<tr class="separator:a8e737d88ff2f1d432403026a91a24766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad6bf68822d73dd9f0d84b6a5aa3f3618">operator!=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#ad6bf68822d73dd9f0d84b6a5aa3f3618">More...</a><br /></td></tr>
<tr class="separator:ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7d07feb0fa4c7f8287a166fbbe4975ee">operator&lt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#a7d07feb0fa4c7f8287a166fbbe4975ee">More...</a><br /></td></tr>
<tr class="separator:a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b91acd82b61f0b96647711aa1414b71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b91acd82b61f0b96647711aa1414b71"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0b91acd82b61f0b96647711aa1414b71">operator&lt;</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a0b91acd82b61f0b96647711aa1414b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#a0b91acd82b61f0b96647711aa1414b71">More...</a><br /></td></tr>
<tr class="separator:a0b91acd82b61f0b96647711aa1414b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffa5aed44c30aae39950e0d82c7a256"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ffa5aed44c30aae39950e0d82c7a256"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0ffa5aed44c30aae39950e0d82c7a256">operator&lt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a0ffa5aed44c30aae39950e0d82c7a256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#a0ffa5aed44c30aae39950e0d82c7a256">More...</a><br /></td></tr>
<tr class="separator:a0ffa5aed44c30aae39950e0d82c7a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3003b74d5cf5363cb983a63f0beaa5b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3003b74d5cf5363cb983a63f0beaa5b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3003b74d5cf5363cb983a63f0beaa5b8">operator&lt;=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a3003b74d5cf5363cb983a63f0beaa5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#a3003b74d5cf5363cb983a63f0beaa5b8">More...</a><br /></td></tr>
<tr class="separator:a3003b74d5cf5363cb983a63f0beaa5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa2ec0f3b39223f0c48dcae6bf744ac8f">operator&gt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#aa2ec0f3b39223f0c48dcae6bf744ac8f">More...</a><br /></td></tr>
<tr class="separator:aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070d0943c411911df11ac5176fa48016"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a070d0943c411911df11ac5176fa48016"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a070d0943c411911df11ac5176fa48016">operator&gt;</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a070d0943c411911df11ac5176fa48016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#a070d0943c411911df11ac5176fa48016">More...</a><br /></td></tr>
<tr class="separator:a070d0943c411911df11ac5176fa48016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad322ae7ca3d230a2cfb6aae8d633356b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad322ae7ca3d230a2cfb6aae8d633356b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad322ae7ca3d230a2cfb6aae8d633356b">operator&gt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ad322ae7ca3d230a2cfb6aae8d633356b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#ad322ae7ca3d230a2cfb6aae8d633356b">More...</a><br /></td></tr>
<tr class="separator:ad322ae7ca3d230a2cfb6aae8d633356b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe18304d67bab939fd57ac52900323a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fe18304d67bab939fd57ac52900323a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8fe18304d67bab939fd57ac52900323a">operator&gt;=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a8fe18304d67bab939fd57ac52900323a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="namespaceetl.html#a8fe18304d67bab939fd57ac52900323a">More...</a><br /></td></tr>
<tr class="separator:a8fe18304d67bab939fd57ac52900323a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975270db4255209c6d0a1664d9072560"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a975270db4255209c6d0a1664d9072560"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a975270db4255209c6d0a1664d9072560">operator==</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, U const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; bool</td></tr>
<tr class="memdesc:a975270db4255209c6d0a1664d9072560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#a975270db4255209c6d0a1664d9072560">More...</a><br /></td></tr>
<tr class="separator:a975270db4255209c6d0a1664d9072560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5311a7c4d14b66f603c0fff05bb0670f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5311a7c4d14b66f603c0fff05bb0670f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5311a7c4d14b66f603c0fff05bb0670f">operator==</a> (T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;opt) -&gt; bool</td></tr>
<tr class="memdesc:a5311a7c4d14b66f603c0fff05bb0670f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#a5311a7c4d14b66f603c0fff05bb0670f">More...</a><br /></td></tr>
<tr class="separator:a5311a7c4d14b66f603c0fff05bb0670f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad955578770fdb3a931ddd25d78ed03de"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad955578770fdb3a931ddd25d78ed03de"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad955578770fdb3a931ddd25d78ed03de">operator!=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, U const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; bool</td></tr>
<tr class="memdesc:ad955578770fdb3a931ddd25d78ed03de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#ad955578770fdb3a931ddd25d78ed03de">More...</a><br /></td></tr>
<tr class="separator:ad955578770fdb3a931ddd25d78ed03de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86505f8f0a3853f5fd106b17b367ebd0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a86505f8f0a3853f5fd106b17b367ebd0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a86505f8f0a3853f5fd106b17b367ebd0">operator!=</a> (T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;opt) -&gt; bool</td></tr>
<tr class="memdesc:a86505f8f0a3853f5fd106b17b367ebd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#a86505f8f0a3853f5fd106b17b367ebd0">More...</a><br /></td></tr>
<tr class="separator:a86505f8f0a3853f5fd106b17b367ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d356ce4c5ed39ba60230ccb9bcdc76a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5d356ce4c5ed39ba60230ccb9bcdc76a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5d356ce4c5ed39ba60230ccb9bcdc76a">operator&lt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, U const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; bool</td></tr>
<tr class="memdesc:a5d356ce4c5ed39ba60230ccb9bcdc76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#a5d356ce4c5ed39ba60230ccb9bcdc76a">More...</a><br /></td></tr>
<tr class="separator:a5d356ce4c5ed39ba60230ccb9bcdc76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683d8509d04f83a6cb7061df789c630c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a683d8509d04f83a6cb7061df789c630c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a683d8509d04f83a6cb7061df789c630c">operator&lt;</a> (T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;opt) -&gt; bool</td></tr>
<tr class="memdesc:a683d8509d04f83a6cb7061df789c630c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#a683d8509d04f83a6cb7061df789c630c">More...</a><br /></td></tr>
<tr class="separator:a683d8509d04f83a6cb7061df789c630c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a59b23e259ef7140b324f681aa07dd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a83a59b23e259ef7140b324f681aa07dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a83a59b23e259ef7140b324f681aa07dd">operator&gt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, U const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; bool</td></tr>
<tr class="memdesc:a83a59b23e259ef7140b324f681aa07dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#a83a59b23e259ef7140b324f681aa07dd">More...</a><br /></td></tr>
<tr class="separator:a83a59b23e259ef7140b324f681aa07dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4a6c0e67c15c1663f2cf60e9281833"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:abf4a6c0e67c15c1663f2cf60e9281833"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abf4a6c0e67c15c1663f2cf60e9281833">operator&gt;</a> (T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;opt) -&gt; bool</td></tr>
<tr class="memdesc:abf4a6c0e67c15c1663f2cf60e9281833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#abf4a6c0e67c15c1663f2cf60e9281833">More...</a><br /></td></tr>
<tr class="separator:abf4a6c0e67c15c1663f2cf60e9281833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270636ff7b3f10c31fea081efff5be7e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a270636ff7b3f10c31fea081efff5be7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a270636ff7b3f10c31fea081efff5be7e">operator&lt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, U const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; bool</td></tr>
<tr class="memdesc:a270636ff7b3f10c31fea081efff5be7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#a270636ff7b3f10c31fea081efff5be7e">More...</a><br /></td></tr>
<tr class="separator:a270636ff7b3f10c31fea081efff5be7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60f7a5afa042d61659f05a0810ac1cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:af60f7a5afa042d61659f05a0810ac1cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af60f7a5afa042d61659f05a0810ac1cd">operator&lt;=</a> (T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;opt) -&gt; bool</td></tr>
<tr class="memdesc:af60f7a5afa042d61659f05a0810ac1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#af60f7a5afa042d61659f05a0810ac1cd">More...</a><br /></td></tr>
<tr class="separator:af60f7a5afa042d61659f05a0810ac1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315cb53ac332644f510d613388dc9403"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a315cb53ac332644f510d613388dc9403"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a315cb53ac332644f510d613388dc9403">operator&gt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, U const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; bool</td></tr>
<tr class="memdesc:a315cb53ac332644f510d613388dc9403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#a315cb53ac332644f510d613388dc9403">More...</a><br /></td></tr>
<tr class="separator:a315cb53ac332644f510d613388dc9403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e08e7d4bbce49c0f236c523f6ca908a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1e08e7d4bbce49c0f236c523f6ca908a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1e08e7d4bbce49c0f236c523f6ca908a">operator&gt;=</a> (T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;opt) -&gt; bool</td></tr>
<tr class="memdesc:a1e08e7d4bbce49c0f236c523f6ca908a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="namespaceetl.html#a1e08e7d4bbce49c0f236c523f6ca908a">More...</a><br /></td></tr>
<tr class="separator:a1e08e7d4bbce49c0f236c523f6ca908a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740c4c4c7e95fbc853b0f8494375b927"><td class="memTemplParams" colspan="2">template&lt;typename Real , size_t Bits, typename RNG &gt; </td></tr>
<tr class="memitem:a740c4c4c7e95fbc853b0f8494375b927"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a740c4c4c7e95fbc853b0f8494375b927">generate_canonical</a> (RNG &amp;g) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(g())) -&gt; Real</td></tr>
<tr class="memdesc:a740c4c4c7e95fbc853b0f8494375b927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random floating point number in range [0,1).  <a href="namespaceetl.html#a740c4c4c7e95fbc853b0f8494375b927">More...</a><br /></td></tr>
<tr class="separator:a740c4c4c7e95fbc853b0f8494375b927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b146153934880dc3e2994a848584226"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b146153934880dc3e2994a848584226"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2b146153934880dc3e2994a848584226">decay_copy</a> (T &amp;&amp;t) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a2efb1cd1aad111e64a98e89322815a8f">is_nothrow_convertible_v</a>&lt; T, <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; T &gt;&gt;) -&gt; <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; T &gt;</td></tr>
<tr class="separator:a2b146153934880dc3e2994a848584226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25b6713e904e47178a1a000a373097a"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:ab25b6713e904e47178a1a000a373097a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab25b6713e904e47178a1a000a373097a">scope_exit</a> (FuncT) -&gt; <a class="el" href="structetl_1_1scope__exit.html">scope_exit</a>&lt; <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; FuncT &gt;&gt;</td></tr>
<tr class="separator:ab25b6713e904e47178a1a000a373097a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16898ab8f9b95de51802d2ac8840c5cb"><td class="memTemplParams" colspan="2">template&lt;typename Key , size_t Capacity, typename Comp &gt; </td></tr>
<tr class="memitem:a16898ab8f9b95de51802d2ac8840c5cb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a16898ab8f9b95de51802d2ac8840c5cb">operator==</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a16898ab8f9b95de51802d2ac8840c5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <a href="namespaceetl.html#a16898ab8f9b95de51802d2ac8840c5cb">More...</a><br /></td></tr>
<tr class="separator:a16898ab8f9b95de51802d2ac8840c5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5ef95c5d2a3f3b77b9d48b0ee394c6"><td class="memTemplParams" colspan="2">template&lt;typename Key , size_t Capacity, typename Comp &gt; </td></tr>
<tr class="memitem:aeb5ef95c5d2a3f3b77b9d48b0ee394c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aeb5ef95c5d2a3f3b77b9d48b0ee394c6">operator!=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:aeb5ef95c5d2a3f3b77b9d48b0ee394c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <a href="namespaceetl.html#aeb5ef95c5d2a3f3b77b9d48b0ee394c6">More...</a><br /></td></tr>
<tr class="separator:aeb5ef95c5d2a3f3b77b9d48b0ee394c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51f4f81c713960abeab665d097df056"><td class="memTemplParams" colspan="2">template&lt;typename Key , size_t Capacity, typename Comp &gt; </td></tr>
<tr class="memitem:aa51f4f81c713960abeab665d097df056"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa51f4f81c713960abeab665d097df056">operator&lt;</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:aa51f4f81c713960abeab665d097df056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <a href="namespaceetl.html#aa51f4f81c713960abeab665d097df056">More...</a><br /></td></tr>
<tr class="separator:aa51f4f81c713960abeab665d097df056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac570ea8aff6b11f4ff8930690e4c5a8e"><td class="memTemplParams" colspan="2">template&lt;typename Key , size_t Capacity, typename Comp &gt; </td></tr>
<tr class="memitem:ac570ea8aff6b11f4ff8930690e4c5a8e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac570ea8aff6b11f4ff8930690e4c5a8e">operator&lt;=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ac570ea8aff6b11f4ff8930690e4c5a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <a href="namespaceetl.html#ac570ea8aff6b11f4ff8930690e4c5a8e">More...</a><br /></td></tr>
<tr class="separator:ac570ea8aff6b11f4ff8930690e4c5a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1767a8d6dec411f212efe9a29c8e0b3"><td class="memTemplParams" colspan="2">template&lt;typename Key , size_t Capacity, typename Comp &gt; </td></tr>
<tr class="memitem:af1767a8d6dec411f212efe9a29c8e0b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af1767a8d6dec411f212efe9a29c8e0b3">operator&gt;</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:af1767a8d6dec411f212efe9a29c8e0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <a href="namespaceetl.html#af1767a8d6dec411f212efe9a29c8e0b3">More...</a><br /></td></tr>
<tr class="separator:af1767a8d6dec411f212efe9a29c8e0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1c3dfb9a3684b8b5905335affb701f"><td class="memTemplParams" colspan="2">template&lt;typename Key , size_t Capacity, typename Comp &gt; </td></tr>
<tr class="memitem:afb1c3dfb9a3684b8b5905335affb701f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afb1c3dfb9a3684b8b5905335affb701f">operator&gt;=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:afb1c3dfb9a3684b8b5905335affb701f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <a href="namespaceetl.html#afb1c3dfb9a3684b8b5905335affb701f">More...</a><br /></td></tr>
<tr class="separator:afb1c3dfb9a3684b8b5905335affb701f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdaddf256aba01af62859d1d068472d"><td class="memTemplParams" colspan="2">template&lt;typename Key , size_t Capacity, typename Compare &gt; </td></tr>
<tr class="memitem:adbdaddf256aba01af62859d1d068472d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adbdaddf256aba01af62859d1d068472d">swap</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Compare &gt; &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Compare &gt; &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(lhs.swap(rhs))) -&gt; void</td></tr>
<tr class="memdesc:adbdaddf256aba01af62859d1d068472d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for set. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs).  <a href="namespaceetl.html#adbdaddf256aba01af62859d1d068472d">More...</a><br /></td></tr>
<tr class="separator:adbdaddf256aba01af62859d1d068472d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf18614592b0fb0ac16bcc76f7cba45"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aebf18614592b0fb0ac16bcc76f7cba45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aebf18614592b0fb0ac16bcc76f7cba45">as_bytes</a> (<a class="el" href="structetl_1_1span.html">span</a>&lt; T, N &gt; s) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1span.html">span</a>&lt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">byte</a> const, detail::span_as_bytes_size&lt; T, N &gt;&gt;</td></tr>
<tr class="memdesc:aebf18614592b0fb0ac16bcc76f7cba45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a view to the object representation of the elements of the span s.  <a href="namespaceetl.html#aebf18614592b0fb0ac16bcc76f7cba45">More...</a><br /></td></tr>
<tr class="separator:aebf18614592b0fb0ac16bcc76f7cba45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214ed44ede7f5b18e511d0a699b5af18"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a214ed44ede7f5b18e511d0a699b5af18"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a214ed44ede7f5b18e511d0a699b5af18">requires</a> (not <a class="el" href="namespaceetl.html#a40862de0c689f5281b8d680741bc7cf9">is_const_v</a>&lt; T &gt;) auto as_writable_bytes(<a class="el" href="structetl_1_1span.html">span</a>&lt; T</td></tr>
<tr class="memdesc:a214ed44ede7f5b18e511d0a699b5af18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a view to the object representation of the elements of the span s.  <a href="namespaceetl.html#a214ed44ede7f5b18e511d0a699b5af18">More...</a><br /></td></tr>
<tr class="separator:a214ed44ede7f5b18e511d0a699b5af18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da3a02a79034271cbc560bc94dbe2cd"><td class="memTemplParams" colspan="2">template&lt;typename Type , etl::size_t Extent&gt; </td></tr>
<tr class="memitem:a0da3a02a79034271cbc560bc94dbe2cd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0da3a02a79034271cbc560bc94dbe2cd">span</a> (Type(&amp;)[Extent]) -&gt; <a class="el" href="structetl_1_1span.html">span</a>&lt; Type, Extent &gt;</td></tr>
<tr class="separator:a0da3a02a79034271cbc560bc94dbe2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ab2c6a5bc678d0ca3f5137c4004543"><td class="memTemplParams" colspan="2">template&lt;typename Type , etl::size_t Size&gt; </td></tr>
<tr class="memitem:ac6ab2c6a5bc678d0ca3f5137c4004543"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac6ab2c6a5bc678d0ca3f5137c4004543">span</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; Type, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; &amp;) -&gt; <a class="el" href="structetl_1_1span.html">span</a>&lt; Type, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt;</td></tr>
<tr class="separator:ac6ab2c6a5bc678d0ca3f5137c4004543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5667307c6ae6ae51fa6d1488fbab93b"><td class="memTemplParams" colspan="2">template&lt;typename Type , etl::size_t Size&gt; </td></tr>
<tr class="memitem:aa5667307c6ae6ae51fa6d1488fbab93b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa5667307c6ae6ae51fa6d1488fbab93b">span</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; Type, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; const &amp;) -&gt; <a class="el" href="structetl_1_1span.html">span</a>&lt; Type const, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt;</td></tr>
<tr class="separator:aa5667307c6ae6ae51fa6d1488fbab93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e186959b2d5132ab142843576d30048"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Element  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container&amp;&gt;().data())&gt;&gt; </td></tr>
<tr class="memitem:a9e186959b2d5132ab142843576d30048"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9e186959b2d5132ab142843576d30048">span</a> (Container &amp;) -&gt; <a class="el" href="structetl_1_1span.html">span</a>&lt; Element &gt;</td></tr>
<tr class="separator:a9e186959b2d5132ab142843576d30048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc55cb127ec094c3dbdec3ed03452ebc"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Element  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container const&amp;&gt;().data())&gt;&gt; </td></tr>
<tr class="memitem:adc55cb127ec094c3dbdec3ed03452ebc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adc55cb127ec094c3dbdec3ed03452ebc">span</a> (Container const &amp;) -&gt; <a class="el" href="structetl_1_1span.html">span</a>&lt; Element &gt;</td></tr>
<tr class="separator:adc55cb127ec094c3dbdec3ed03452ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57d951f6a467976762f8f57f9b49cee"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ab57d951f6a467976762f8f57f9b49cee"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab57d951f6a467976762f8f57f9b49cee">stack</a> (Container) -&gt; <a class="el" href="structetl_1_1stack.html">stack</a>&lt; typename Container::value_type, Container &gt;</td></tr>
<tr class="separator:ab57d951f6a467976762f8f57f9b49cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335349cd6aae9e810496caeba2c8c7cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C &gt; </td></tr>
<tr class="memitem:a335349cd6aae9e810496caeba2c8c7cd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a335349cd6aae9e810496caeba2c8c7cd">requires</a> (<a class="el" href="namespaceetl.html#a46cb1671f31576cce07cf1bac1e99f7c">is_swappable_v</a>&lt; C &gt;) const expr auto <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5">swap</a>(<a class="el" href="structetl_1_1stack.html">stack</a>&lt; T</td></tr>
<tr class="memdesc:a335349cd6aae9e810496caeba2c8c7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for stack. Swaps the contents of lhs and rhs. This overload only participates in overload resolution if is_swappable&lt;C&gt;::value is true.  <a href="namespaceetl.html#a335349cd6aae9e810496caeba2c8c7cd">More...</a><br /></td></tr>
<tr class="separator:a335349cd6aae9e810496caeba2c8c7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550be74a772ee835b7969103906449d0"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , size_t Capacity1, size_t Capacity2&gt; </td></tr>
<tr class="memitem:a550be74a772ee835b7969103906449d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a550be74a772ee835b7969103906449d0">operator+</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity1, Traits &gt;</td></tr>
<tr class="memdesc:a550be74a772ee835b7969103906449d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <a href="namespaceetl.html#a550be74a772ee835b7969103906449d0">More...</a><br /></td></tr>
<tr class="separator:a550be74a772ee835b7969103906449d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f68785d405ab507029b4dc21d784f32"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , size_t Capacity&gt; </td></tr>
<tr class="memitem:a8f68785d405ab507029b4dc21d784f32"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8f68785d405ab507029b4dc21d784f32">operator+</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, CharT const *rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt;</td></tr>
<tr class="memdesc:a8f68785d405ab507029b4dc21d784f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <a href="namespaceetl.html#a8f68785d405ab507029b4dc21d784f32">More...</a><br /></td></tr>
<tr class="separator:a8f68785d405ab507029b4dc21d784f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3730f573680ab7ee2848994263888494"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , size_t Capacity&gt; </td></tr>
<tr class="memitem:a3730f573680ab7ee2848994263888494"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3730f573680ab7ee2848994263888494">operator+</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, CharT rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt;</td></tr>
<tr class="memdesc:a3730f573680ab7ee2848994263888494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <a href="namespaceetl.html#a3730f573680ab7ee2848994263888494">More...</a><br /></td></tr>
<tr class="separator:a3730f573680ab7ee2848994263888494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0402f15f7abdd70ed375cfc0c967739a"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , size_t Capacity&gt; </td></tr>
<tr class="memitem:a0402f15f7abdd70ed375cfc0c967739a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0402f15f7abdd70ed375cfc0c967739a">operator+</a> (CharT const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt;</td></tr>
<tr class="memdesc:a0402f15f7abdd70ed375cfc0c967739a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <a href="namespaceetl.html#a0402f15f7abdd70ed375cfc0c967739a">More...</a><br /></td></tr>
<tr class="separator:a0402f15f7abdd70ed375cfc0c967739a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6e97ff485e83eeab3a47dda30b592b"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , size_t Capacity&gt; </td></tr>
<tr class="memitem:a1e6e97ff485e83eeab3a47dda30b592b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1e6e97ff485e83eeab3a47dda30b592b">operator+</a> (CharT <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt;</td></tr>
<tr class="memdesc:a1e6e97ff485e83eeab3a47dda30b592b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <a href="namespaceetl.html#a1e6e97ff485e83eeab3a47dda30b592b">More...</a><br /></td></tr>
<tr class="separator:a1e6e97ff485e83eeab3a47dda30b592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6b52bf4545c553a814d0bdb36cfc3b"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </td></tr>
<tr class="memitem:a1d6b52bf4545c553a814d0bdb36cfc3b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1d6b52bf4545c553a814d0bdb36cfc3b">operator==</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a1d6b52bf4545c553a814d0bdb36cfc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#a1d6b52bf4545c553a814d0bdb36cfc3b">More...</a><br /></td></tr>
<tr class="separator:a1d6b52bf4545c553a814d0bdb36cfc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7dc7e7afd9ab5389cf089585ecb7ff"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:afd7dc7e7afd9ab5389cf089585ecb7ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afd7dc7e7afd9ab5389cf089585ecb7ff">operator==</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, CharT const *rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:afd7dc7e7afd9ab5389cf089585ecb7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#afd7dc7e7afd9ab5389cf089585ecb7ff">More...</a><br /></td></tr>
<tr class="separator:afd7dc7e7afd9ab5389cf089585ecb7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7c985efe97b9de9bcb2fd57ed62f63"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a1f7c985efe97b9de9bcb2fd57ed62f63"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1f7c985efe97b9de9bcb2fd57ed62f63">operator==</a> (CharT const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a1f7c985efe97b9de9bcb2fd57ed62f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#a1f7c985efe97b9de9bcb2fd57ed62f63">More...</a><br /></td></tr>
<tr class="separator:a1f7c985efe97b9de9bcb2fd57ed62f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af595ea9358f1b118453f23ce14c7c539"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </td></tr>
<tr class="memitem:af595ea9358f1b118453f23ce14c7c539"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af595ea9358f1b118453f23ce14c7c539">operator!=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:af595ea9358f1b118453f23ce14c7c539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#af595ea9358f1b118453f23ce14c7c539">More...</a><br /></td></tr>
<tr class="separator:af595ea9358f1b118453f23ce14c7c539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9556a73ed76342b9e3acbfde9f9cdac8"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </td></tr>
<tr class="memitem:a9556a73ed76342b9e3acbfde9f9cdac8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9556a73ed76342b9e3acbfde9f9cdac8">operator!=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, CharT const *rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a9556a73ed76342b9e3acbfde9f9cdac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#a9556a73ed76342b9e3acbfde9f9cdac8">More...</a><br /></td></tr>
<tr class="separator:a9556a73ed76342b9e3acbfde9f9cdac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2996ca93f7497f0f26bc52448cbc3a87"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a2996ca93f7497f0f26bc52448cbc3a87"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2996ca93f7497f0f26bc52448cbc3a87">operator!=</a> (CharT const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a2996ca93f7497f0f26bc52448cbc3a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#a2996ca93f7497f0f26bc52448cbc3a87">More...</a><br /></td></tr>
<tr class="separator:a2996ca93f7497f0f26bc52448cbc3a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac484f684a7e23d519733aa7a1dfdd2cc"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </td></tr>
<tr class="memitem:ac484f684a7e23d519733aa7a1dfdd2cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac484f684a7e23d519733aa7a1dfdd2cc">operator&lt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a></td></tr>
<tr class="memdesc:ac484f684a7e23d519733aa7a1dfdd2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#ac484f684a7e23d519733aa7a1dfdd2cc">More...</a><br /></td></tr>
<tr class="separator:ac484f684a7e23d519733aa7a1dfdd2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f66fcbe677016753265cda13588a02"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </td></tr>
<tr class="memitem:a25f66fcbe677016753265cda13588a02"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a25f66fcbe677016753265cda13588a02">operator&lt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, CharT const *rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a25f66fcbe677016753265cda13588a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#a25f66fcbe677016753265cda13588a02">More...</a><br /></td></tr>
<tr class="separator:a25f66fcbe677016753265cda13588a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834f76d59c40a1aaa9b9f45222a5815c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </td></tr>
<tr class="memitem:a834f76d59c40a1aaa9b9f45222a5815c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a834f76d59c40a1aaa9b9f45222a5815c">operator&lt;</a> (CharT const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a834f76d59c40a1aaa9b9f45222a5815c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#a834f76d59c40a1aaa9b9f45222a5815c">More...</a><br /></td></tr>
<tr class="separator:a834f76d59c40a1aaa9b9f45222a5815c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105ce49011cd77ed4c6e3b72390ed12b"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </td></tr>
<tr class="memitem:a105ce49011cd77ed4c6e3b72390ed12b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a105ce49011cd77ed4c6e3b72390ed12b">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a></td></tr>
<tr class="memdesc:a105ce49011cd77ed4c6e3b72390ed12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#a105ce49011cd77ed4c6e3b72390ed12b">More...</a><br /></td></tr>
<tr class="separator:a105ce49011cd77ed4c6e3b72390ed12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dc9a85456db0c3b0085526ad74898c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </td></tr>
<tr class="memitem:a24dc9a85456db0c3b0085526ad74898c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a24dc9a85456db0c3b0085526ad74898c">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, CharT const *rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a24dc9a85456db0c3b0085526ad74898c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#a24dc9a85456db0c3b0085526ad74898c">More...</a><br /></td></tr>
<tr class="separator:a24dc9a85456db0c3b0085526ad74898c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3378b9bc8853f3e35709acd2a945d2a"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </td></tr>
<tr class="memitem:ad3378b9bc8853f3e35709acd2a945d2a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad3378b9bc8853f3e35709acd2a945d2a">operator&lt;=</a> (CharT const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ad3378b9bc8853f3e35709acd2a945d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#ad3378b9bc8853f3e35709acd2a945d2a">More...</a><br /></td></tr>
<tr class="separator:ad3378b9bc8853f3e35709acd2a945d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dbbab6f8321779c8eb9b3b173cb34e"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </td></tr>
<tr class="memitem:a07dbbab6f8321779c8eb9b3b173cb34e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a07dbbab6f8321779c8eb9b3b173cb34e">operator&gt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a></td></tr>
<tr class="memdesc:a07dbbab6f8321779c8eb9b3b173cb34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#a07dbbab6f8321779c8eb9b3b173cb34e">More...</a><br /></td></tr>
<tr class="separator:a07dbbab6f8321779c8eb9b3b173cb34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fe899d26d372e2f56cbe8fa4551770"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </td></tr>
<tr class="memitem:af8fe899d26d372e2f56cbe8fa4551770"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8fe899d26d372e2f56cbe8fa4551770">operator&gt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, CharT const *rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:af8fe899d26d372e2f56cbe8fa4551770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#af8fe899d26d372e2f56cbe8fa4551770">More...</a><br /></td></tr>
<tr class="separator:af8fe899d26d372e2f56cbe8fa4551770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd663da7cd107379f89f863f44d18d7c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </td></tr>
<tr class="memitem:abd663da7cd107379f89f863f44d18d7c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abd663da7cd107379f89f863f44d18d7c">operator&gt;</a> (CharT const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:abd663da7cd107379f89f863f44d18d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#abd663da7cd107379f89f863f44d18d7c">More...</a><br /></td></tr>
<tr class="separator:abd663da7cd107379f89f863f44d18d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e94a2069d38ef480a1f723e594c4f60"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </td></tr>
<tr class="memitem:a0e94a2069d38ef480a1f723e594c4f60"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0e94a2069d38ef480a1f723e594c4f60">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a></td></tr>
<tr class="memdesc:a0e94a2069d38ef480a1f723e594c4f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#a0e94a2069d38ef480a1f723e594c4f60">More...</a><br /></td></tr>
<tr class="separator:a0e94a2069d38ef480a1f723e594c4f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe7782ee247113a01628108deed5640"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a1fe7782ee247113a01628108deed5640"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1fe7782ee247113a01628108deed5640">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, CharT const *rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a1fe7782ee247113a01628108deed5640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#a1fe7782ee247113a01628108deed5640">More...</a><br /></td></tr>
<tr class="separator:a1fe7782ee247113a01628108deed5640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada97bd78bce6e3f4b4181a18403077da"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:ada97bd78bce6e3f4b4181a18403077da"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ada97bd78bce6e3f4b4181a18403077da">operator&gt;=</a> (CharT const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ada97bd78bce6e3f4b4181a18403077da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <a href="namespaceetl.html#ada97bd78bce6e3f4b4181a18403077da">More...</a><br /></td></tr>
<tr class="separator:ada97bd78bce6e3f4b4181a18403077da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9897e71535e601101f19e29b7fb9c82"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:ad9897e71535e601101f19e29b7fb9c82"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad9897e71535e601101f19e29b7fb9c82">swap</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(lhs.swap(rhs))) -&gt; void</td></tr>
<tr class="memdesc:ad9897e71535e601101f19e29b7fb9c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5" title="Specializes the swap algorithm for array. Swaps the contents of lhs and rhs.">etl::swap</a> algorithm for <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">etl::basic_static_string</a>. Swaps the contents of lhs and rhs. Equivalent to lhs.swap(rhs).  <a href="namespaceetl.html#ad9897e71535e601101f19e29b7fb9c82">More...</a><br /></td></tr>
<tr class="separator:ad9897e71535e601101f19e29b7fb9c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cf7e5dcda9f55d609ec4236a37c3b0"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity, typename U &gt; </td></tr>
<tr class="memitem:a21cf7e5dcda9f55d609ec4236a37c3b0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a21cf7e5dcda9f55d609ec4236a37c3b0">erase</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; &amp;c, U const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; typename <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt;::size_type</td></tr>
<tr class="memdesc:a21cf7e5dcda9f55d609ec4236a37c3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that compare equal to value from the container.  <a href="namespaceetl.html#a21cf7e5dcda9f55d609ec4236a37c3b0">More...</a><br /></td></tr>
<tr class="separator:a21cf7e5dcda9f55d609ec4236a37c3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b84ee8ace15469eade7ad329497759"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , etl::size_t Capacity, typename Predicate &gt; </td></tr>
<tr class="memitem:ae5b84ee8ace15469eade7ad329497759"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae5b84ee8ace15469eade7ad329497759">erase_if</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; &amp;c, Predicate pred) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; typename <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt;::size_type</td></tr>
<tr class="memdesc:ae5b84ee8ace15469eade7ad329497759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate pred from the container.  <a href="namespaceetl.html#ae5b84ee8ace15469eade7ad329497759">More...</a><br /></td></tr>
<tr class="separator:ae5b84ee8ace15469eade7ad329497759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5346fd1e1c69c9da34adc6ba0d875b"><td class="memTemplParams" colspan="2">template&lt;size_t Capacity&gt; </td></tr>
<tr class="memitem:a7b5346fd1e1c69c9da34adc6ba0d875b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7b5346fd1e1c69c9da34adc6ba0d875b">stof</a> (<a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">static_string</a>&lt; Capacity &gt; const &amp;str, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> *pos=nullptr) -&gt; float</td></tr>
<tr class="memdesc:a7b5346fd1e1c69c9da34adc6ba0d875b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <a href="namespaceetl.html#a7b5346fd1e1c69c9da34adc6ba0d875b">More...</a><br /></td></tr>
<tr class="separator:a7b5346fd1e1c69c9da34adc6ba0d875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03247c5be7114ad3402fea1ac09a5323"><td class="memTemplParams" colspan="2">template&lt;size_t Capacity&gt; </td></tr>
<tr class="memitem:a03247c5be7114ad3402fea1ac09a5323"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a03247c5be7114ad3402fea1ac09a5323">stod</a> (<a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">static_string</a>&lt; Capacity &gt; const &amp;str, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> *pos=nullptr) -&gt; double</td></tr>
<tr class="memdesc:a03247c5be7114ad3402fea1ac09a5323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <a href="namespaceetl.html#a03247c5be7114ad3402fea1ac09a5323">More...</a><br /></td></tr>
<tr class="separator:a03247c5be7114ad3402fea1ac09a5323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d8c5321a6401ffca589167c2f5200c"><td class="memTemplParams" colspan="2">template&lt;size_t Capacity&gt; </td></tr>
<tr class="memitem:ad2d8c5321a6401ffca589167c2f5200c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad2d8c5321a6401ffca589167c2f5200c">stold</a> (<a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">static_string</a>&lt; Capacity &gt; const &amp;str, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> *pos=nullptr) -&gt; long double</td></tr>
<tr class="memdesc:ad2d8c5321a6401ffca589167c2f5200c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <a href="namespaceetl.html#ad2d8c5321a6401ffca589167c2f5200c">More...</a><br /></td></tr>
<tr class="separator:ad2d8c5321a6401ffca589167c2f5200c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67d02a60ed99d7b4f7caa47c456418c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad67d02a60ed99d7b4f7caa47c456418c">stoi</a> (<a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a> str, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> *pos=nullptr, int <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>=10) -&gt; int</td></tr>
<tr class="memdesc:ad67d02a60ed99d7b4f7caa47c456418c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <a href="namespaceetl.html#ad67d02a60ed99d7b4f7caa47c456418c">More...</a><br /></td></tr>
<tr class="separator:ad67d02a60ed99d7b4f7caa47c456418c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e713476eeb2d06c599abb03b3c81da"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac5e713476eeb2d06c599abb03b3c81da">stol</a> (<a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a> str, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> *pos=nullptr, int <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>=10) -&gt; long</td></tr>
<tr class="memdesc:ac5e713476eeb2d06c599abb03b3c81da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <a href="namespaceetl.html#ac5e713476eeb2d06c599abb03b3c81da">More...</a><br /></td></tr>
<tr class="separator:ac5e713476eeb2d06c599abb03b3c81da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6979ddaeccf0df75fc74642fad0938"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3e6979ddaeccf0df75fc74642fad0938">stoll</a> (<a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a> str, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> *pos=nullptr, int <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>=10) -&gt; long long</td></tr>
<tr class="memdesc:a3e6979ddaeccf0df75fc74642fad0938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <a href="namespaceetl.html#a3e6979ddaeccf0df75fc74642fad0938">More...</a><br /></td></tr>
<tr class="separator:a3e6979ddaeccf0df75fc74642fad0938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5ca51303826f354fffce9e40115186"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aab5ca51303826f354fffce9e40115186">stoul</a> (<a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a> str, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> *pos=nullptr, int <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>=10) -&gt; unsigned long</td></tr>
<tr class="memdesc:aab5ca51303826f354fffce9e40115186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <a href="namespaceetl.html#aab5ca51303826f354fffce9e40115186">More...</a><br /></td></tr>
<tr class="separator:aab5ca51303826f354fffce9e40115186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fff36f8d372c069a8335afa15afab5d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5fff36f8d372c069a8335afa15afab5d">stoull</a> (<a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a> str, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> *pos=nullptr, int <a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>=10) -&gt; unsigned long long</td></tr>
<tr class="memdesc:a5fff36f8d372c069a8335afa15afab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <a href="namespaceetl.html#a5fff36f8d372c069a8335afa15afab5d">More...</a><br /></td></tr>
<tr class="separator:a5fff36f8d372c069a8335afa15afab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefef503dc1f63ba2e9183e92350a35d6"><td class="memTemplParams" colspan="2">template&lt;typename CharT , CharT... Chars&gt; </td></tr>
<tr class="memitem:aefef503dc1f63ba2e9183e92350a35d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aefef503dc1f63ba2e9183e92350a35d6">operator==</a> (<a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; CharT, Chars... &gt;, <a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; CharT, Chars... &gt;) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:aefef503dc1f63ba2e9183e92350a35d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06688b616d203a7f05d1902d4e9e9ae6"><td class="memTemplParams" colspan="2">template&lt;typename CharT , CharT... CharsL, CharT... CharsR&gt; </td></tr>
<tr class="memitem:a06688b616d203a7f05d1902d4e9e9ae6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a06688b616d203a7f05d1902d4e9e9ae6">operator==</a> (<a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; CharT, CharsL... &gt;, <a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; CharT, CharsR... &gt;) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a06688b616d203a7f05d1902d4e9e9ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3175965fb95cd90d46d8741581b050a9"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a3175965fb95cd90d46d8741581b050a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3175965fb95cd90d46d8741581b050a9">to_string</a> (int <a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt; Capacity &gt;</td></tr>
<tr class="memdesc:a3175965fb95cd90d46d8741581b050a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <a href="namespaceetl.html#a3175965fb95cd90d46d8741581b050a9">More...</a><br /></td></tr>
<tr class="separator:a3175965fb95cd90d46d8741581b050a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae1922b9fe325bc073f9157245ea62f"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a0ae1922b9fe325bc073f9157245ea62f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0ae1922b9fe325bc073f9157245ea62f">to_string</a> (long <a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt; Capacity &gt;</td></tr>
<tr class="memdesc:a0ae1922b9fe325bc073f9157245ea62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <a href="namespaceetl.html#a0ae1922b9fe325bc073f9157245ea62f">More...</a><br /></td></tr>
<tr class="separator:a0ae1922b9fe325bc073f9157245ea62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866ea97f8268ee79e420deb4e7d0b5c8"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a866ea97f8268ee79e420deb4e7d0b5c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a866ea97f8268ee79e420deb4e7d0b5c8">to_string</a> (long long <a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt; Capacity &gt;</td></tr>
<tr class="memdesc:a866ea97f8268ee79e420deb4e7d0b5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <a href="namespaceetl.html#a866ea97f8268ee79e420deb4e7d0b5c8">More...</a><br /></td></tr>
<tr class="separator:a866ea97f8268ee79e420deb4e7d0b5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cec2c910331a0348fbc177f79fb5d7"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a76cec2c910331a0348fbc177f79fb5d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a76cec2c910331a0348fbc177f79fb5d7">to_string</a> (unsigned <a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt; Capacity &gt;</td></tr>
<tr class="memdesc:a76cec2c910331a0348fbc177f79fb5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <a href="namespaceetl.html#a76cec2c910331a0348fbc177f79fb5d7">More...</a><br /></td></tr>
<tr class="separator:a76cec2c910331a0348fbc177f79fb5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1591359f7f91cee90f3670ee200fd71e"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a1591359f7f91cee90f3670ee200fd71e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1591359f7f91cee90f3670ee200fd71e">to_string</a> (unsigned long <a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt; Capacity &gt;</td></tr>
<tr class="memdesc:a1591359f7f91cee90f3670ee200fd71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <a href="namespaceetl.html#a1591359f7f91cee90f3670ee200fd71e">More...</a><br /></td></tr>
<tr class="separator:a1591359f7f91cee90f3670ee200fd71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316c748b2a3e782707bf5f99266226ce"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a316c748b2a3e782707bf5f99266226ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a316c748b2a3e782707bf5f99266226ce">to_string</a> (unsigned long long <a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt; Capacity &gt;</td></tr>
<tr class="memdesc:a316c748b2a3e782707bf5f99266226ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <a href="namespaceetl.html#a316c748b2a3e782707bf5f99266226ce">More...</a><br /></td></tr>
<tr class="separator:a316c748b2a3e782707bf5f99266226ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de851aa9fa43387b4735c74a2e913ac"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a3de851aa9fa43387b4735c74a2e913ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3de851aa9fa43387b4735c74a2e913ac">to_string</a> (float <a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt; Capacity &gt;</td></tr>
<tr class="memdesc:a3de851aa9fa43387b4735c74a2e913ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <a href="namespaceetl.html#a3de851aa9fa43387b4735c74a2e913ac">More...</a><br /></td></tr>
<tr class="separator:a3de851aa9fa43387b4735c74a2e913ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12fe48f1155730f6d6beed4ac618c03"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:ad12fe48f1155730f6d6beed4ac618c03"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad12fe48f1155730f6d6beed4ac618c03">to_string</a> (double <a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt; Capacity &gt;</td></tr>
<tr class="memdesc:ad12fe48f1155730f6d6beed4ac618c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <a href="namespaceetl.html#ad12fe48f1155730f6d6beed4ac618c03">More...</a><br /></td></tr>
<tr class="separator:ad12fe48f1155730f6d6beed4ac618c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252c37b56c955507d6f799b10f6d7bf8"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:a252c37b56c955507d6f799b10f6d7bf8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a252c37b56c955507d6f799b10f6d7bf8">to_string</a> (long double <a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt; Capacity &gt;</td></tr>
<tr class="memdesc:a252c37b56c955507d6f799b10f6d7bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <a href="namespaceetl.html#a252c37b56c955507d6f799b10f6d7bf8">More...</a><br /></td></tr>
<tr class="separator:a252c37b56c955507d6f799b10f6d7bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e970cc5b5992d8eb7ac649c247c62c"><td class="memTemplParams" colspan="2">template&lt;typename CharType , typename Traits &gt; </td></tr>
<tr class="memitem:ab7e970cc5b5992d8eb7ac649c247c62c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab7e970cc5b5992d8eb7ac649c247c62c">operator==</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ab7e970cc5b5992d8eb7ac649c247c62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="namespaceetl.html#ab7e970cc5b5992d8eb7ac649c247c62c">More...</a><br /></td></tr>
<tr class="separator:ab7e970cc5b5992d8eb7ac649c247c62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77dee4d1ef01fa1c6c922c1a02b714f"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 1&gt; </td></tr>
<tr class="memitem:ad77dee4d1ef01fa1c6c922c1a02b714f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad77dee4d1ef01fa1c6c922c1a02b714f">operator==</a> (<a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:ad77dee4d1ef01fa1c6c922c1a02b714f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd71b3ab7f409fd7b42ffc2c484988dc"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 2&gt; </td></tr>
<tr class="memitem:abd71b3ab7f409fd7b42ffc2c484988dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abd71b3ab7f409fd7b42ffc2c484988dc">operator==</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:abd71b3ab7f409fd7b42ffc2c484988dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75a10e3bbd7b95eda40943d83c2c213"><td class="memTemplParams" colspan="2">template&lt;typename CharType , typename Traits &gt; </td></tr>
<tr class="memitem:ac75a10e3bbd7b95eda40943d83c2c213"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac75a10e3bbd7b95eda40943d83c2c213">operator!=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ac75a10e3bbd7b95eda40943d83c2c213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="namespaceetl.html#ac75a10e3bbd7b95eda40943d83c2c213">More...</a><br /></td></tr>
<tr class="separator:ac75a10e3bbd7b95eda40943d83c2c213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c2dfd4d9e60efce84621bd3f0c999e"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 1&gt; </td></tr>
<tr class="memitem:a37c2dfd4d9e60efce84621bd3f0c999e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a37c2dfd4d9e60efce84621bd3f0c999e">operator!=</a> (<a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a37c2dfd4d9e60efce84621bd3f0c999e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef3d7d5a76fc9b4082213e704c87090"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 2&gt; </td></tr>
<tr class="memitem:adef3d7d5a76fc9b4082213e704c87090"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adef3d7d5a76fc9b4082213e704c87090">operator!=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:adef3d7d5a76fc9b4082213e704c87090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5e98d445c114716af566d56c8846de"><td class="memTemplParams" colspan="2">template&lt;typename CharType , typename Traits &gt; </td></tr>
<tr class="memitem:adc5e98d445c114716af566d56c8846de"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adc5e98d445c114716af566d56c8846de">operator&lt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:adc5e98d445c114716af566d56c8846de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="namespaceetl.html#adc5e98d445c114716af566d56c8846de">More...</a><br /></td></tr>
<tr class="separator:adc5e98d445c114716af566d56c8846de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365ed56c7fa37151b60b488d437a542c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 1&gt; </td></tr>
<tr class="memitem:a365ed56c7fa37151b60b488d437a542c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a365ed56c7fa37151b60b488d437a542c">operator&lt;</a> (<a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a365ed56c7fa37151b60b488d437a542c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86fc574bc6418a5aa73bc9b7189d679"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 2&gt; </td></tr>
<tr class="memitem:ac86fc574bc6418a5aa73bc9b7189d679"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac86fc574bc6418a5aa73bc9b7189d679">operator&lt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:ac86fc574bc6418a5aa73bc9b7189d679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda576b0bc560a8f6d7fe3ab07ee4f80"><td class="memTemplParams" colspan="2">template&lt;typename CharType , typename Traits &gt; </td></tr>
<tr class="memitem:aeda576b0bc560a8f6d7fe3ab07ee4f80"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aeda576b0bc560a8f6d7fe3ab07ee4f80">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:aeda576b0bc560a8f6d7fe3ab07ee4f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="namespaceetl.html#aeda576b0bc560a8f6d7fe3ab07ee4f80">More...</a><br /></td></tr>
<tr class="separator:aeda576b0bc560a8f6d7fe3ab07ee4f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d0745dca782dc6ccaf69298ab6a977"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 1&gt; </td></tr>
<tr class="memitem:ad3d0745dca782dc6ccaf69298ab6a977"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad3d0745dca782dc6ccaf69298ab6a977">operator&lt;=</a> (<a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:ad3d0745dca782dc6ccaf69298ab6a977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac858c75276a00249c96cc27219347c3d"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 2&gt; </td></tr>
<tr class="memitem:ac858c75276a00249c96cc27219347c3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac858c75276a00249c96cc27219347c3d">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:ac858c75276a00249c96cc27219347c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a16921121279f4b613b0c0228f839b"><td class="memTemplParams" colspan="2">template&lt;typename CharType , typename Traits &gt; </td></tr>
<tr class="memitem:ae5a16921121279f4b613b0c0228f839b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae5a16921121279f4b613b0c0228f839b">operator&gt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ae5a16921121279f4b613b0c0228f839b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="namespaceetl.html#ae5a16921121279f4b613b0c0228f839b">More...</a><br /></td></tr>
<tr class="separator:ae5a16921121279f4b613b0c0228f839b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafacaaf3ec66f2ff780382a0d1b00c76"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 1&gt; </td></tr>
<tr class="memitem:aafacaaf3ec66f2ff780382a0d1b00c76"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aafacaaf3ec66f2ff780382a0d1b00c76">operator&gt;</a> (<a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:aafacaaf3ec66f2ff780382a0d1b00c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbf42135bafe3381b402f1f8c229ef3"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 2&gt; </td></tr>
<tr class="memitem:a7bbf42135bafe3381b402f1f8c229ef3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7bbf42135bafe3381b402f1f8c229ef3">operator&gt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a7bbf42135bafe3381b402f1f8c229ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8245ad8d38c37448fb6f2b289695f3"><td class="memTemplParams" colspan="2">template&lt;typename CharType , typename Traits &gt; </td></tr>
<tr class="memitem:a1e8245ad8d38c37448fb6f2b289695f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1e8245ad8d38c37448fb6f2b289695f3">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a1e8245ad8d38c37448fb6f2b289695f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="namespaceetl.html#a1e8245ad8d38c37448fb6f2b289695f3">More...</a><br /></td></tr>
<tr class="separator:a1e8245ad8d38c37448fb6f2b289695f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1d78ef0edb2cbc80128926a2cf5873"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 1&gt; </td></tr>
<tr class="memitem:a0c1d78ef0edb2cbc80128926a2cf5873"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0c1d78ef0edb2cbc80128926a2cf5873">operator&gt;=</a> (<a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a0c1d78ef0edb2cbc80128926a2cf5873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261e1e937423beeae22afbe45b8e0579"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , int  = 2&gt; </td></tr>
<tr class="memitem:a261e1e937423beeae22afbe45b8e0579"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a261e1e937423beeae22afbe45b8e0579">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt; rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a261e1e937423beeae22afbe45b8e0579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9ad17f89aa026ee52417e1a98d119c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1string__view__literals.html#aae9ad17f89aa026ee52417e1a98d119c">operator&quot;&quot;_sv</a> (char const *str, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> len) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a></td></tr>
<tr class="memdesc:aae9ad17f89aa026ee52417e1a98d119c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a string view of a character literal. Returns <a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da" title="Typedefs for common character type.">etl::string_view</a>{str, len}.  <a href="namespaceetl_1_1literals_1_1string__view__literals.html#aae9ad17f89aa026ee52417e1a98d119c">More...</a><br /></td></tr>
<tr class="separator:aae9ad17f89aa026ee52417e1a98d119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974fb6faa222ecb40a59180647ccb79d"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Tuple &gt; </td></tr>
<tr class="memitem:a974fb6faa222ecb40a59180647ccb79d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a974fb6faa222ecb40a59180647ccb79d">apply</a> (F &amp;&amp;f, Tuple &amp;&amp;t) -&gt; decltype(auto)</td></tr>
<tr class="separator:a974fb6faa222ecb40a59180647ccb79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed3d4879ef8b1df2012935a3022f720"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a0ed3d4879ef8b1df2012935a3022f720"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0ed3d4879ef8b1df2012935a3022f720">forward_as_tuple</a> (Types &amp;&amp;... args) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt; Types &amp;&amp;... &gt;</td></tr>
<tr class="memdesc:a0ed3d4879ef8b1df2012935a3022f720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function. The tuple has rvalue reference data members when rvalues are used as arguments, and otherwise has lvalue reference data members.  <a href="namespaceetl.html#a0ed3d4879ef8b1df2012935a3022f720">More...</a><br /></td></tr>
<tr class="separator:a0ed3d4879ef8b1df2012935a3022f720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722cde6b61e815e5a032f34f922c3e99"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a722cde6b61e815e5a032f34f922c3e99"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a722cde6b61e815e5a032f34f922c3e99">make_from_tuple</a> (Tuple &amp;&amp;t) -&gt; T</td></tr>
<tr class="separator:a722cde6b61e815e5a032f34f922c3e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e0097403ec5f189d1192cca821a7e4"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:aa7e0097403ec5f189d1192cca821a7e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa7e0097403ec5f189d1192cca821a7e4">make_tuple</a> (Types &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa7e0097403ec5f189d1192cca821a7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tuple object, deducing the target type from the types of arguments.  <a href="namespaceetl.html#aa7e0097403ec5f189d1192cca821a7e4">More...</a><br /></td></tr>
<tr class="separator:aa7e0097403ec5f189d1192cca821a7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3ddae955d45b6a63298906227f2f60"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ada3ddae955d45b6a63298906227f2f60"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ada3ddae955d45b6a63298906227f2f60">tie</a> (Args &amp;... args) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Args &amp;... &gt;</td></tr>
<tr class="separator:ada3ddae955d45b6a63298906227f2f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7332293756222129bddd488f2be46c89"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a7332293756222129bddd488f2be46c89"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7332293756222129bddd488f2be46c89">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;t) -&gt; auto &amp;</td></tr>
<tr class="separator:a7332293756222129bddd488f2be46c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3910901935da4bd1aa0404bb8e4344cd"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a3910901935da4bd1aa0404bb8e4344cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3910901935da4bd1aa0404bb8e4344cd">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; const &amp;t) -&gt; auto const &amp;</td></tr>
<tr class="separator:a3910901935da4bd1aa0404bb8e4344cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d05954af24fa3a51c81a56eac04b53"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a44d05954af24fa3a51c81a56eac04b53"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a44d05954af24fa3a51c81a56eac04b53">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;&amp;t) -&gt; auto &amp;&amp;</td></tr>
<tr class="separator:a44d05954af24fa3a51c81a56eac04b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca389dd668b413db5163594031d441dc"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:aca389dd668b413db5163594031d441dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aca389dd668b413db5163594031d441dc">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; const &amp;&amp;t) -&gt; auto const &amp;&amp;</td></tr>
<tr class="separator:aca389dd668b413db5163594031d441dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308b29ca423e2fd99cd291d2f7ac00af"><td class="memTemplParams" colspan="2">template&lt;etl::tuple_like... Tuples&gt; </td></tr>
<tr class="memitem:a308b29ca423e2fd99cd291d2f7ac00af"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a308b29ca423e2fd99cd291d2f7ac00af">tuple_cat</a> (Tuples &amp;&amp;... ts)</td></tr>
<tr class="separator:a308b29ca423e2fd99cd291d2f7ac00af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1c3baeebc248b3f787a308af595c6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0a1c3baeebc248b3f787a308af595c6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0a1c3baeebc248b3f787a308af595c6a">swap</a> (T &amp;a, T &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; void</td></tr>
<tr class="separator:a0a1c3baeebc248b3f787a308af595c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a1a97135d4a41771948063bd8c3a90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27a1a97135d4a41771948063bd8c3a90"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a> () <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a1498f004a367863b7b1b4f0f8ca3f75d">etl::add_rvalue_reference_t</a>&lt; T &gt;</td></tr>
<tr class="separator:a27a1a97135d4a41771948063bd8c3a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b9b4f72a823403539ecfc03192012e"><td class="memTemplParams" colspan="2">template&lt;typename Rhs , Rhs R, typename Lhs , Lhs L&gt; </td></tr>
<tr class="memitem:a57b9b4f72a823403539ecfc03192012e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a57b9b4f72a823403539ecfc03192012e">operator+</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Rhs, R &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Lhs, L &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; decltype(L+R), L+R &gt;</td></tr>
<tr class="separator:a57b9b4f72a823403539ecfc03192012e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b41a63ce6030e00a502be9c802192dc"><td class="memTemplParams" colspan="2">template&lt;typename Rhs , Rhs R, typename Lhs , Lhs L&gt; </td></tr>
<tr class="memitem:a9b41a63ce6030e00a502be9c802192dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9b41a63ce6030e00a502be9c802192dc">operator==</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Rhs, R &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Lhs, L &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; bool, L==R &gt;</td></tr>
<tr class="separator:a9b41a63ce6030e00a502be9c802192dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043a792e889d30e7160364a8a4670297"><td class="memTemplParams" colspan="2">template&lt;typename Rhs , Rhs R, typename Lhs , Lhs L&gt; </td></tr>
<tr class="memitem:a043a792e889d30e7160364a8a4670297"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a043a792e889d30e7160364a8a4670297">operator!=</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Rhs, R &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Lhs, L &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; bool, L !=R &gt;</td></tr>
<tr class="separator:a043a792e889d30e7160364a8a4670297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec5c14f53ef79e0b6debfffb6ce947f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4ec5c14f53ef79e0b6debfffb6ce947f">is_constant_evaluated</a> () <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a4ec5c14f53ef79e0b6debfffb6ce947f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false.  <a href="namespaceetl.html#a4ec5c14f53ef79e0b6debfffb6ce947f">More...</a><br /></td></tr>
<tr class="separator:a4ec5c14f53ef79e0b6debfffb6ce947f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2a8839b0088ceabc861e39e5a15daa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d2a8839b0088ceabc861e39e5a15daa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5d2a8839b0088ceabc861e39e5a15daa">test_implicit_default_constructible</a> (T)</td></tr>
<tr class="separator:a5d2a8839b0088ceabc861e39e5a15daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904a2454aba7d55b9ff9918d3ca2bc23"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a904a2454aba7d55b9ff9918d3ca2bc23"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a904a2454aba7d55b9ff9918d3ca2bc23">requires</a> (<a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v</a>&lt; T &gt; &amp;&amp;<a class="el" href="namespaceetl.html#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v</a>&lt; T &gt;) const expr auto <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5">swap</a>(T &amp;a</td></tr>
<tr class="separator:a904a2454aba7d55b9ff9918d3ca2bc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa798c4fa78e6eaade4cdaf8e42ae8f7f"><td class="memItemLeft" align="right" valign="top">T &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa798c4fa78e6eaade4cdaf8e42ae8f7f">noexcept</a> (<a class="el" href="namespaceetl.html#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; &amp;&amp;<a class="el" href="namespaceetl.html#ab5d18b577003e8d090a82e4c6d497cdd">etl::is_nothrow_move_assignable_v</a>&lt; T &gt;) -&gt; void</td></tr>
<tr class="separator:aa798c4fa78e6eaade4cdaf8e42ae8f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ba91687b857ba136bf8979ce65352b"><td class="memTemplParams" colspan="2">template&lt;typename T , etl::size_t N&gt; </td></tr>
<tr class="memitem:a53ba91687b857ba136bf8979ce65352b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a53ba91687b857ba136bf8979ce65352b">requires</a> (<a class="el" href="structetl_1_1is__swappable.html">etl::is_swappable</a>&lt; T &gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) const expr auto <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5">swap</a>(T(&amp;a)[N]</td></tr>
<tr class="separator:a53ba91687b857ba136bf8979ce65352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa180d468fdf2378d57e100ab2bd37ccc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa180d468fdf2378d57e100ab2bd37ccc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa180d468fdf2378d57e100ab2bd37ccc">as_const</a> (T &amp;t) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a06fe98569e6409cac789c54e1e563996">add_const_t</a>&lt; T &gt; &amp;</td></tr>
<tr class="memdesc:aa180d468fdf2378d57e100ab2bd37ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms lvalue reference to const type of t.  <a href="namespaceetl.html#aa180d468fdf2378d57e100ab2bd37ccc">More...</a><br /></td></tr>
<tr class="separator:aa180d468fdf2378d57e100ab2bd37ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467b2ed1f8f9d51ceb6786d6f6cd2c1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a467b2ed1f8f9d51ceb6786d6f6cd2c1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a467b2ed1f8f9d51ceb6786d6f6cd2c1d">as_const</a> (T const &amp;&amp;) -&gt; void=delete</td></tr>
<tr class="separator:a467b2ed1f8f9d51ceb6786d6f6cd2c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba6712de4c274105b7757d5ff5c256d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a2ba6712de4c274105b7757d5ff5c256d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt; T, U &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2ba6712de4c274105b7757d5ff5c256d">cmp_equal</a> (T t, U u) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a2ba6712de4c274105b7757d5ff5c256d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="namespaceetl.html#a2ba6712de4c274105b7757d5ff5c256d">More...</a><br /></td></tr>
<tr class="separator:a2ba6712de4c274105b7757d5ff5c256d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991d919ce72e4c7cacc0d985e362e851"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a991d919ce72e4c7cacc0d985e362e851"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt; T, U &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a991d919ce72e4c7cacc0d985e362e851">cmp_greater</a> (T t, U u) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a991d919ce72e4c7cacc0d985e362e851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="namespaceetl.html#a991d919ce72e4c7cacc0d985e362e851">More...</a><br /></td></tr>
<tr class="separator:a991d919ce72e4c7cacc0d985e362e851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e082a5290e35758ae6b74054087ca05"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a8e082a5290e35758ae6b74054087ca05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt; T, U &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8e082a5290e35758ae6b74054087ca05">cmp_greater_equal</a> (T t, U u) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a8e082a5290e35758ae6b74054087ca05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="namespaceetl.html#a8e082a5290e35758ae6b74054087ca05">More...</a><br /></td></tr>
<tr class="separator:a8e082a5290e35758ae6b74054087ca05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4f3be26a45d1c5877e4b4bbfafe7e1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a8d4f3be26a45d1c5877e4b4bbfafe7e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt; T, U &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8d4f3be26a45d1c5877e4b4bbfafe7e1">cmp_less</a> (T t, U u) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a8d4f3be26a45d1c5877e4b4bbfafe7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="namespaceetl.html#a8d4f3be26a45d1c5877e4b4bbfafe7e1">More...</a><br /></td></tr>
<tr class="separator:a8d4f3be26a45d1c5877e4b4bbfafe7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa6045b488bf1c8d79050b3e3179907"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aaaa6045b488bf1c8d79050b3e3179907"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt; T, U &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaaa6045b488bf1c8d79050b3e3179907">cmp_less_equal</a> (T t, U u) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:aaaa6045b488bf1c8d79050b3e3179907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="namespaceetl.html#aaaa6045b488bf1c8d79050b3e3179907">More...</a><br /></td></tr>
<tr class="separator:aaaa6045b488bf1c8d79050b3e3179907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c1257280c7c023cf896d46505a27ae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac3c1257280c7c023cf896d46505a27ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt; T, U &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac3c1257280c7c023cf896d46505a27ae">cmp_not_equal</a> (T t, U u) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ac3c1257280c7c023cf896d46505a27ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="namespaceetl.html#ac3c1257280c7c023cf896d46505a27ae">More...</a><br /></td></tr>
<tr class="separator:ac3c1257280c7c023cf896d46505a27ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab9c512cd288c92340c8a957b3742fe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = T&gt; </td></tr>
<tr class="memitem:abab9c512cd288c92340c8a957b3742fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abab9c512cd288c92340c8a957b3742fe">exchange</a> (T &amp;obj, U &amp;&amp;newValue) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; and <a class="el" href="namespaceetl.html#a865b2c54ee24d227ee6f222e49fd076c">etl::is_nothrow_assignable_v</a>&lt; T &amp;, U &gt;) -&gt; T</td></tr>
<tr class="memdesc:abab9c512cd288c92340c8a957b3742fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the value of obj with new_value and returns the old value of obj.  <a href="namespaceetl.html#abab9c512cd288c92340c8a957b3742fe">More...</a><br /></td></tr>
<tr class="separator:abab9c512cd288c92340c8a957b3742fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed541bafacdd55b5d4bd723e6b9bb91f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed541bafacdd55b5d4bd723e6b9bb91f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aed541bafacdd55b5d4bd723e6b9bb91f">forward</a> (<a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt; T &gt; &amp;param) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T &amp;&amp;</td></tr>
<tr class="memdesc:aed541bafacdd55b5d4bd723e6b9bb91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards lvalues as either lvalues or as rvalues, depending on T. When t is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function.  <a href="namespaceetl.html#aed541bafacdd55b5d4bd723e6b9bb91f">More...</a><br /></td></tr>
<tr class="separator:aed541bafacdd55b5d4bd723e6b9bb91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7788668573df04d891d55b5433f6e49b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7788668573df04d891d55b5433f6e49b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7788668573df04d891d55b5433f6e49b">forward</a> (<a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt; T &gt; &amp;&amp;param) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; T &amp;&amp;</td></tr>
<tr class="separator:a7788668573df04d891d55b5433f6e49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb59d3fc5e1767148b6803b4b3a1ba4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9eb59d3fc5e1767148b6803b4b3a1ba4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9eb59d3fc5e1767148b6803b4b3a1ba4">forward_like</a> (U &amp;&amp;x) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; auto &amp;&amp;</td></tr>
<tr class="separator:a9eb59d3fc5e1767148b6803b4b3a1ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f77e77ccc84d294f2108336b590d8ea"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:a4f77e77ccc84d294f2108336b590d8ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::integer_and_not_char&lt; T &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4f77e77ccc84d294f2108336b590d8ea">in_range</a> (T t) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a4f77e77ccc84d294f2108336b590d8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the value of t is in the range of values that can be represented in R, that is, if t can be converted to R without data loss.  <a href="namespaceetl.html#a4f77e77ccc84d294f2108336b590d8ea">More...</a><br /></td></tr>
<tr class="separator:a4f77e77ccc84d294f2108336b590d8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c81fb3d2e0ae2e41e87e2381bd9776a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c81fb3d2e0ae2e41e87e2381bd9776a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4c81fb3d2e0ae2e41e87e2381bd9776a">move</a> (T &amp;&amp;t) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">etl::remove_reference_t</a>&lt; T &gt; &amp;&amp;</td></tr>
<tr class="memdesc:a4c81fb3d2e0ae2e41e87e2381bd9776a"><td class="mdescLeft">&#160;</td><td class="mdescRight">move is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type.  <a href="namespaceetl.html#a4c81fb3d2e0ae2e41e87e2381bd9776a">More...</a><br /></td></tr>
<tr class="separator:a4c81fb3d2e0ae2e41e87e2381bd9776a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd2f9cfbab270ff115707284d5c73a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afdd2f9cfbab270ff115707284d5c73a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afdd2f9cfbab270ff115707284d5c73a7">move_if_noexcept</a> (T &amp;x) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">etl::conditional_t</a>&lt;!<a class="el" href="namespaceetl.html#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; and <a class="el" href="namespaceetl.html#a045ef39158833b2ba6592fa8a1d0ebc1">etl::is_copy_constructible_v</a>&lt; T &gt;, T const &amp;, T &amp;&amp; &gt;</td></tr>
<tr class="memdesc:afdd2f9cfbab270ff115707284d5c73a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally convert a value to an rvalue.  <a href="namespaceetl.html#afdd2f9cfbab270ff115707284d5c73a7">More...</a><br /></td></tr>
<tr class="separator:afdd2f9cfbab270ff115707284d5c73a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eed856cd0d950a984b3f7b4bed78b4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a53eed856cd0d950a984b3f7b4bed78b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a53eed856cd0d950a984b3f7b4bed78b4">pair</a> (T1, T2) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt;</td></tr>
<tr class="separator:a53eed856cd0d950a984b3f7b4bed78b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa50aa68713ac9f56128ad9c0406b737"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aaa50aa68713ac9f56128ad9c0406b737"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaa50aa68713ac9f56128ad9c0406b737">swap</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(<a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>(lhs.swap(rhs))) -&gt; void</td></tr>
<tr class="memdesc:aaa50aa68713ac9f56128ad9c0406b737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of x and y. Equivalent to x.swap(y).  <a href="namespaceetl.html#aaa50aa68713ac9f56128ad9c0406b737">More...</a><br /></td></tr>
<tr class="separator:aaa50aa68713ac9f56128ad9c0406b737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481d5f0f3c183fc9d7407e1275c3040d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a481d5f0f3c183fc9d7407e1275c3040d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a481d5f0f3c183fc9d7407e1275c3040d">make_pair</a> (T1 &amp;&amp;t, T2 &amp;&amp;u) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; T1 &gt;, <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; T2 &gt;&gt;</td></tr>
<tr class="memdesc:a481d5f0f3c183fc9d7407e1275c3040d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> object, deducing the target type from the types of arguments.  <a href="namespaceetl.html#a481d5f0f3c183fc9d7407e1275c3040d">More...</a><br /></td></tr>
<tr class="separator:a481d5f0f3c183fc9d7407e1275c3040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca122149a06ebd4ab08b8ed486df0198"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aca122149a06ebd4ab08b8ed486df0198"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aca122149a06ebd4ab08b8ed486df0198">operator==</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:aca122149a06ebd4ab08b8ed486df0198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second.  <a href="namespaceetl.html#aca122149a06ebd4ab08b8ed486df0198">More...</a><br /></td></tr>
<tr class="separator:aca122149a06ebd4ab08b8ed486df0198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30eb6d42bd94db249c6bb61f3b07ca8b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a30eb6d42bd94db249c6bb61f3b07ca8b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a30eb6d42bd94db249c6bb61f3b07ca8b">operator&lt;</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a30eb6d42bd94db249c6bb61f3b07ca8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <a href="namespaceetl.html#a30eb6d42bd94db249c6bb61f3b07ca8b">More...</a><br /></td></tr>
<tr class="separator:a30eb6d42bd94db249c6bb61f3b07ca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880fb1e1ee9736f911f931c4f10e4a1c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a880fb1e1ee9736f911f931c4f10e4a1c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a880fb1e1ee9736f911f931c4f10e4a1c">operator&lt;=</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a880fb1e1ee9736f911f931c4f10e4a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <a href="namespaceetl.html#a880fb1e1ee9736f911f931c4f10e4a1c">More...</a><br /></td></tr>
<tr class="separator:a880fb1e1ee9736f911f931c4f10e4a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc0b3aadb4525efaf31a9e8d62acc46"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9fc0b3aadb4525efaf31a9e8d62acc46"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9fc0b3aadb4525efaf31a9e8d62acc46">operator&gt;</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a9fc0b3aadb4525efaf31a9e8d62acc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <a href="namespaceetl.html#a9fc0b3aadb4525efaf31a9e8d62acc46">More...</a><br /></td></tr>
<tr class="separator:a9fc0b3aadb4525efaf31a9e8d62acc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110f9b6f4b39272ee65e708330f7905a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a110f9b6f4b39272ee65e708330f7905a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a110f9b6f4b39272ee65e708330f7905a">operator&gt;=</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a110f9b6f4b39272ee65e708330f7905a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <a href="namespaceetl.html#a110f9b6f4b39272ee65e708330f7905a">More...</a><br /></td></tr>
<tr class="separator:a110f9b6f4b39272ee65e708330f7905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd61172cf5e65c895a94de9f3c4f079e"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:abd61172cf5e65c895a94de9f3c4f079e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abd61172cf5e65c895a94de9f3c4f079e">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;p) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a700f0f867c8a351c79de3b290004521e">tuple_element_t</a>&lt; I, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt;&gt; &amp;</td></tr>
<tr class="memdesc:abd61172cf5e65c895a94de9f3c4f079e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <a href="namespaceetl.html#abd61172cf5e65c895a94de9f3c4f079e">More...</a><br /></td></tr>
<tr class="separator:abd61172cf5e65c895a94de9f3c4f079e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af679f67dbe70cc1109b995b1c7527580"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af679f67dbe70cc1109b995b1c7527580"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af679f67dbe70cc1109b995b1c7527580">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;p) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a700f0f867c8a351c79de3b290004521e">tuple_element_t</a>&lt; I, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt;&gt; const &amp;</td></tr>
<tr class="memdesc:af679f67dbe70cc1109b995b1c7527580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <a href="namespaceetl.html#af679f67dbe70cc1109b995b1c7527580">More...</a><br /></td></tr>
<tr class="separator:af679f67dbe70cc1109b995b1c7527580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02233890b8c93586b3d951747142ee8a"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a02233890b8c93586b3d951747142ee8a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a02233890b8c93586b3d951747142ee8a">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;&amp;p) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a700f0f867c8a351c79de3b290004521e">tuple_element_t</a>&lt; I, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt;&gt; &amp;&amp;</td></tr>
<tr class="memdesc:a02233890b8c93586b3d951747142ee8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <a href="namespaceetl.html#a02233890b8c93586b3d951747142ee8a">More...</a><br /></td></tr>
<tr class="separator:a02233890b8c93586b3d951747142ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd73ffe592700a8dda59dfeae41e9c9"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aabd73ffe592700a8dda59dfeae41e9c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aabd73ffe592700a8dda59dfeae41e9c9">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&amp;p) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a700f0f867c8a351c79de3b290004521e">tuple_element_t</a>&lt; I, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt;&gt; const &amp;&amp;</td></tr>
<tr class="memdesc:aabd73ffe592700a8dda59dfeae41e9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <a href="namespaceetl.html#aabd73ffe592700a8dda59dfeae41e9c9">More...</a><br /></td></tr>
<tr class="separator:aabd73ffe592700a8dda59dfeae41e9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039de8a03db5998c4a426dcb8a99768b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a039de8a03db5998c4a426dcb8a99768b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a039de8a03db5998c4a426dcb8a99768b">requires</a> (<a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v</a>&lt; T &gt; and <a class="el" href="namespaceetl.html#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v</a>&lt; T &gt;) const expr auto <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5">swap</a>(T &amp;a</td></tr>
<tr class="memdesc:a039de8a03db5998c4a426dcb8a99768b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="namespaceetl.html#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v&lt;T&gt;</a> is true.  <a href="namespaceetl.html#a039de8a03db5998c4a426dcb8a99768b">More...</a><br /></td></tr>
<tr class="separator:a039de8a03db5998c4a426dcb8a99768b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4048788ac43f56fd533a797c2af698e5"><td class="memItemLeft" align="right" valign="top">T &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4048788ac43f56fd533a797c2af698e5">noexcept</a> (<a class="el" href="namespaceetl.html#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; and <a class="el" href="namespaceetl.html#ab5d18b577003e8d090a82e4c6d497cdd">etl::is_nothrow_move_assignable_v</a>&lt; T &gt;) -&gt; void</td></tr>
<tr class="separator:a4048788ac43f56fd533a797c2af698e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb415a657944fa6c433f795fdb3a0b6"><td class="memTemplParams" colspan="2">template&lt;typename T , etl::size_t N&gt; </td></tr>
<tr class="memitem:a9bb415a657944fa6c433f795fdb3a0b6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9bb415a657944fa6c433f795fdb3a0b6">requires</a> (<a class="el" href="namespaceetl.html#a46cb1671f31576cce07cf1bac1e99f7c">etl::is_swappable_v</a>&lt; T &gt;) const expr auto <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5">swap</a>(T(&amp;a)[N]</td></tr>
<tr class="separator:a9bb415a657944fa6c433f795fdb3a0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81467d3810ee7b1ebc9c41ebd6941a1"><td class="memTemplParams" colspan="2">template&lt;typename Enum &gt; </td></tr>
<tr class="memitem:ad81467d3810ee7b1ebc9c41ebd6941a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad81467d3810ee7b1ebc9c41ebd6941a1">to_underlying</a> (Enum e) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a49061e75c4b48962719493fb046259e2">underlying_type_t</a>&lt; Enum &gt;</td></tr>
<tr class="memdesc:ad81467d3810ee7b1ebc9c41ebd6941a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an enumeration to its underlying type.  <a href="namespaceetl.html#ad81467d3810ee7b1ebc9c41ebd6941a1">More...</a><br /></td></tr>
<tr class="separator:ad81467d3810ee7b1ebc9c41ebd6941a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaf10daac93eed1add86c6ca8317c29"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#addaf10daac93eed1add86c6ca8317c29">unreachable</a> () -&gt; void</td></tr>
<tr class="separator:addaf10daac93eed1add86c6ca8317c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4805fd3b0cdc0a1a3db6475f16708849"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4805fd3b0cdc0a1a3db6475f16708849">operator==</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a4805fd3b0cdc0a1a3db6475f16708849"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal.  <a href="namespaceetl.html#a4805fd3b0cdc0a1a3db6475f16708849">More...</a><br /></td></tr>
<tr class="separator:a4805fd3b0cdc0a1a3db6475f16708849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde631d12e3fa3eadef0726f8a1218ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abde631d12e3fa3eadef0726f8a1218ec">operator!=</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:abde631d12e3fa3eadef0726f8a1218ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal.  <a href="namespaceetl.html#abde631d12e3fa3eadef0726f8a1218ec">More...</a><br /></td></tr>
<tr class="separator:abde631d12e3fa3eadef0726f8a1218ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d6295f5e016b5d4473335bb3bdc056"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad3d6295f5e016b5d4473335bb3bdc056">operator&lt;</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ad3d6295f5e016b5d4473335bb3bdc056"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal.  <a href="namespaceetl.html#ad3d6295f5e016b5d4473335bb3bdc056">More...</a><br /></td></tr>
<tr class="separator:ad3d6295f5e016b5d4473335bb3bdc056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e919d889b1cffc2fe30748064be47d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae7e919d889b1cffc2fe30748064be47d">operator&gt;</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ae7e919d889b1cffc2fe30748064be47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal.  <a href="namespaceetl.html#ae7e919d889b1cffc2fe30748064be47d">More...</a><br /></td></tr>
<tr class="separator:ae7e919d889b1cffc2fe30748064be47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e6f06421ee1d47e10ac411d5266606"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a15e6f06421ee1d47e10ac411d5266606">operator&lt;=</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a15e6f06421ee1d47e10ac411d5266606"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal.  <a href="namespaceetl.html#a15e6f06421ee1d47e10ac411d5266606">More...</a><br /></td></tr>
<tr class="separator:a15e6f06421ee1d47e10ac411d5266606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9427318b650a4b9bc68d9c363e7b6a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3c9427318b650a4b9bc68d9c363e7b6a">operator&gt;=</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a3c9427318b650a4b9bc68d9c363e7b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal.  <a href="namespaceetl.html#a3c9427318b650a4b9bc68d9c363e7b6a">More...</a><br /></td></tr>
<tr class="separator:a3c9427318b650a4b9bc68d9c363e7b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3b824f87ab3ce98ad82b777b551b2d"><td class="memTemplParams" colspan="2">template&lt;typename... Functor&gt; </td></tr>
<tr class="memitem:abd3b824f87ab3ce98ad82b777b551b2d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abd3b824f87ab3ce98ad82b777b551b2d">overload</a> (Functor...) -&gt; <a class="el" href="structetl_1_1overload.html">overload</a>&lt; Functor... &gt;</td></tr>
<tr class="separator:abd3b824f87ab3ce98ad82b777b551b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127a9420152769a476a9e4820580c807"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a127a9420152769a476a9e4820580c807"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a127a9420152769a476a9e4820580c807">requires</a> (detail::enable_variant_swap&lt; Ts... &gt;) const expr auto <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5">swap</a>(<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a></td></tr>
<tr class="memdesc:a127a9420152769a476a9e4820580c807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the swap algorithm for variant. Effectively calls lhs.swap(rhs).  <a href="namespaceetl.html#a127a9420152769a476a9e4820580c807">More...</a><br /></td></tr>
<tr class="separator:a127a9420152769a476a9e4820580c807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863041a1cb8498c8853e859e29367241"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a863041a1cb8498c8853e859e29367241"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a863041a1cb8498c8853e859e29367241">operator==</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a863041a1cb8498c8853e859e29367241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for variants:  <a href="namespaceetl.html#a863041a1cb8498c8853e859e29367241">More...</a><br /></td></tr>
<tr class="separator:a863041a1cb8498c8853e859e29367241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5ac4ee748bb8b9017c1a38e275a288"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:add5ac4ee748bb8b9017c1a38e275a288"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#add5ac4ee748bb8b9017c1a38e275a288">operator!=</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:add5ac4ee748bb8b9017c1a38e275a288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for variants:  <a href="namespaceetl.html#add5ac4ee748bb8b9017c1a38e275a288">More...</a><br /></td></tr>
<tr class="separator:add5ac4ee748bb8b9017c1a38e275a288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254c3da6eb0085b05cecc9c4c7586758"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a254c3da6eb0085b05cecc9c4c7586758"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a254c3da6eb0085b05cecc9c4c7586758">operator&lt;</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a254c3da6eb0085b05cecc9c4c7586758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator for variants:  <a href="namespaceetl.html#a254c3da6eb0085b05cecc9c4c7586758">More...</a><br /></td></tr>
<tr class="separator:a254c3da6eb0085b05cecc9c4c7586758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a1ddfed1011b3663a305e72aca1fe0"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a97a1ddfed1011b3663a305e72aca1fe0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a97a1ddfed1011b3663a305e72aca1fe0">operator&lt;=</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a97a1ddfed1011b3663a305e72aca1fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-equal operator for variants:  <a href="namespaceetl.html#a97a1ddfed1011b3663a305e72aca1fe0">More...</a><br /></td></tr>
<tr class="separator:a97a1ddfed1011b3663a305e72aca1fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe841983c5c96ec128c540e07d8ae590"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:afe841983c5c96ec128c540e07d8ae590"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afe841983c5c96ec128c540e07d8ae590">operator&gt;</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:afe841983c5c96ec128c540e07d8ae590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator for variants:  <a href="namespaceetl.html#afe841983c5c96ec128c540e07d8ae590">More...</a><br /></td></tr>
<tr class="separator:afe841983c5c96ec128c540e07d8ae590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46d330593ce07ddecb63c78618e1f73"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ae46d330593ce07ddecb63c78618e1f73"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae46d330593ce07ddecb63c78618e1f73">operator&gt;=</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ae46d330593ce07ddecb63c78618e1f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-equal operator for variants:  <a href="namespaceetl.html#ae46d330593ce07ddecb63c78618e1f73">More...</a><br /></td></tr>
<tr class="separator:ae46d330593ce07ddecb63c78618e1f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf81f6c62201f50e40031c362915e191"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:aaf81f6c62201f50e40031c362915e191"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaf81f6c62201f50e40031c362915e191">holds_alternative</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;v) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:aaf81f6c62201f50e40031c362915e191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the variant v holds the alternative T. The call is ill-formed if T does not appear exactly once in Ts...  <a href="namespaceetl.html#aaf81f6c62201f50e40031c362915e191">More...</a><br /></td></tr>
<tr class="separator:aaf81f6c62201f50e40031c362915e191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f35bc3fbdafc55d32dfd35bf1f7d446"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a7f35bc3fbdafc55d32dfd35bf1f7d446"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7f35bc3fbdafc55d32dfd35bf1f7d446">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;v) -&gt; auto &amp;</td></tr>
<tr class="memdesc:a7f35bc3fbdafc55d32dfd35bf1f7d446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <a href="namespaceetl.html#a7f35bc3fbdafc55d32dfd35bf1f7d446">More...</a><br /></td></tr>
<tr class="separator:a7f35bc3fbdafc55d32dfd35bf1f7d446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c84339b3f6aa69a3df586dc2a5b1f69"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a3c84339b3f6aa69a3df586dc2a5b1f69"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3c84339b3f6aa69a3df586dc2a5b1f69">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;v) -&gt; auto const &amp;</td></tr>
<tr class="memdesc:a3c84339b3f6aa69a3df586dc2a5b1f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <a href="namespaceetl.html#a3c84339b3f6aa69a3df586dc2a5b1f69">More...</a><br /></td></tr>
<tr class="separator:a3c84339b3f6aa69a3df586dc2a5b1f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54d98119a0f0e56078324af917a37e7"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:ab54d98119a0f0e56078324af917a37e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab54d98119a0f0e56078324af917a37e7">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;v) -&gt; auto &amp;&amp;</td></tr>
<tr class="memdesc:ab54d98119a0f0e56078324af917a37e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <a href="namespaceetl.html#ab54d98119a0f0e56078324af917a37e7">More...</a><br /></td></tr>
<tr class="separator:ab54d98119a0f0e56078324af917a37e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7502c4e6253168a35b9f80528d9264"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:abf7502c4e6253168a35b9f80528d9264"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abf7502c4e6253168a35b9f80528d9264">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&amp;v) -&gt; auto const &amp;&amp;</td></tr>
<tr class="memdesc:abf7502c4e6253168a35b9f80528d9264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <a href="namespaceetl.html#abf7502c4e6253168a35b9f80528d9264">More...</a><br /></td></tr>
<tr class="separator:abf7502c4e6253168a35b9f80528d9264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5756e54810f927e033e5cce195c7501e"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a5756e54810f927e033e5cce195c7501e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5756e54810f927e033e5cce195c7501e">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; *pv) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2ab42b86be16dbdbaa744a2caaca7e80">add_pointer_t</a>&lt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt; I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a5756e54810f927e033e5cce195c7501e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant.  <a href="namespaceetl.html#a5756e54810f927e033e5cce195c7501e">More...</a><br /></td></tr>
<tr class="separator:a5756e54810f927e033e5cce195c7501e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72842431b135e51894f5c6a7752cf12a"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a72842431b135e51894f5c6a7752cf12a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a72842431b135e51894f5c6a7752cf12a">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const *pv) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2ab42b86be16dbdbaa744a2caaca7e80">add_pointer_t</a>&lt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt; I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt;&gt; const &gt;</td></tr>
<tr class="memdesc:a72842431b135e51894f5c6a7752cf12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant.  <a href="namespaceetl.html#a72842431b135e51894f5c6a7752cf12a">More...</a><br /></td></tr>
<tr class="separator:a72842431b135e51894f5c6a7752cf12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a6d812774670ddf34c1d44f62e14ea"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a77a6d812774670ddf34c1d44f62e14ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a77a6d812774670ddf34c1d44f62e14ea">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;v) -&gt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt; I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt;&gt; &amp;</td></tr>
<tr class="memdesc:a77a6d812774670ddf34c1d44f62e14ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <a href="namespaceetl.html#a77a6d812774670ddf34c1d44f62e14ea">More...</a><br /></td></tr>
<tr class="separator:a77a6d812774670ddf34c1d44f62e14ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666956f74e899e9b7e1dbc505dbabfa1"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a666956f74e899e9b7e1dbc505dbabfa1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a666956f74e899e9b7e1dbc505dbabfa1">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;v) -&gt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt; I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt;&gt; &amp;&amp;</td></tr>
<tr class="memdesc:a666956f74e899e9b7e1dbc505dbabfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <a href="namespaceetl.html#a666956f74e899e9b7e1dbc505dbabfa1">More...</a><br /></td></tr>
<tr class="separator:a666956f74e899e9b7e1dbc505dbabfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31721b496f003097daaae13eed0e05a9"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a31721b496f003097daaae13eed0e05a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a31721b496f003097daaae13eed0e05a9">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;v) -&gt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt; I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt;&gt; const &amp;</td></tr>
<tr class="memdesc:a31721b496f003097daaae13eed0e05a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <a href="namespaceetl.html#a31721b496f003097daaae13eed0e05a9">More...</a><br /></td></tr>
<tr class="separator:a31721b496f003097daaae13eed0e05a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe303a47b99addb10aa27283e98e34e5"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:afe303a47b99addb10aa27283e98e34e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afe303a47b99addb10aa27283e98e34e5">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&amp;v) -&gt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt; I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt;&gt; const &amp;&amp;</td></tr>
<tr class="memdesc:afe303a47b99addb10aa27283e98e34e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <a href="namespaceetl.html#afe303a47b99addb10aa27283e98e34e5">More...</a><br /></td></tr>
<tr class="separator:afe303a47b99addb10aa27283e98e34e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4d75c3208d681357d77774b729444d"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a6f4d75c3208d681357d77774b729444d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6f4d75c3208d681357d77774b729444d">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;v) -&gt; auto &amp;</td></tr>
<tr class="separator:a6f4d75c3208d681357d77774b729444d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa90ac4a6cf3911ab23789c9af4d089"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:aeaa90ac4a6cf3911ab23789c9af4d089"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aeaa90ac4a6cf3911ab23789c9af4d089">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; const &amp;v) -&gt; auto const &amp;</td></tr>
<tr class="separator:aeaa90ac4a6cf3911ab23789c9af4d089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c39898b60620723d80247080de0439d"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a3c39898b60620723d80247080de0439d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3c39898b60620723d80247080de0439d">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;&amp;v) -&gt; auto &amp;&amp;</td></tr>
<tr class="separator:a3c39898b60620723d80247080de0439d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec2c2a52094776da58ed54719f0bcbd"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a9ec2c2a52094776da58ed54719f0bcbd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9ec2c2a52094776da58ed54719f0bcbd">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; const &amp;&amp;v) -&gt; auto const &amp;&amp;</td></tr>
<tr class="separator:a9ec2c2a52094776da58ed54719f0bcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffc9f0ae12737a221731fd43249e944"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:aeffc9f0ae12737a221731fd43249e944"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aeffc9f0ae12737a221731fd43249e944">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; *pv) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2ab42b86be16dbdbaa744a2caaca7e80">add_pointer_t</a>&lt; T &gt;</td></tr>
<tr class="separator:aeffc9f0ae12737a221731fd43249e944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dbeed267147923b02448b493be930d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a32dbeed267147923b02448b493be930d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a32dbeed267147923b02448b493be930d">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; const *pv) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="namespaceetl.html#a2ab42b86be16dbdbaa744a2caaca7e80">add_pointer_t</a>&lt; T const &gt;</td></tr>
<tr class="separator:a32dbeed267147923b02448b493be930d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43fcb4942d4cec1824f6e38edce9981"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Vs&gt; </td></tr>
<tr class="memitem:aa43fcb4942d4cec1824f6e38edce9981"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa43fcb4942d4cec1824f6e38edce9981">visit</a> (F &amp;&amp;f, Vs &amp;&amp;... vs)</td></tr>
<tr class="memdesc:aa43fcb4942d4cec1824f6e38edce9981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the visitor vis (Callable that can be called with any combination of types from variants) to the variants vars.  <a href="namespaceetl.html#aa43fcb4942d4cec1824f6e38edce9981">More...</a><br /></td></tr>
<tr class="separator:aa43fcb4942d4cec1824f6e38edce9981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c5f129858d55474d1d7ae92c374456"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:ac1c5f129858d55474d1d7ae92c374456"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac1c5f129858d55474d1d7ae92c374456">swap</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; void</td></tr>
<tr class="memdesc:ac1c5f129858d55474d1d7ae92c374456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">static_vector</a>. Swaps the contents of lhs and rhs.  <a href="namespaceetl.html#ac1c5f129858d55474d1d7ae92c374456">More...</a><br /></td></tr>
<tr class="separator:ac1c5f129858d55474d1d7ae92c374456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3aa3446aca179d812252faf83360c6"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:a9d3aa3446aca179d812252faf83360c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9d3aa3446aca179d812252faf83360c6">operator==</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a9d3aa3446aca179d812252faf83360c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors.  <a href="namespaceetl.html#a9d3aa3446aca179d812252faf83360c6">More...</a><br /></td></tr>
<tr class="separator:a9d3aa3446aca179d812252faf83360c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2867e9d12d25137a50a1b3aee3c5a7"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:a3d2867e9d12d25137a50a1b3aee3c5a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3d2867e9d12d25137a50a1b3aee3c5a7">operator!=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a3d2867e9d12d25137a50a1b3aee3c5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dfb93223a9c8e4413fe9368cd36046"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:ab0dfb93223a9c8e4413fe9368cd36046"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab0dfb93223a9c8e4413fe9368cd36046">operator&lt;</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:ab0dfb93223a9c8e4413fe9368cd36046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors.  <a href="namespaceetl.html#ab0dfb93223a9c8e4413fe9368cd36046">More...</a><br /></td></tr>
<tr class="separator:ab0dfb93223a9c8e4413fe9368cd36046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715395c53fa693969e269ef5af1972e6"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:a715395c53fa693969e269ef5af1972e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a715395c53fa693969e269ef5af1972e6">operator&lt;=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a715395c53fa693969e269ef5af1972e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fd2ea0cf33ad9339a54469a92f5121"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:ad4fd2ea0cf33ad9339a54469a92f5121"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad4fd2ea0cf33ad9339a54469a92f5121">operator&gt;</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:ad4fd2ea0cf33ad9339a54469a92f5121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf47ed021fd1e8bfbc389525967e551"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:aebf47ed021fd1e8bfbc389525967e551"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aebf47ed021fd1e8bfbc389525967e551">operator&gt;=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:aebf47ed021fd1e8bfbc389525967e551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6028d08459dc299edcae40876481fca"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity, typename Predicate &gt; </td></tr>
<tr class="memitem:ab6028d08459dc299edcae40876481fca"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab6028d08459dc299edcae40876481fca">erase_if</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; &amp;c, Predicate pred) -&gt; typename <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt;::size_type</td></tr>
<tr class="memdesc:ab6028d08459dc299edcae40876481fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate pred from the container.  <a href="namespaceetl.html#ab6028d08459dc299edcae40876481fca">More...</a><br /></td></tr>
<tr class="separator:ab6028d08459dc299edcae40876481fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eea328e45af7e2f0cba2ecf9bfae03e"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity, typename U &gt; </td></tr>
<tr class="memitem:a7eea328e45af7e2f0cba2ecf9bfae03e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7eea328e45af7e2f0cba2ecf9bfae03e">erase</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; &amp;c, U const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; typename <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt;::size_type</td></tr>
<tr class="separator:a7eea328e45af7e2f0cba2ecf9bfae03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b8bc94405a580d276749fde24834f7"><td class="memItemLeft" align="right" valign="top">consteval auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a47b8bc94405a580d276749fde24834f7">is_hosted</a> () <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a47b8bc94405a580d276749fde24834f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0643ba313eeb2da0a37a713fa74cb5f"><td class="memItemLeft" align="right" valign="top">consteval auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae0643ba313eeb2da0a37a713fa74cb5f">is_freestanding</a> () <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:ae0643ba313eeb2da0a37a713fa74cb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b353c6f122b14a8e9b78c453d8fa381"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7b353c6f122b14a8e9b78c453d8fa381">operator==</a> (<a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a7b353c6f122b14a8e9b78c453d8fa381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares language_standards.  <a href="namespaceetl.html#a7b353c6f122b14a8e9b78c453d8fa381">More...</a><br /></td></tr>
<tr class="separator:a7b353c6f122b14a8e9b78c453d8fa381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be806bd6b96b20e9313a7e398cc5783"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0be806bd6b96b20e9313a7e398cc5783">operator!=</a> (<a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a0be806bd6b96b20e9313a7e398cc5783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2e2b8ee1daac1fdf220e6aad21fbea"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afb2e2b8ee1daac1fdf220e6aad21fbea">operator&lt;</a> (<a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:afb2e2b8ee1daac1fdf220e6aad21fbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff7b111685f53a1a28d184323c9a7c3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6ff7b111685f53a1a28d184323c9a7c3">operator&lt;=</a> (<a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a6ff7b111685f53a1a28d184323c9a7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5748614e8daf5563998666a4584ee575"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5748614e8daf5563998666a4584ee575">operator&gt;</a> (<a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a5748614e8daf5563998666a4584ee575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00deb6a88953ac9fe457f6f79b347152"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a00deb6a88953ac9fe457f6f79b347152">operator&gt;=</a> (<a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="separator:a00deb6a88953ac9fe457f6f79b347152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce870bde6a96dc0634f235573439dd1"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:acce870bde6a96dc0634f235573439dd1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acce870bde6a96dc0634f235573439dd1">ignore_unused</a> (Types &amp;&amp;...) -&gt; void</td></tr>
<tr class="memdesc:acce870bde6a96dc0634f235573439dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly ignore arguments or variables.  <a href="namespaceetl.html#acce870bde6a96dc0634f235573439dd1">More...</a><br /></td></tr>
<tr class="separator:acce870bde6a96dc0634f235573439dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#ga09c5b412c05c58fb89e569a2d72ed17e">adjacent_find</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate pred) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p.  <a href="group__algorithm-header.html#ga09c5b412c05c58fb89e569a2d72ed17e">More...</a><br /></td></tr>
<tr class="separator:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe91c66e3042bde20710111a8d622e4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:ga4fe91c66e3042bde20710111a8d622e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#ga4fe91c66e3042bde20710111a8d622e4">adjacent_find</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>) -&gt; ForwardIt</td></tr>
<tr class="separator:ga4fe91c66e3042bde20710111a8d622e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gac76b028bf28233ada520a5bc0d52f6b9"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:gac76b028bf28233ada520a5bc0d52f6b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gac76b028bf28233ada520a5bc0d52f6b9">all_of</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:gac76b028bf28233ada520a5bc0d52f6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for all elements in the range <code>[first, last)</code>.  <a href="group__algorithm-header.html#gac76b028bf28233ada520a5bc0d52f6b9">More...</a><br /></td></tr>
<tr class="separator:gac76b028bf28233ada520a5bc0d52f6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga1d4122ca9a611ac90a64ff447c212a42"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga1d4122ca9a611ac90a64ff447c212a42"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#ga1d4122ca9a611ac90a64ff447c212a42">any_of</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:ga1d4122ca9a611ac90a64ff447c212a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for at least one element in the range <code>[first, last)</code>.  <a href="group__algorithm-header.html#ga1d4122ca9a611ac90a64ff447c212a42">More...</a><br /></td></tr>
<tr class="separator:ga1d4122ca9a611ac90a64ff447c212a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga8844708a6931fb2b21419d7a605328dd"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:ga8844708a6931fb2b21419d7a605328dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#ga8844708a6931fb2b21419d7a605328dd">binary_search</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:ga8844708a6931fb2b21419d7a605328dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an element equivalent to value appears within the range <code>[first, last)</code>. For binary_search to succeed, the range <code>[first, last)</code> must be at least partially ordered with respect to <code>value</code>.  <a href="group__algorithm-header.html#ga8844708a6931fb2b21419d7a605328dd">More...</a><br /></td></tr>
<tr class="separator:ga8844708a6931fb2b21419d7a605328dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb446f356892ac1d540180018a20faba"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:gadb446f356892ac1d540180018a20faba"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gadb446f356892ac1d540180018a20faba">binary_search</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; bool</td></tr>
<tr class="separator:gadb446f356892ac1d540180018a20faba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaf90379160c94dc0396b5f32204c790bf"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gaf90379160c94dc0396b5f32204c790bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gaf90379160c94dc0396b5f32204c790bf">clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Type const &amp;</td></tr>
<tr class="memdesc:gaf90379160c94dc0396b5f32204c790bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <a href="group__algorithm-header.html#gaf90379160c94dc0396b5f32204c790bf">More...</a><br /></td></tr>
<tr class="separator:gaf90379160c94dc0396b5f32204c790bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfa416a307b0bb33666d34845c42ba2b"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:gabfa416a307b0bb33666d34845c42ba2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gabfa416a307b0bb33666d34845c42ba2b">clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi, Compare comp) -&gt; Type const &amp;</td></tr>
<tr class="separator:gabfa416a307b0bb33666d34845c42ba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gad3271ee1abafc543f4bf69cc20b01ded"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:gad3271ee1abafc543f4bf69cc20b01ded"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gad3271ee1abafc543f4bf69cc20b01ded">copy</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:gad3271ee1abafc543f4bf69cc20b01ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <a href="group__algorithm-header.html#gad3271ee1abafc543f4bf69cc20b01ded">More...</a><br /></td></tr>
<tr class="separator:gad3271ee1abafc543f4bf69cc20b01ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaf5caeb0f954aff0eb31c350558f7e827"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt1 , typename BidirIt2 &gt; </td></tr>
<tr class="memitem:gaf5caeb0f954aff0eb31c350558f7e827"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gaf5caeb0f954aff0eb31c350558f7e827">copy_backward</a> (BidirIt1 first, BidirIt1 <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, BidirIt2 dLast) -&gt; BidirIt2</td></tr>
<tr class="memdesc:gaf5caeb0f954aff0eb31c350558f7e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range, defined by <code>[first, last)</code>, to another range ending at <code>dLast</code>. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved.  <a href="group__algorithm-header.html#gaf5caeb0f954aff0eb31c350558f7e827">More...</a><br /></td></tr>
<tr class="separator:gaf5caeb0f954aff0eb31c350558f7e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga31799054ecdf344760efe76af7987776"><td class="memTemplParams" colspan="2">template&lt;typename InIt , typename OutIt , typename Pred &gt; </td></tr>
<tr class="memitem:ga31799054ecdf344760efe76af7987776"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#ga31799054ecdf344760efe76af7987776">copy_if</a> (InIt first, InIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutIt dFirst, Pred pred) -&gt; OutIt</td></tr>
<tr class="memdesc:ga31799054ecdf344760efe76af7987776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <a href="group__algorithm-header.html#ga31799054ecdf344760efe76af7987776">More...</a><br /></td></tr>
<tr class="separator:ga31799054ecdf344760efe76af7987776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Size , typename OutputIt &gt; </td></tr>
<tr class="memitem:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gaa65063d9f87cd088156f3d49bb32f2e5">copy_n</a> (InputIt first, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>, OutputIt result) -&gt; OutputIt</td></tr>
<tr class="memdesc:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer <code>0 &lt;= i &lt; count</code>, performs <code>*(result + i) = *(first + i)</code>. Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results.  <a href="group__algorithm-header.html#gaa65063d9f87cd088156f3d49bb32f2e5">More...</a><br /></td></tr>
<tr class="separator:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga7aff5cc5281436a205079dc71ee4c317"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga7aff5cc5281436a205079dc71ee4c317"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#ga7aff5cc5281436a205079dc71ee4c317">count_if</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate p) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; InputIt &gt;::difference_type</td></tr>
<tr class="memdesc:ga7aff5cc5281436a205079dc71ee4c317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts elements for which predicate p returns true.  <a href="group__algorithm-header.html#ga7aff5cc5281436a205079dc71ee4c317">More...</a><br /></td></tr>
<tr class="separator:ga7aff5cc5281436a205079dc71ee4c317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af9b15653958e67cfe944d92826719780"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a></td></tr>
<tr class="separator:af9b15653958e67cfe944d92826719780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb63d88f3219c350ab03af8bd0adb5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedb63d88f3219c350ab03af8bd0adb5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aedb63d88f3219c350ab03af8bd0adb5a">is_bitmask_type_v</a> = <a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:aedb63d88f3219c350ab03af8bd0adb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef47ac360905d8fac28fb87847a855ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef47ac360905d8fac28fb87847a855ec"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aef47ac360905d8fac28fb87847a855ec">bitmask_type</a> = <a class="el" href="namespaceetl.html#aedb63d88f3219c350ab03af8bd0adb5a">is_bitmask_type_v</a>&lt;T&gt;</td></tr>
<tr class="separator:aef47ac360905d8fac28fb87847a855ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cc35f4fca27a07908f67b7ef595cd3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab8cc35f4fca27a07908f67b7ef595cd3">binary</a> = <a class="el" href="structetl_1_1binary__t.html">binary_t</a>{}</td></tr>
<tr class="separator:ab8cc35f4fca27a07908f67b7ef595cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5911bdc109e2c7265b7486da04e8b8"><td class="memItemLeft" align="right" valign="top">char const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a></td></tr>
<tr class="separator:a5d5911bdc109e2c7265b7486da04e8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c15a5d5f4ab487941035d024cad9d7"><td class="memItemLeft" align="right" valign="top">char const <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a51c15a5d5f4ab487941035d024cad9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a7c3cbcd306c97b268134f54e90d2d"><td class="memItemLeft" align="right" valign="top">char T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a></td></tr>
<tr class="separator:aa2a7c3cbcd306c97b268134f54e90d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299d1930276b590319d37b6b2afa6724"><td class="memItemLeft" align="right" valign="top">char T int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a></td></tr>
<tr class="separator:a299d1930276b590319d37b6b2afa6724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb8468ab3c13301477017cfc35f00ef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1bb8468ab3c13301477017cfc35f00ef"><td class="memTemplItemLeft" align="right" valign="top">requires&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> { typename <a class="el" href="namespaceetl.html#a076e8c592e28166b1126264966624b4b">compare_three_way_result_t</a>&lt;T, U&gt;</td></tr>
<tr class="separator:a1bb8468ab3c13301477017cfc35f00ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada667f9d8a054c2bcf73335fd257dbb8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cat  = partial_ordering&gt; </td></tr>
<tr class="memitem:ada667f9d8a054c2bcf73335fd257dbb8"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ada667f9d8a054c2bcf73335fd257dbb8">three_way_comparable</a></td></tr>
<tr class="separator:ada667f9d8a054c2bcf73335fd257dbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7816eb16d1037719f611bb94eb5d0807"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:a7816eb16d1037719f611bb94eb5d0807"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7816eb16d1037719f611bb94eb5d0807">assignable_from</a></td></tr>
<tr class="separator:a7816eb16d1037719f611bb94eb5d0807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d34c7f7f72c76ccd274e394e0db56e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00d34c7f7f72c76ccd274e394e0db56e"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a00d34c7f7f72c76ccd274e394e0db56e">boolean_testable</a></td></tr>
<tr class="separator:a00d34c7f7f72c76ccd274e394e0db56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e107a90f5ce06cb6af9b383b8012da"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a07e107a90f5ce06cb6af9b383b8012da"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a07e107a90f5ce06cb6af9b383b8012da">common_reference_with</a></td></tr>
<tr class="separator:a07e107a90f5ce06cb6af9b383b8012da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53091ecead3b4c698545fce2f1e73625"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a53091ecead3b4c698545fce2f1e73625"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a53091ecead3b4c698545fce2f1e73625">common_with</a></td></tr>
<tr class="separator:a53091ecead3b4c698545fce2f1e73625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecaacd8370f16b3d1697b918cd279e0a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aecaacd8370f16b3d1697b918cd279e0a"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aecaacd8370f16b3d1697b918cd279e0a">constructible_from</a> = <a class="el" href="namespaceetl.html#aa7807b04c3fd1dcd899cbfbac85435cc">destructible</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#a1ab616d6855ca5fc60968a153587b2b4">is_constructible_v</a>&lt;T, Args...&gt;</td></tr>
<tr class="memdesc:aecaacd8370f16b3d1697b918cd279e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructible_from concept specifies that a variable of type T can be initialized with the given set of argument types Args....  <a href="namespaceetl.html#aecaacd8370f16b3d1697b918cd279e0a">More...</a><br /></td></tr>
<tr class="separator:aecaacd8370f16b3d1697b918cd279e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93b0ea62659b41252c66e6152b0b4b2"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:ac93b0ea62659b41252c66e6152b0b4b2"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac93b0ea62659b41252c66e6152b0b4b2">convertible_to</a> = <a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">etl::is_convertible_v</a>&lt;From, To&gt; and <a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(<a class="el" href="namespaceetl.html#a1498f004a367863b7b1b4f0f8ca3f75d">etl::add_rvalue_reference_t</a>&lt;From&gt; (&amp;f)()) { static_cast&lt;To&gt;(f()); }</td></tr>
<tr class="memdesc:ac93b0ea62659b41252c66e6152b0b4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept convertible_to&lt;From, To&gt; specifies that an expression of the same type and value category as those of <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval&lt;From&gt;()</a> can be implicitly and explicitly converted to the type To, and the two forms of conversion are equivalent.  <a href="namespaceetl.html#ac93b0ea62659b41252c66e6152b0b4b2">More...</a><br /></td></tr>
<tr class="separator:ac93b0ea62659b41252c66e6152b0b4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae025789c49d242b8b45203bfbbf8f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ae025789c49d242b8b45203bfbbf8f4"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5ae025789c49d242b8b45203bfbbf8f4">copy_constructible</a></td></tr>
<tr class="memdesc:a5ae025789c49d242b8b45203bfbbf8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept copy_constructible is satisfied if T is an lvalue reference type, or if it is a move_constructible object type where an object of that type can constructed from a (possibly const) lvalue or const rvalue of that type in both direct- and copy-initialization contexts with the usual semantics (a copy is constructed with the source unchanged).  <a href="namespaceetl.html#a5ae025789c49d242b8b45203bfbbf8f4">More...</a><br /></td></tr>
<tr class="separator:a5ae025789c49d242b8b45203bfbbf8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf9593cd813280528b9bbb0c68f4f45"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cf9593cd813280528b9bbb0c68f4f45"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6cf9593cd813280528b9bbb0c68f4f45">copyable</a></td></tr>
<tr class="separator:a6cf9593cd813280528b9bbb0c68f4f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaca15276a2469cb69859e7917e42a22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaca15276a2469cb69859e7917e42a22"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adaca15276a2469cb69859e7917e42a22">default_initializable</a></td></tr>
<tr class="memdesc:adaca15276a2469cb69859e7917e42a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default_initializable concept checks whether variables of type T can be value-initialized (T() is well-formed); direct-list-initialized from an empty initializer list (T{} is well-formed); and default-initialized (T t; is well-formed). Access checking is performed as if in a context unrelated to T. Only the validity of the immediate context of the variable initialization is considered.  <a href="namespaceetl.html#adaca15276a2469cb69859e7917e42a22">More...</a><br /></td></tr>
<tr class="separator:adaca15276a2469cb69859e7917e42a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cb104089116b2bcb2d946c5cdf0f7d"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Base &gt; </td></tr>
<tr class="memitem:a70cb104089116b2bcb2d946c5cdf0f7d"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a70cb104089116b2bcb2d946c5cdf0f7d">derived_from</a> = <a class="el" href="namespaceetl.html#af00bab8d0b02bcb2974969b9d69639bb">is_base_of_v</a>&lt;Base, Derived&gt; &amp;&amp; <a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">is_convertible_v</a>&lt;Derived const volatile*, Base const volatile*&gt;</td></tr>
<tr class="memdesc:a70cb104089116b2bcb2d946c5cdf0f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept derived_from&lt;Derived, Base&gt; is satisfied if and only if Base is a class type that is either Derived or a public and unambiguous base of Derived, ignoring cv-qualifiers. Note that this behaviour is different to <a class="el" href="structetl_1_1is__base__of.html" title="If Derived is derived from Base or if both are the same non-union class (in both cases ignoring cv-qu...">is_base_of</a> when Base is a private or protected base of Derived.  <a href="namespaceetl.html#a70cb104089116b2bcb2d946c5cdf0f7d">More...</a><br /></td></tr>
<tr class="separator:a70cb104089116b2bcb2d946c5cdf0f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7807b04c3fd1dcd899cbfbac85435cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7807b04c3fd1dcd899cbfbac85435cc"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa7807b04c3fd1dcd899cbfbac85435cc">destructible</a> = <a class="el" href="namespaceetl.html#a92bb068a979f4237eb8c218d4f0112f2">etl::is_nothrow_destructible_v</a>&lt;T&gt;</td></tr>
<tr class="memdesc:aa7807b04c3fd1dcd899cbfbac85435cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept destructible specifies the concept of all types whose instances can safely be destroyed at the end of their lifetime (including reference types).  <a href="namespaceetl.html#aa7807b04c3fd1dcd899cbfbac85435cc">More...</a><br /></td></tr>
<tr class="separator:aa7807b04c3fd1dcd899cbfbac85435cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afdd392b306391331437406550d4ef5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1afdd392b306391331437406550d4ef5"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1afdd392b306391331437406550d4ef5">equality_comparable</a> = <a class="el" href="namespaceetl.html#ada002bf896bcbba39f049225a8d45aef">weakly_equality_comparable_with</a>&lt;T, T&gt;</td></tr>
<tr class="separator:a1afdd392b306391331437406550d4ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add53beec16093e42cbbdf40a0b38cabf"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , typename U &gt; </td></tr>
<tr class="memitem:add53beec16093e42cbbdf40a0b38cabf"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#add53beec16093e42cbbdf40a0b38cabf">equivalence_relation</a> = <a class="el" href="namespaceetl.html#a2dc9fe932ba829e5e6f72998c2afb631">relation</a>&lt;R, T, U&gt;</td></tr>
<tr class="separator:add53beec16093e42cbbdf40a0b38cabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db737b5a4dfad876c197c1aca7c5139"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7db737b5a4dfad876c197c1aca7c5139"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7db737b5a4dfad876c197c1aca7c5139">floating_point</a> = <a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt;T&gt;</td></tr>
<tr class="memdesc:a7db737b5a4dfad876c197c1aca7c5139"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept floating_point&lt;T&gt; is satisfied if and only if T is a floating-point type.  <a href="namespaceetl.html#a7db737b5a4dfad876c197c1aca7c5139">More...</a><br /></td></tr>
<tr class="separator:a7db737b5a4dfad876c197c1aca7c5139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4daf60f1f070c94586efbcf55d6e84f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4daf60f1f070c94586efbcf55d6e84f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac4daf60f1f070c94586efbcf55d6e84f">integral</a> = <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt;T&gt;</td></tr>
<tr class="memdesc:ac4daf60f1f070c94586efbcf55d6e84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept integral&lt;T&gt; is satisfied if and only if T is an integral type.  <a href="namespaceetl.html#ac4daf60f1f070c94586efbcf55d6e84f">More...</a><br /></td></tr>
<tr class="separator:ac4daf60f1f070c94586efbcf55d6e84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988da8950eef9f43c6613375c4153129"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Args&gt; </td></tr>
<tr class="memitem:a988da8950eef9f43c6613375c4153129"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a988da8950eef9f43c6613375c4153129">invocable</a> = <a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(F&amp;&amp; f, Args&amp;&amp;... args) { <a class="el" href="namespaceetl.html#a0bd726a99d25fb6e96ef3527de8a0164">etl::invoke</a>(<a class="el" href="forward_8hpp.html#a2d576f2c39bf49da4909a2a497671e6e">TETL_FORWARD</a>(f), <a class="el" href="forward_8hpp.html#a2d576f2c39bf49da4909a2a497671e6e">TETL_FORWARD</a>(args)...); }</td></tr>
<tr class="separator:a988da8950eef9f43c6613375c4153129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6b96f07b8ee5033e7e669fd72e5494"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f6b96f07b8ee5033e7e669fd72e5494"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4f6b96f07b8ee5033e7e669fd72e5494">movable</a> = <a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">is_object_v</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#a08dbf06561db5c1d6165c94862e9a232">move_constructible</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#a7816eb16d1037719f611bb94eb5d0807">assignable_from</a>&lt;T&amp;, T&gt; and <a class="el" href="namespaceetl.html#abc3d55874cfd650688465099bef5a51c">swappable</a>&lt;T&gt;</td></tr>
<tr class="separator:a4f6b96f07b8ee5033e7e669fd72e5494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dbf06561db5c1d6165c94862e9a232"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a08dbf06561db5c1d6165c94862e9a232"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a08dbf06561db5c1d6165c94862e9a232">move_constructible</a> = <a class="el" href="namespaceetl.html#aecaacd8370f16b3d1697b918cd279e0a">constructible_from</a>&lt;T, T&gt; &amp;&amp; <a class="el" href="namespaceetl.html#ac93b0ea62659b41252c66e6152b0b4b2">convertible_to</a>&lt;T, T&gt;</td></tr>
<tr class="memdesc:a08dbf06561db5c1d6165c94862e9a232"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept move_constructible is satisfied if T is a reference type, or if it is an object type where an object of that type can be constructed from an rvalue of that type in both direct- and copy-initialization contexts, with the usual semantics.  <a href="namespaceetl.html#a08dbf06561db5c1d6165c94862e9a232">More...</a><br /></td></tr>
<tr class="separator:a08dbf06561db5c1d6165c94862e9a232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf1991d2ce684016a8e3a756021fa38"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Args&gt; </td></tr>
<tr class="memitem:a3cf1991d2ce684016a8e3a756021fa38"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3cf1991d2ce684016a8e3a756021fa38">predicate</a> = <a class="el" href="namespaceetl.html#a4870b0eff355f370c20bccb8a28cebe8">regular_invocable</a>&lt;F, Args...&gt; and <a class="el" href="namespaceetl.html#a00d34c7f7f72c76ccd274e394e0db56e">boolean_testable</a>&lt;<a class="el" href="namespaceetl.html#a93ed3feabd9624cf09aa604f49155cc2">invoke_result_t</a>&lt;F, Args...&gt;&gt;</td></tr>
<tr class="separator:a3cf1991d2ce684016a8e3a756021fa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abefe210f09c67ad5c66f7492b1a98e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2abefe210f09c67ad5c66f7492b1a98e"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2abefe210f09c67ad5c66f7492b1a98e">regular</a> = <a class="el" href="namespaceetl.html#a2fd176827c6247549c03a4dd19731a01">etl::semiregular</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#a1afdd392b306391331437406550d4ef5">etl::equality_comparable</a>&lt;T&gt;</td></tr>
<tr class="separator:a2abefe210f09c67ad5c66f7492b1a98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4870b0eff355f370c20bccb8a28cebe8"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Args&gt; </td></tr>
<tr class="memitem:a4870b0eff355f370c20bccb8a28cebe8"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4870b0eff355f370c20bccb8a28cebe8">regular_invocable</a> = <a class="el" href="namespaceetl.html#a988da8950eef9f43c6613375c4153129">etl::invocable</a>&lt;F, Args...&gt;</td></tr>
<tr class="separator:a4870b0eff355f370c20bccb8a28cebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc9fe932ba829e5e6f72998c2afb631"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , typename U &gt; </td></tr>
<tr class="memitem:a2dc9fe932ba829e5e6f72998c2afb631"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2dc9fe932ba829e5e6f72998c2afb631">relation</a> = <a class="el" href="namespaceetl.html#a3cf1991d2ce684016a8e3a756021fa38">predicate</a>&lt;R, T, T&gt; and <a class="el" href="namespaceetl.html#a3cf1991d2ce684016a8e3a756021fa38">predicate</a>&lt;R, U, U&gt; and <a class="el" href="namespaceetl.html#a3cf1991d2ce684016a8e3a756021fa38">predicate</a>&lt;R, T, U&gt; and <a class="el" href="namespaceetl.html#a3cf1991d2ce684016a8e3a756021fa38">predicate</a>&lt;R, U, T&gt;</td></tr>
<tr class="separator:a2dc9fe932ba829e5e6f72998c2afb631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa602e717add57122f28f5186a8399a87"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa602e717add57122f28f5186a8399a87"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa602e717add57122f28f5186a8399a87">same_as</a> = detail::same_helper&lt;T, U&gt; and detail::same_helper&lt;U, T&gt;</td></tr>
<tr class="memdesc:aa602e717add57122f28f5186a8399a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept same_as&lt;T, U&gt; is satisfied if and only if T and U denote the same type. same_as&lt;T, U&gt; subsumes same_as&lt;U, T&gt; and vice versa.  <a href="namespaceetl.html#aa602e717add57122f28f5186a8399a87">More...</a><br /></td></tr>
<tr class="separator:aa602e717add57122f28f5186a8399a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd176827c6247549c03a4dd19731a01"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2fd176827c6247549c03a4dd19731a01"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2fd176827c6247549c03a4dd19731a01">semiregular</a> = <a class="el" href="namespaceetl.html#a6cf9593cd813280528b9bbb0c68f4f45">etl::copyable</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#adaca15276a2469cb69859e7917e42a22">etl::default_initializable</a>&lt;T&gt;</td></tr>
<tr class="separator:a2fd176827c6247549c03a4dd19731a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eadc31af2a7472602cfc3929a0914f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4eadc31af2a7472602cfc3929a0914f0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4eadc31af2a7472602cfc3929a0914f0">signed_integral</a> = <a class="el" href="namespaceetl.html#ac4daf60f1f070c94586efbcf55d6e84f">etl::integral</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#aff3fadd2a1e349c45f524ab5444220ff">etl::is_signed_v</a>&lt;T&gt;</td></tr>
<tr class="memdesc:a4eadc31af2a7472602cfc3929a0914f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept signed_integral&lt;T&gt; is satisfied if and only if T is an integral type and is_signed_v&lt;T&gt; is true.  <a href="namespaceetl.html#a4eadc31af2a7472602cfc3929a0914f0">More...</a><br /></td></tr>
<tr class="separator:a4eadc31af2a7472602cfc3929a0914f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f3b6a3010a0611d77648f91f3ccdf7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6f3b6a3010a0611d77648f91f3ccdf7"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac6f3b6a3010a0611d77648f91f3ccdf7">standard_integer</a> = <a class="el" href="namespaceetl.html#ad52ae3e71a7e5954830504af2048ed7d">is_standard_integer_v</a>&lt;T&gt;</td></tr>
<tr class="separator:ac6f3b6a3010a0611d77648f91f3ccdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadad383df2f67b95302958dd5c9322c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aadad383df2f67b95302958dd5c9322c7"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aadad383df2f67b95302958dd5c9322c7">standard_signed_integer</a> = <a class="el" href="namespaceetl.html#ab19a5f05a129870f874303571c11da48">is_standard_signed_integer_v</a>&lt;T&gt;</td></tr>
<tr class="separator:aadad383df2f67b95302958dd5c9322c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf98855f87500a0c8e475a82dc1cabe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abdf98855f87500a0c8e475a82dc1cabe"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abdf98855f87500a0c8e475a82dc1cabe">standard_unsigned_integer</a> = <a class="el" href="namespaceetl.html#a4881471dda8be900e4d183c9a413f66c">is_standard_unsigned_integer_v</a>&lt;T&gt;</td></tr>
<tr class="separator:abdf98855f87500a0c8e475a82dc1cabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29d579cd21c6e393409132a0019316b"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , typename U &gt; </td></tr>
<tr class="memitem:af29d579cd21c6e393409132a0019316b"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af29d579cd21c6e393409132a0019316b">strict_weak_order</a> = <a class="el" href="namespaceetl.html#a2dc9fe932ba829e5e6f72998c2afb631">relation</a>&lt;R, T, U&gt;</td></tr>
<tr class="separator:af29d579cd21c6e393409132a0019316b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3d55874cfd650688465099bef5a51c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc3d55874cfd650688465099bef5a51c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abc3d55874cfd650688465099bef5a51c">swappable</a></td></tr>
<tr class="separator:abc3d55874cfd650688465099bef5a51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dae8aa2c733dd84d9b8f15d79528bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41dae8aa2c733dd84d9b8f15d79528bb"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a41dae8aa2c733dd84d9b8f15d79528bb">unsigned_integral</a> = <a class="el" href="namespaceetl.html#ac4daf60f1f070c94586efbcf55d6e84f">etl::integral</a>&lt;T&gt; &amp;&amp; <a class="el" href="namespaceetl.html#a3bbd05dc09b68b19c63d7b4fbf6f1108">etl::is_unsigned_v</a>&lt;T&gt;</td></tr>
<tr class="memdesc:a41dae8aa2c733dd84d9b8f15d79528bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept unsigned_integral&lt;T&gt; is satisfied if and only if T is an integral type and is_unsigned_v&lt;T&gt; is true.  <a href="namespaceetl.html#a41dae8aa2c733dd84d9b8f15d79528bb">More...</a><br /></td></tr>
<tr class="separator:a41dae8aa2c733dd84d9b8f15d79528bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada002bf896bcbba39f049225a8d45aef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ada002bf896bcbba39f049225a8d45aef"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ada002bf896bcbba39f049225a8d45aef">weakly_equality_comparable_with</a></td></tr>
<tr class="separator:ada002bf896bcbba39f049225a8d45aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d957fa8529e9617c445e42519518e5e"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="attributes_8hpp.html#a6cf990edeb7f9f6f1b5928471cef5e56">TETL_MAY_ALIAS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">byte</a></td></tr>
<tr class="memdesc:a1d957fa8529e9617c445e42519518e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a> is a distinct type that implements the concept of byte as specified in the C++ language definition.  <a href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">More...</a><br /></td></tr>
<tr class="separator:a1d957fa8529e9617c445e42519518e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2932a67109d86a3d3414866785f19613"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2932a67109d86a3d3414866785f19613">unexpect</a> = <a class="el" href="structetl_1_1unexpect__t.html">unexpect_t</a>{}</td></tr>
<tr class="separator:a2932a67109d86a3d3414866785f19613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3206db2ddd4b49017ef0d257ca69a515"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3206db2ddd4b49017ef0d257ca69a515">sorted_unique</a> = <a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a>{}</td></tr>
<tr class="separator:a3206db2ddd4b49017ef0d257ca69a515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ecf4e1b001cdba463b17849f4b55e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5ecf4e1b001cdba463b17849f4b55e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad5ecf4e1b001cdba463b17849f4b55e4">is_placeholder_v</a> = <a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:ad5ecf4e1b001cdba463b17849f4b55e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212bf7be37c4b9bdf1328f042486b384"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a212bf7be37c4b9bdf1328f042486b384"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a212bf7be37c4b9bdf1328f042486b384">incrementable</a></td></tr>
<tr class="separator:a212bf7be37c4b9bdf1328f042486b384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b6c2ea4f13089ede1a42514f87e6c6"><td class="memItemLeft" align="right" valign="top">T const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a></td></tr>
<tr class="separator:a18b6c2ea4f13089ede1a42514f87e6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c276f2e1f0ad19e9311b62769978acc"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a9c276f2e1f0ad19e9311b62769978acc"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9c276f2e1f0ad19e9311b62769978acc">input_or_output_iterator</a></td></tr>
<tr class="separator:a9c276f2e1f0ad19e9311b62769978acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9960486cb35efd439dc700529983a6d3"><td class="memTemplParams" colspan="2">template&lt;typename S , typename Iter &gt; </td></tr>
<tr class="memitem:a9960486cb35efd439dc700529983a6d3"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9960486cb35efd439dc700529983a6d3">sentinel_for</a> = <a class="el" href="namespaceetl.html#a2fd176827c6247549c03a4dd19731a01">semiregular</a>&lt;S&gt; and <a class="el" href="namespaceetl.html#a9c276f2e1f0ad19e9311b62769978acc">input_or_output_iterator</a>&lt;Iter&gt; and <a class="el" href="namespaceetl.html#ada002bf896bcbba39f049225a8d45aef">weakly_equality_comparable_with</a>&lt;S, Iter&gt;</td></tr>
<tr class="separator:a9960486cb35efd439dc700529983a6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadd2b30864294d4537931e8d9835b94"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:acadd2b30864294d4537931e8d9835b94"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acadd2b30864294d4537931e8d9835b94">weakly_incrementable</a></td></tr>
<tr class="separator:acadd2b30864294d4537931e8d9835b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751416861268d9328aa2a7263fd85e1b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a751416861268d9328aa2a7263fd85e1b">full_extent</a> = <a class="el" href="structetl_1_1full__extent__t.html">full_extent_t</a>{}</td></tr>
<tr class="separator:a751416861268d9328aa2a7263fd85e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceb01bf8ef98fb9e5817d452798b6c1"><td class="memItemLeft" align="right" valign="top">Integrals&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8ceb01bf8ef98fb9e5817d452798b6c1">mdspan&lt; ElementType, dextents&lt; size_t, sizeof...(Integrals)&gt; &gt;</a></td></tr>
<tr class="separator:a8ceb01bf8ef98fb9e5817d452798b6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fea0e76b0257b8f9ffbca0b6de6aaa"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a74fea0e76b0257b8f9ffbca0b6de6aaa">allocator_arg</a> {}</td></tr>
<tr class="memdesc:a74fea0e76b0257b8f9ffbca0b6de6aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator_arg is a constant of type <a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects.  <a href="namespaceetl.html#a74fea0e76b0257b8f9ffbca0b6de6aaa">More...</a><br /></td></tr>
<tr class="separator:a74fea0e76b0257b8f9ffbca0b6de6aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cf19d8af06969d839fa909ad6e184f"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Alloc &gt; </td></tr>
<tr class="memitem:a16cf19d8af06969d839fa909ad6e184f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a16cf19d8af06969d839fa909ad6e184f">uses_allocator_v</a> = <a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a>&lt;Type, Alloc&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="memdesc:a16cf19d8af06969d839fa909ad6e184f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false.  <a href="namespaceetl.html#a16cf19d8af06969d839fa909ad6e184f">More...</a><br /></td></tr>
<tr class="separator:a16cf19d8af06969d839fa909ad6e184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9e177fde5dc55ea58bb3771c37051a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structetl_1_1defer__lock__t.html">defer_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3e9e177fde5dc55ea58bb3771c37051a">defer_lock</a> {}</td></tr>
<tr class="memdesc:a3e9e177fde5dc55ea58bb3771c37051a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of empty struct tag types. See <a class="el" href="structetl_1_1defer__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">defer_lock_t</a>.  <a href="namespaceetl.html#a3e9e177fde5dc55ea58bb3771c37051a">More...</a><br /></td></tr>
<tr class="separator:a3e9e177fde5dc55ea58bb3771c37051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086e79db17e8b72ae86d834fad514b2e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structetl_1_1try__to__lock__t.html">try_to_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a086e79db17e8b72ae86d834fad514b2e">try_to_lock</a> {}</td></tr>
<tr class="memdesc:a086e79db17e8b72ae86d834fad514b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of empty struct tag types. See <a class="el" href="structetl_1_1try__to__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">try_to_lock_t</a>.  <a href="namespaceetl.html#a086e79db17e8b72ae86d834fad514b2e">More...</a><br /></td></tr>
<tr class="separator:a086e79db17e8b72ae86d834fad514b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ee00292ff760cd8ecf8b41bb4de696"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structetl_1_1adopt__lock__t.html">adopt_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a03ee00292ff760cd8ecf8b41bb4de696">adopt_lock</a> {}</td></tr>
<tr class="memdesc:a03ee00292ff760cd8ecf8b41bb4de696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of empty struct tag types. See <a class="el" href="structetl_1_1adopt__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">adopt_lock_t</a>.  <a href="namespaceetl.html#a03ee00292ff760cd8ecf8b41bb4de696">More...</a><br /></td></tr>
<tr class="separator:a03ee00292ff760cd8ecf8b41bb4de696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7234bd8fd6d2e05055093f7a4bb53d7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac7234bd8fd6d2e05055093f7a4bb53d7">destroying_delete</a> = <a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a>{}</td></tr>
<tr class="memdesc:ac7234bd8fd6d2e05055093f7a4bb53d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type used to identify the destroying delete form of operator delete.  <a href="namespaceetl.html#ac7234bd8fd6d2e05055093f7a4bb53d7">More...</a><br /></td></tr>
<tr class="separator:ac7234bd8fd6d2e05055093f7a4bb53d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ecb067c83bfce58af4f03457f15c8c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a20ecb067c83bfce58af4f03457f15c8c">hardware_constructive_interference_size</a> = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td></tr>
<tr class="memdesc:a20ecb067c83bfce58af4f03457f15c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum offset between two objects to avoid false sharing. Guaranteed to be at least alignof(max_align_t).  <a href="namespaceetl.html#a20ecb067c83bfce58af4f03457f15c8c">More...</a><br /></td></tr>
<tr class="separator:a20ecb067c83bfce58af4f03457f15c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc217ae19afd481b0993696cbb1729bf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abc217ae19afd481b0993696cbb1729bf">hardware_destructive_interference_size</a> = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td></tr>
<tr class="memdesc:abc217ae19afd481b0993696cbb1729bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of contiguous memory to promote true sharing. Guaranteed to be at least alignof(max_align_t).  <a href="namespaceetl.html#abc217ae19afd481b0993696cbb1729bf">More...</a><br /></td></tr>
<tr class="separator:abc217ae19afd481b0993696cbb1729bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1ead4c5ac981fe88bcd71d1aba1d61"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8a1ead4c5ac981fe88bcd71d1aba1d61">nothrow</a> = <a class="el" href="structetl_1_1nothrow__t.html">etl::nothrow_t</a>{}</td></tr>
<tr class="memdesc:a8a1ead4c5ac981fe88bcd71d1aba1d61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#a8a1ead4c5ac981fe88bcd71d1aba1d61" title="etl::nothrow is a constant of type etl::nothrow_t used to disambiguate the overloads of throwing and ...">etl::nothrow</a> is a constant of type <a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> used to disambiguate the overloads of throwing and non-throwing allocation functions.  <a href="namespaceetl.html#a8a1ead4c5ac981fe88bcd71d1aba1d61">More...</a><br /></td></tr>
<tr class="separator:a8a1ead4c5ac981fe88bcd71d1aba1d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab7a2b5df589ee0db680c5833896d8e"><td class="memItemLeft" align="right" valign="top">N n&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7ab7a2b5df589ee0db680c5833896d8e">common_type_t&lt; M, N &gt;</a></td></tr>
<tr class="separator:a7ab7a2b5df589ee0db680c5833896d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f837bf0258547b23e4f04e4d03e6d1"><td class="memItemLeft" align="right" valign="top">Int <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a> <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a></td></tr>
<tr class="separator:af4f837bf0258547b23e4f04e4d03e6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acb4483c815a6504bcca76ca33d7d0f"><td class="memItemLeft" align="right" valign="top">auto const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3acb4483c815a6504bcca76ca33d7d0f">shift</a> = static_cast&lt;UInt&gt;(<a class="el" href="structetl_1_1numeric__limits.html">etl::numeric_limits</a>&lt;UInt&gt;::digits - 1)</td></tr>
<tr class="separator:a3acb4483c815a6504bcca76ca33d7d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5310f602316cea39c9b7d3b6101a47d"><td class="memItemLeft" align="right" valign="top">auto const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab5310f602316cea39c9b7d3b6101a47d">diff</a> = static_cast&lt;UInt&gt;(UInt(<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) - UInt(a))</td></tr>
<tr class="separator:ab5310f602316cea39c9b7d3b6101a47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2e8cf3fb3b9b4fe2e13ae866510ced"><td class="memItemLeft" align="right" valign="top">auto const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2e2e8cf3fb3b9b4fe2e13ae866510ced">sign</a> = static_cast&lt;UInt&gt;(<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a> &lt; a)</td></tr>
<tr class="separator:a2e2e8cf3fb3b9b4fe2e13ae866510ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a2fbfa8f64e7bebc363cd78c4d6660"><td class="memItemLeft" align="right" valign="top">auto const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad5a2fbfa8f64e7bebc363cd78c4d6660">half</a> = static_cast&lt;UInt&gt;((<a class="el" href="namespaceetl.html#ab5310f602316cea39c9b7d3b6101a47d">diff</a> / 2) + (<a class="el" href="namespaceetl.html#a2e2e8cf3fb3b9b4fe2e13ae866510ced">sign</a> &lt;&lt; <a class="el" href="namespaceetl.html#a3acb4483c815a6504bcca76ca33d7d0f">shift</a>) + (<a class="el" href="namespaceetl.html#a2e2e8cf3fb3b9b4fe2e13ae866510ced">sign</a> &amp; <a class="el" href="namespaceetl.html#ab5310f602316cea39c9b7d3b6101a47d">diff</a>))</td></tr>
<tr class="separator:ad5a2fbfa8f64e7bebc363cd78c4d6660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d7a7601aedf2ce125a34a9d83b80a7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a93d7a7601aedf2ce125a34a9d83b80a7">nullopt</a> = <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>{{}}</td></tr>
<tr class="memdesc:a93d7a7601aedf2ce125a34a9d83b80a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#a93d7a7601aedf2ce125a34a9d83b80a7" title="etl::nullopt is a constant of type etl::nullopt_t that is used to indicate optional type with uniniti...">etl::nullopt</a> is a constant of type <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">etl::nullopt_t</a> that is used to indicate optional type with uninitialized state.  <a href="namespaceetl.html#a93d7a7601aedf2ce125a34a9d83b80a7">More...</a><br /></td></tr>
<tr class="separator:a93d7a7601aedf2ce125a34a9d83b80a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717a065b4d593697dc186ca84f51ffb8"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a717a065b4d593697dc186ca84f51ffb8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a717a065b4d593697dc186ca84f51ffb8">ratio_equal_v</a> = <a class="el" href="structetl_1_1ratio__equal.html">ratio_equal</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a717a065b4d593697dc186ca84f51ffb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce653ddb9ec91f96bda7e292725dc0e"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:abce653ddb9ec91f96bda7e292725dc0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abce653ddb9ec91f96bda7e292725dc0e">ratio_greater_v</a> = <a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:abce653ddb9ec91f96bda7e292725dc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed208c9b18aabc1288d0721225be488"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a1ed208c9b18aabc1288d0721225be488"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1ed208c9b18aabc1288d0721225be488">ratio_greater_equal_v</a> = <a class="el" href="structetl_1_1ratio__greater__equal.html">ratio_greater_equal</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a1ed208c9b18aabc1288d0721225be488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d7dd3cfa6494a27aaf40f11ec60b62"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:aa8d7dd3cfa6494a27aaf40f11ec60b62"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa8d7dd3cfa6494a27aaf40f11ec60b62">ratio_less_v</a> = <a class="el" href="structetl_1_1ratio__less.html">ratio_less</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:aa8d7dd3cfa6494a27aaf40f11ec60b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e01f9b1a6c95f6f7b793bdfb54755d"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a31e01f9b1a6c95f6f7b793bdfb54755d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a31e01f9b1a6c95f6f7b793bdfb54755d">ratio_less_equal_v</a> = <a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a31e01f9b1a6c95f6f7b793bdfb54755d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf88cdc68bd2c8d7aa353d030c3c1e6c"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:adf88cdc68bd2c8d7aa353d030c3c1e6c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adf88cdc68bd2c8d7aa353d030c3c1e6c">ratio_not_equal_v</a> = <a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:adf88cdc68bd2c8d7aa353d030c3c1e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b2aa1aec32660fd5004c4847957f20"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structetl_1_1element__aligned__tag.html">element_aligned_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a92b2aa1aec32660fd5004c4847957f20">element_aligned</a> {}</td></tr>
<tr class="separator:a92b2aa1aec32660fd5004c4847957f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57e9c30285b23943d7021abf09160e1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structetl_1_1vector__aligned__tag.html">vector_aligned_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae57e9c30285b23943d7021abf09160e1">vector_aligned</a> {}</td></tr>
<tr class="separator:ae57e9c30285b23943d7021abf09160e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9312dc46a8d75ebd1d2ac9315c09bf57"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a9312dc46a8d75ebd1d2ac9315c09bf57"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structetl_1_1overaligned__tag.html">overaligned_tag</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9312dc46a8d75ebd1d2ac9315c09bf57">overaligned</a> {}</td></tr>
<tr class="separator:a9312dc46a8d75ebd1d2ac9315c09bf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae174223df490e6263d4648a86326c902"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae174223df490e6263d4648a86326c902">dynamic_extent</a> = <a class="el" href="structetl_1_1numeric__limits.html">numeric_limits</a>&lt;<a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&gt;::<a class="el" href="namespaceetl.html#a7fdd0cf88f36f44f8fe8ec8327cfac74">max</a>()</td></tr>
<tr class="memdesc:ae174223df490e6263d4648a86326c902"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#ae174223df490e6263d4648a86326c902" title="etl::dynamic_extent is a constant of type etl::size_t that is used to differentiate etl::span of stat...">etl::dynamic_extent</a> is a constant of type <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> that is used to differentiate <a class="el" href="structetl_1_1span.html" title="A non-owning view over a contiguous sequence of objects.">etl::span</a> of static and dynamic extent.  <a href="namespaceetl.html#ae174223df490e6263d4648a86326c902">More...</a><br /></td></tr>
<tr class="separator:ae174223df490e6263d4648a86326c902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90533d8a4222a3a68dfc34fcd9b9e3a1"><td class="memItemLeft" align="right" valign="top">C &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a></td></tr>
<tr class="separator:a90533d8a4222a3a68dfc34fcd9b9e3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a0374b0fe975ab01bcc129d60f5d03"><td class="memItemLeft" align="right" valign="top">constexpr struct <a class="el" href="structetl_1_1ignore.html">etl::ignore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad8a0374b0fe975ab01bcc129d60f5d03">ignore</a></td></tr>
<tr class="separator:ad8a0374b0fe975ab01bcc129d60f5d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e2b2e600cad8b86cd15cb73d7f0a4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3e2b2e600cad8b86cd15cb73d7f0a4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac3e2b2e600cad8b86cd15cb73d7f0a4c">is_tuple_like</a> = false</td></tr>
<tr class="separator:ac3e2b2e600cad8b86cd15cb73d7f0a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020b53dca62b51c6ff63f22a1c81fabd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a020b53dca62b51c6ff63f22a1c81fabd"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a020b53dca62b51c6ff63f22a1c81fabd">pair_like</a> = <a class="el" href="namespaceetl.html#af600cc0169aa4ca5e5d09668d34feecd">etl::tuple_like</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#a93d0a5fb70cb82c336299812b04498f8">etl::tuple_size_v</a>&lt;<a class="el" href="namespaceetl.html#ac0c34af472196537fb719bde6ab1c4ad">etl::remove_cvref_t</a>&lt;T&gt;&gt; == 2</td></tr>
<tr class="separator:a020b53dca62b51c6ff63f22a1c81fabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af600cc0169aa4ca5e5d09668d34feecd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af600cc0169aa4ca5e5d09668d34feecd"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af600cc0169aa4ca5e5d09668d34feecd">tuple_like</a> = <a class="el" href="namespaceetl.html#ac3e2b2e600cad8b86cd15cb73d7f0a4c">etl::is_tuple_like</a>&lt;<a class="el" href="namespaceetl.html#ac0c34af472196537fb719bde6ab1c4ad">etl::remove_cvref_t</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:af600cc0169aa4ca5e5d09668d34feecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d0a5fb70cb82c336299812b04498f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93d0a5fb70cb82c336299812b04498f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a93d0a5fb70cb82c336299812b04498f8">tuple_size_v</a> = <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a93d0a5fb70cb82c336299812b04498f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e66c3ede7a3c2d993850cd16d1b4e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76e66c3ede7a3c2d993850cd16d1b4e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a76e66c3ede7a3c2d993850cd16d1b4e3">alignment_of_v</a> = <a class="el" href="structetl_1_1alignment__of.html">etl::alignment_of</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a76e66c3ede7a3c2d993850cd16d1b4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815380448fc90ab014b40a47938372f9"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a815380448fc90ab014b40a47938372f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a815380448fc90ab014b40a47938372f9">always_false</a> = false</td></tr>
<tr class="separator:a815380448fc90ab014b40a47938372f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d9f32a20bf813fd8ce025d0aebbff5"><td class="memTemplParams" colspan="2">template&lt;typename... B&gt; </td></tr>
<tr class="memitem:af0d9f32a20bf813fd8ce025d0aebbff5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af0d9f32a20bf813fd8ce025d0aebbff5">conjunction_v</a> = (B::value &amp;&amp; ...)</td></tr>
<tr class="separator:af0d9f32a20bf813fd8ce025d0aebbff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f460d9cd9dc39f08fc926828d8b442"><td class="memTemplParams" colspan="2">template&lt;typename... B&gt; </td></tr>
<tr class="memitem:a29f460d9cd9dc39f08fc926828d8b442"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a29f460d9cd9dc39f08fc926828d8b442">disjunction_v</a> = (B::value || ...)</td></tr>
<tr class="separator:a29f460d9cd9dc39f08fc926828d8b442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115f1cea7fc27ee979afae4871d03a03"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N = 0&gt; </td></tr>
<tr class="memitem:a115f1cea7fc27ee979afae4871d03a03"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a115f1cea7fc27ee979afae4871d03a03">extent_v</a> = static_cast&lt;<a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>&gt;(<a class="el" href="structetl_1_1extent.html">extent</a>&lt;T, N&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>)</td></tr>
<tr class="separator:a115f1cea7fc27ee979afae4871d03a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a60e01980cd945b387ffc47f44eccf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66a60e01980cd945b387ffc47f44eccf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a66a60e01980cd945b387ffc47f44eccf">has_unique_object_representations_v</a> = <a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a66a60e01980cd945b387ffc47f44eccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f3f4c2468d1d1f33a449bf167efbbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46f3f4c2468d1d1f33a449bf167efbbc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a46f3f4c2468d1d1f33a449bf167efbbc">has_virtual_destructor_v</a> = __has_virtual_destructor(T)</td></tr>
<tr class="memdesc:a46f3f4c2468d1d1f33a449bf167efbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a>  <a href="namespaceetl.html#a46f3f4c2468d1d1f33a449bf167efbbc">More...</a><br /></td></tr>
<tr class="separator:a46f3f4c2468d1d1f33a449bf167efbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27862efe6b9f1ba007a712b5e2a6e8a"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I&gt; </td></tr>
<tr class="memitem:af27862efe6b9f1ba007a712b5e2a6e8a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af27862efe6b9f1ba007a712b5e2a6e8a">index_c</a> = <a class="el" href="namespaceetl.html#adee9f2213a709e3392d4d998d2a406f2">etl::index_constant</a>&lt;I&gt;{}</td></tr>
<tr class="separator:af27862efe6b9f1ba007a712b5e2a6e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad586ed3dee38cd4cc1b409e607230ffb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad586ed3dee38cd4cc1b409e607230ffb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad586ed3dee38cd4cc1b409e607230ffb">is_abstract_v</a> = __is_abstract(T)</td></tr>
<tr class="separator:ad586ed3dee38cd4cc1b409e607230ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacace2162b09f525f4baff15548ecda"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afacace2162b09f525f4baff15548ecda"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afacace2162b09f525f4baff15548ecda">is_aggregate_v</a> = __is_aggregate(<a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">remove_cv_t</a>&lt;T&gt;)</td></tr>
<tr class="separator:afacace2162b09f525f4baff15548ecda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0de9ab0c91e46602a77993e77ec8a6d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ad0de9ab0c91e46602a77993e77ec8a6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad0de9ab0c91e46602a77993e77ec8a6d">is_any_of_v</a> = <a class="el" href="namespaceetl.html#a29f460d9cd9dc39f08fc926828d8b442">disjunction_v</a>&lt;<a class="el" href="structetl_1_1is__same.html">is_same</a>&lt;T, Types&gt;...&gt;</td></tr>
<tr class="separator:ad0de9ab0c91e46602a77993e77ec8a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a105e2a5ac8fc634dcc71675e27e3f95e">is_arithmetic_v</a> = <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;T&gt; or <a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">etl::is_floating_point_v</a>&lt;T&gt;</td></tr>
<tr class="separator:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afaa46050181985a6156a6c800c86a7d8">is_array_v</a> = <a class="el" href="structetl_1_1is__array.html">etl::is_array</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:afaa46050181985a6156a6c800c86a7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae630f4cbcf30c3c7912d50547711e86d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae630f4cbcf30c3c7912d50547711e86d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae630f4cbcf30c3c7912d50547711e86d">is_assignable_v</a> = __is_assignable(T, U)</td></tr>
<tr class="separator:ae630f4cbcf30c3c7912d50547711e86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00bab8d0b02bcb2974969b9d69639bb"><td class="memTemplParams" colspan="2">template&lt;typename Base , typename Derived &gt; </td></tr>
<tr class="memitem:af00bab8d0b02bcb2974969b9d69639bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af00bab8d0b02bcb2974969b9d69639bb">is_base_of_v</a> = <a class="el" href="structetl_1_1is__base__of.html">is_base_of</a>&lt;Base, Derived&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:af00bab8d0b02bcb2974969b9d69639bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d2eef20a4d7f2fcfb333c7e5c23444"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6d2eef20a4d7f2fcfb333c7e5c23444"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae6d2eef20a4d7f2fcfb333c7e5c23444">is_bounded_array_v</a> = <a class="el" href="structetl_1_1is__bounded__array.html">etl::is_bounded_array</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:ae6d2eef20a4d7f2fcfb333c7e5c23444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8d441fab48eb459b77f6f5829f7fc75">is_class_v</a> = __is_class(T)</td></tr>
<tr class="separator:af8d441fab48eb459b77f6f5829f7fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab45e49677aea4d7ed533e7c73ea7f2b6">is_compound_v</a> = !<a class="el" href="namespaceetl.html#af6b1115f04c131e47ab31a50aa2194b2">etl::is_fundamental_v</a>&lt;T&gt;</td></tr>
<tr class="separator:ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40862de0c689f5281b8d680741bc7cf9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40862de0c689f5281b8d680741bc7cf9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a40862de0c689f5281b8d680741bc7cf9">is_const_v</a> = <a class="el" href="structetl_1_1is__const.html">etl::is_const</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a40862de0c689f5281b8d680741bc7cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1ab616d6855ca5fc60968a153587b2b4">is_constructible_v</a> = <a class="el" href="namespaceetl.html#a9c3c8b104138758267e7fc29e7aa2828">is_constructible</a>&lt;T, Args...&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a1ab616d6855ca5fc60968a153587b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">is_convertible_v</a> = <a class="el" href="structetl_1_1is__convertible.html">is_convertible</a>&lt;From, To&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e13a2d8cce95954bee3d62ec059851"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17e13a2d8cce95954bee3d62ec059851"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a17e13a2d8cce95954bee3d62ec059851">is_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a17e13a2d8cce95954bee3d62ec059851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a045ef39158833b2ba6592fa8a1d0ebc1">is_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0093a625b8acbeac1878b9a9668a2563"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0093a625b8acbeac1878b9a9668a2563"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0093a625b8acbeac1878b9a9668a2563">is_default_constructible_v</a> = <a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a0093a625b8acbeac1878b9a9668a2563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ff2b6f5e9a98730031297120e28af4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34ff2b6f5e9a98730031297120e28af4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a34ff2b6f5e9a98730031297120e28af4">is_destructible_v</a> = <a class="el" href="structetl_1_1is__destructible.html">is_destructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a34ff2b6f5e9a98730031297120e28af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258143fbbaaef57434ff042f35db08a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a258143fbbaaef57434ff042f35db08a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a258143fbbaaef57434ff042f35db08a6">is_empty_v</a> = <a class="el" href="structetl_1_1is__empty.html">is_empty</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a258143fbbaaef57434ff042f35db08a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa4784b73e6d758a37358b62211a308ef">is_enum_v</a> = __is_enum(T)</td></tr>
<tr class="separator:aa4784b73e6d758a37358b62211a308ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8c484a0ff37fdfc1fc2c47b092ade2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b8c484a0ff37fdfc1fc2c47b092ade2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0b8c484a0ff37fdfc1fc2c47b092ade2">is_final_v</a> = __is_final(T)</td></tr>
<tr class="separator:a0b8c484a0ff37fdfc1fc2c47b092ade2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a> = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a5cf273d19443134cffcd66310d027ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aec3b44fa05f956c1efc4f34af98bd1f0">is_function_v</a> = <a class="el" href="structetl_1_1is__function.html">is_function</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="memdesc:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a function type. Types like etl::function, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false.  <a href="namespaceetl.html#aec3b44fa05f956c1efc4f34af98bd1f0">More...</a><br /></td></tr>
<tr class="separator:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b1115f04c131e47ab31a50aa2194b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6b1115f04c131e47ab31a50aa2194b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af6b1115f04c131e47ab31a50aa2194b2">is_fundamental_v</a> = <a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:af6b1115f04c131e47ab31a50aa2194b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750d61c5b9f6964af8d9465794b92953"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a750d61c5b9f6964af8d9465794b92953"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a750d61c5b9f6964af8d9465794b92953">is_implicit_default_constructible_v</a> = <a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a750d61c5b9f6964af8d9465794b92953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a></td></tr>
<tr class="separator:a0ef2a50a29c8803d461abedd7437effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcda8292d5b910aed63532a701d39e87"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:abcda8292d5b910aed63532a701d39e87"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abcda8292d5b910aed63532a701d39e87">is_invocable_v</a> = <a class="el" href="structetl_1_1is__invocable.html">is_invocable</a>&lt;Fn, ArgTypes...&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:abcda8292d5b910aed63532a701d39e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a1ef24a3b6eb7a38ad1307015c2c09"><td class="memTemplParams" colspan="2">template&lt;typename R , typename Fn , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:af8a1ef24a3b6eb7a38ad1307015c2c09"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8a1ef24a3b6eb7a38ad1307015c2c09">is_invocable_r_v</a> = <a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a>&lt;R, Fn, ArgTypes...&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:af8a1ef24a3b6eb7a38ad1307015c2c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf67506d7e83cba3f386c212a824e9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abdf67506d7e83cba3f386c212a824e9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abdf67506d7e83cba3f386c212a824e9c">is_lvalue_reference_v</a> = <a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:abdf67506d7e83cba3f386c212a824e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690a598d20472c340a3e6969d5fe58af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a690a598d20472c340a3e6969d5fe58af"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a690a598d20472c340a3e6969d5fe58af">is_member_function_pointer_v</a> = <a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a690a598d20472c340a3e6969d5fe58af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a05fe5ff6b0b6727ff7c98a53e5eb1c80">is_member_object_pointer_v</a> = <a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaaa5057d498812ee848f491a20649a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adbaaa5057d498812ee848f491a20649a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adbaaa5057d498812ee848f491a20649a">is_member_pointer_v</a> = <a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:adbaaa5057d498812ee848f491a20649a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad208b3b6c99d59cdc5d698310e59143e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad208b3b6c99d59cdc5d698310e59143e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad208b3b6c99d59cdc5d698310e59143e">is_move_assignable_v</a> = <a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:ad208b3b6c99d59cdc5d698310e59143e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b776d5da5e25514489bfd330d7940d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82b776d5da5e25514489bfd330d7940d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">is_move_constructible_v</a> = <a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a82b776d5da5e25514489bfd330d7940d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865b2c54ee24d227ee6f222e49fd076c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a865b2c54ee24d227ee6f222e49fd076c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a865b2c54ee24d227ee6f222e49fd076c">is_nothrow_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a>&lt;T, U&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a865b2c54ee24d227ee6f222e49fd076c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4ff5fc00d3b16aa2421ea49dae4e864e">is_nothrow_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a>&lt;T, Args...&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efb1cd1aad111e64a98e89322815a8f"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:a2efb1cd1aad111e64a98e89322815a8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2efb1cd1aad111e64a98e89322815a8f">is_nothrow_convertible_v</a> = <a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a>&lt;From, To&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a2efb1cd1aad111e64a98e89322815a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5684c28598fd5bde573fccdf36cccda9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5684c28598fd5bde573fccdf36cccda9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5684c28598fd5bde573fccdf36cccda9">is_nothrow_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a5684c28598fd5bde573fccdf36cccda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05ca75073ae3731fef7c09200d9f693"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab05ca75073ae3731fef7c09200d9f693"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab05ca75073ae3731fef7c09200d9f693">is_nothrow_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:ab05ca75073ae3731fef7c09200d9f693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e312d7578609fe1f21277a6d7a1606"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12e312d7578609fe1f21277a6d7a1606"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a12e312d7578609fe1f21277a6d7a1606">is_nothrow_default_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a12e312d7578609fe1f21277a6d7a1606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bb068a979f4237eb8c218d4f0112f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92bb068a979f4237eb8c218d4f0112f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a92bb068a979f4237eb8c218d4f0112f2">is_nothrow_destructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a92bb068a979f4237eb8c218d4f0112f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d18b577003e8d090a82e4c6d497cdd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5d18b577003e8d090a82e4c6d497cdd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab5d18b577003e8d090a82e4c6d497cdd">is_nothrow_move_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:ab5d18b577003e8d090a82e4c6d497cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">is_nothrow_move_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe0a7655d7b161139e48f8eb34838ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4fe0a7655d7b161139e48f8eb34838ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4fe0a7655d7b161139e48f8eb34838ac">is_nothrow_swappable_v</a> = <a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a4fe0a7655d7b161139e48f8eb34838ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d458068230554e22227d91a28708809"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a8d458068230554e22227d91a28708809"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8d458068230554e22227d91a28708809">is_nothrow_swappable_with_v</a> = <a class="el" href="structetl_1_1is__nothrow__swappable__with.html">is_nothrow_swappable_with</a>&lt;T, U&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a8d458068230554e22227d91a28708809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a016c8419365e8e3697a56040d335bca4">is_null_pointer_v</a> = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a016c8419365e8e3697a56040d335bca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63efd09c0ee7195824be65423adadedc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63efd09c0ee7195824be65423adadedc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">is_object_v</a> = <a class="el" href="structetl_1_1is__object.html">is_object</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a63efd09c0ee7195824be65423adadedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a> = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8f73739262829ccbc6f7400f3b2601"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca8f73739262829ccbc6f7400f3b2601"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aca8f73739262829ccbc6f7400f3b2601">is_polymorphic_v</a> = __is_polymorphic(T)</td></tr>
<tr class="separator:aca8f73739262829ccbc6f7400f3b2601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22294e9170ea0547c68724eabe0c8c5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22294e9170ea0547c68724eabe0c8c5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a22294e9170ea0547c68724eabe0c8c5a">is_reference_v</a> = <a class="el" href="structetl_1_1is__reference.html">is_reference</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a22294e9170ea0547c68724eabe0c8c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c52ea67297deb4aba0a1d7abb142f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73c52ea67297deb4aba0a1d7abb142f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a73c52ea67297deb4aba0a1d7abb142f5">is_reference_wrapper_v</a> = <a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a73c52ea67297deb4aba0a1d7abb142f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cba0c4e29fbd91ba77cbf6b9744ebc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2cba0c4e29fbd91ba77cbf6b9744ebc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af2cba0c4e29fbd91ba77cbf6b9744ebc">is_rvalue_reference_v</a> = <a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:af2cba0c4e29fbd91ba77cbf6b9744ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">is_same_v</a> = false</td></tr>
<tr class="separator:a3f74da2365a9a6f68d472686fd0f1666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699a4890b6c210a9503c517082e10e6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a699a4890b6c210a9503c517082e10e6c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a699a4890b6c210a9503c517082e10e6c">is_same_v&lt; T, T &gt;</a> = true</td></tr>
<tr class="separator:a699a4890b6c210a9503c517082e10e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43d223a689de0810df63d7c223d4228"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab43d223a689de0810df63d7c223d4228"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab43d223a689de0810df63d7c223d4228">is_scalar_v</a> = <a class="el" href="structetl_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:ab43d223a689de0810df63d7c223d4228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e458f80e6889b85b2e3bf2ee84360b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af3e458f80e6889b85b2e3bf2ee84360b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af3e458f80e6889b85b2e3bf2ee84360b">is_scoped_enum_v</a> = <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="memdesc:af3e458f80e6889b85b2e3bf2ee84360b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an scoped enumeration type. Provides the member constant value which is equal to true, if T is an scoped enumeration type. Otherwise, value is equal to false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a> or is_scoped_enum_v is undefined.  <a href="namespaceetl.html#af3e458f80e6889b85b2e3bf2ee84360b">More...</a><br /></td></tr>
<tr class="separator:af3e458f80e6889b85b2e3bf2ee84360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3fadd2a1e349c45f524ab5444220ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff3fadd2a1e349c45f524ab5444220ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aff3fadd2a1e349c45f524ab5444220ff">is_signed_v</a> = <a class="el" href="structetl_1_1is__signed.html">is_signed</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:aff3fadd2a1e349c45f524ab5444220ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efadb1ffae420e853d78309b080bb5"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; typename Template, typename T , typename Tag  = void&gt; </td></tr>
<tr class="memitem:a68efadb1ffae420e853d78309b080bb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a68efadb1ffae420e853d78309b080bb5">is_specialized_v</a> = <a class="el" href="structetl_1_1is__specialized.html">etl::is_specialized</a>&lt;Template, T, Tag&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a68efadb1ffae420e853d78309b080bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52ae3e71a7e5954830504af2048ed7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad52ae3e71a7e5954830504af2048ed7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad52ae3e71a7e5954830504af2048ed7d">is_standard_integer_v</a> = <a class="el" href="namespaceetl.html#a4881471dda8be900e4d183c9a413f66c">is_standard_unsigned_integer_v</a>&lt;T&gt; or <a class="el" href="namespaceetl.html#ab19a5f05a129870f874303571c11da48">is_standard_signed_integer_v</a>&lt;T&gt;</td></tr>
<tr class="separator:ad52ae3e71a7e5954830504af2048ed7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0627b73385571d2f5b0bb7b5f23d0c4e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0627b73385571d2f5b0bb7b5f23d0c4e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0627b73385571d2f5b0bb7b5f23d0c4e">is_standard_layout_v</a> = <a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a0627b73385571d2f5b0bb7b5f23d0c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19a5f05a129870f874303571c11da48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab19a5f05a129870f874303571c11da48"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab19a5f05a129870f874303571c11da48">is_standard_signed_integer_v</a> = <a class="el" href="namespaceetl.html#ad0de9ab0c91e46602a77993e77ec8a6d">etl::is_any_of_v</a>&lt;<a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">etl::remove_cv_t</a>&lt;T&gt;, signed char, short, int, long, long long&gt;</td></tr>
<tr class="separator:ab19a5f05a129870f874303571c11da48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4881471dda8be900e4d183c9a413f66c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4881471dda8be900e4d183c9a413f66c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4881471dda8be900e4d183c9a413f66c">is_standard_unsigned_integer_v</a> = <a class="el" href="namespaceetl.html#ad0de9ab0c91e46602a77993e77ec8a6d">is_any_of_v</a>&lt;<a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">remove_cv_t</a>&lt;T&gt;, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long&gt;</td></tr>
<tr class="separator:a4881471dda8be900e4d183c9a413f66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cb1671f31576cce07cf1bac1e99f7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46cb1671f31576cce07cf1bac1e99f7c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a46cb1671f31576cce07cf1bac1e99f7c">is_swappable_v</a> = <a class="el" href="structetl_1_1is__swappable.html">is_swappable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a46cb1671f31576cce07cf1bac1e99f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5489a5258551040b63e6eef9f49264d8"><td class="memItemLeft" align="right" valign="top">T(&amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>)[N]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> (<a class="el" href="structetl_1_1is__nothrow__swappable.html">etl::is_nothrow_swappable</a>&lt; T &gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; void</td></tr>
<tr class="separator:a5489a5258551040b63e6eef9f49264d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be84147dabbe2371aec6974e74d0f77"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7be84147dabbe2371aec6974e74d0f77"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7be84147dabbe2371aec6974e74d0f77">is_swappable_with_v</a> = <a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a>&lt;T, U&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a7be84147dabbe2371aec6974e74d0f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc5a4c4924b529a3f8760925c283ce6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1dc5a4c4924b529a3f8760925c283ce6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1dc5a4c4924b529a3f8760925c283ce6">is_trivial_v</a> = <a class="el" href="structetl_1_1is__trivial.html">is_trivial</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a1dc5a4c4924b529a3f8760925c283ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cfce5bc9de7ea45285ad503a807a9b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad2cfce5bc9de7ea45285ad503a807a9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad2cfce5bc9de7ea45285ad503a807a9b">is_trivially_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a>&lt;T, U&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:ad2cfce5bc9de7ea45285ad503a807a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0a74c34b46b65c2b8fa633d1e6211b25">is_trivially_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a>&lt;T, Args...&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4028d9154b8d629e56fd488b33587786"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4028d9154b8d629e56fd488b33587786"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4028d9154b8d629e56fd488b33587786">is_trivially_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a4028d9154b8d629e56fd488b33587786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56b91d45ec88c108b77f55e9f6bc187"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac56b91d45ec88c108b77f55e9f6bc187"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac56b91d45ec88c108b77f55e9f6bc187">is_trivially_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:ac56b91d45ec88c108b77f55e9f6bc187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3b937c99443cbaf5f1817d061261bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b3b937c99443cbaf5f1817d061261bd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5b3b937c99443cbaf5f1817d061261bd">is_trivially_copyable_v</a> = __is_trivially_copyable(T)</td></tr>
<tr class="separator:a5b3b937c99443cbaf5f1817d061261bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f37ab88cda78781a7aca13f18adac97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f37ab88cda78781a7aca13f18adac97"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6f37ab88cda78781a7aca13f18adac97">is_trivially_default_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a6f37ab88cda78781a7aca13f18adac97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b9d2d77f59d05a317cc9715ac7aa8c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11b9d2d77f59d05a317cc9715ac7aa8c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a11b9d2d77f59d05a317cc9715ac7aa8c">is_trivially_destructible_v</a> = __has_trivial_destructor(T)</td></tr>
<tr class="separator:a11b9d2d77f59d05a317cc9715ac7aa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3673480825caede3c2d5095f8a39fe0d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3673480825caede3c2d5095f8a39fe0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3673480825caede3c2d5095f8a39fe0d">is_trivially_move_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a3673480825caede3c2d5095f8a39fe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6928ba542ac2317ce2796c3a71a9b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef6928ba542ac2317ce2796c3a71a9b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aef6928ba542ac2317ce2796c3a71a9b7">is_trivially_move_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__move__constructible.html">etl::is_trivially_move_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:aef6928ba542ac2317ce2796c3a71a9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c65af89fc55014250b54559626d075"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00c65af89fc55014250b54559626d075"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a00c65af89fc55014250b54559626d075">is_unbounded_array_v</a> = <a class="el" href="structetl_1_1is__unbounded__array.html">etl::is_unbounded_array</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a00c65af89fc55014250b54559626d075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a51d4c31d288adf2cb4c5d7fd14c32f00">is_union_v</a> = __is_union(T)</td></tr>
<tr class="separator:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3bbd05dc09b68b19c63d7b4fbf6f1108">is_unsigned_v</a> = <a class="el" href="structetl_1_1is__unsigned.html">etl::is_unsigned</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a149f8ba4063995f2c8ed7248d93a4d9e">is_void_v</a> = <a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt;void, <a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">etl::remove_cv_t</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76b943cef158f554f60c8d61b6835bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa76b943cef158f554f60c8d61b6835bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa76b943cef158f554f60c8d61b6835bc">is_volatile_v</a> = <a class="el" href="structetl_1_1is__volatile.html">etl::is_volatile</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:aa76b943cef158f554f60c8d61b6835bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0422e10e238c05956150aa5f4ed77e"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:a2e0422e10e238c05956150aa5f4ed77e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2e0422e10e238c05956150aa5f4ed77e">negation_v</a> = !bool(B::value)</td></tr>
<tr class="separator:a2e0422e10e238c05956150aa5f4ed77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4229d4171b460abc833736d622ce9745"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a4229d4171b460abc833736d622ce9745"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4229d4171b460abc833736d622ce9745">rank_v</a> = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;Type&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a4229d4171b460abc833736d622ce9745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53057a1d7b9d22a69eb3e40fdc44eb3d"><td class="memTemplParams" colspan="2">template&lt;auto V&gt; </td></tr>
<tr class="memitem:a53057a1d7b9d22a69eb3e40fdc44eb3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a53057a1d7b9d22a69eb3e40fdc44eb3d">nontype</a> = <a class="el" href="structetl_1_1nontype__t.html">etl::nontype_t</a>&lt;V&gt;{}</td></tr>
<tr class="separator:a53057a1d7b9d22a69eb3e40fdc44eb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29815251de01b00c45a0bb62678930c5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a29815251de01b00c45a0bb62678930c5">piecewise_construct</a> = <a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a>{}</td></tr>
<tr class="memdesc:a29815251de01b00c45a0bb62678930c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constant <a class="el" href="namespaceetl.html#a29815251de01b00c45a0bb62678930c5" title="The constant etl::piecewise_construct is an instance of an empty struct tag type etl::piecewise_const...">etl::piecewise_construct</a> is an instance of an empty struct tag type <a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a>.  <a href="namespaceetl.html#a29815251de01b00c45a0bb62678930c5">More...</a><br /></td></tr>
<tr class="separator:a29815251de01b00c45a0bb62678930c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d369052fc23b452882a9fd514abb87"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a28d369052fc23b452882a9fd514abb87">variant_npos</a> = <a class="el" href="structetl_1_1numeric__limits.html">etl::numeric_limits</a>&lt;<a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&gt;::<a class="el" href="namespaceetl.html#a7fdd0cf88f36f44f8fe8ec8327cfac74">max</a>()</td></tr>
<tr class="memdesc:a28d369052fc23b452882a9fd514abb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special value equal to the largest value representable by the type size_t, used as the return value of index() when valueless_by_exception() is true.  <a href="namespaceetl.html#a28d369052fc23b452882a9fd514abb87">More...</a><br /></td></tr>
<tr class="separator:a28d369052fc23b452882a9fd514abb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9289432c6100af2ec8b2563959f2c261"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9289432c6100af2ec8b2563959f2c261"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9289432c6100af2ec8b2563959f2c261">variant_size_v</a> = <a class="el" href="structetl_1_1variant__size.html">variant_size</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td></tr>
<tr class="separator:a9289432c6100af2ec8b2563959f2c261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8047ec1fd97af797afb4226eba8bd80f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8047ec1fd97af797afb4226eba8bd80f">current_implementation</a> = <a class="el" href="namespaceetl.html#a035e7d2ea0f6aebad724e7fab40495d5aed920a9dd5bae2e1c4f11aab8f5784e1">implementation::freestanding</a></td></tr>
<tr class="separator:a8047ec1fd97af797afb4226eba8bd80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1c600f9a9722bf7bef4af93af1d5ca"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afb1c600f9a9722bf7bef4af93af1d5ca">current_standard</a> = <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53af94629088b2e56f93753526b629a62ff">language_standard::cpp_26</a></td></tr>
<tr class="memdesc:afb1c600f9a9722bf7bef4af93af1d5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently configured C++ standard.  <a href="namespaceetl.html#afb1c600f9a9722bf7bef4af93af1d5ca">More...</a><br /></td></tr>
<tr class="separator:afb1c600f9a9722bf7bef4af93af1d5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a568b4df04642a2e727b3a8b201f2e450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568b4df04642a2e727b3a8b201f2e450">&#9670;&nbsp;</a></span>c_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , etl::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a568b4df04642a2e727b3a8b201f2e450">etl::c_array</a> = typedef ValueType[<a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04532556e568bb7cc276440befc7f441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04532556e568bb7cc276440befc7f441">&#9670;&nbsp;</a></span>float_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a04532556e568bb7cc276440befc7f441">etl::float_t</a> = typedef float</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most efficient floating-point type at least as wide as float. </p>

</div>
</div>
<a id="a9c91cfdd41de11ccf80532067354fe92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c91cfdd41de11ccf80532067354fe92">&#9670;&nbsp;</a></span>double_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a9c91cfdd41de11ccf80532067354fe92">etl::double_t</a> = typedef double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most efficient floating-point type at least as wide as double. </p>

</div>
</div>
<a id="ad206e673dfd2f8aa9800684c6734595c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad206e673dfd2f8aa9800684c6734595c">&#9670;&nbsp;</a></span>common_comparison_category_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ad206e673dfd2f8aa9800684c6734595c">etl::common_comparison_category_t</a> = typedef typename <a class="el" href="structetl_1_1common__comparison__category.html">common_comparison_category</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a076e8c592e28166b1126264966624b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076e8c592e28166b1126264966624b4b">&#9670;&nbsp;</a></span>compare_three_way_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a076e8c592e28166b1126264966624b4b">etl::compare_three_way_result_t</a> = typedef decltype( <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt;<a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt;T&gt; const&amp;&gt;() &lt;=&gt; <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt;<a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt;U&gt; const&amp;&gt;() )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a910e85d940ada86b5e325f3a16815963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910e85d940ada86b5e325f3a16815963">&#9670;&nbsp;</a></span>smallest_size_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned long long N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a910e85d940ada86b5e325f3a16815963">etl::smallest_size_t</a> = typedef <a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">conditional_t</a>&lt;(N &lt; static_cast&lt;unsigned char&gt;(-1)), unsigned char, <a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">conditional_t</a>&lt;(N &lt; static_cast&lt;unsigned short&gt;(-1)), unsigned short, <a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">conditional_t</a>&lt;(N &lt; static_cast&lt;unsigned int&gt;(-1)), unsigned int, <a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">conditional_t</a>&lt;(N &lt; static_cast&lt;unsigned long&gt;(-1)), unsigned long, unsigned long long&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smallest fixed-width unsigned integer type that can represent values in the range [0, N]. </p>

</div>
</div>
<a id="adf4272f3f16bf2234ac8248db615f133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4272f3f16bf2234ac8248db615f133">&#9670;&nbsp;</a></span>nullptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">etl::nullptr_t</a> = typedef decltype(nullptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/nullptr_t">https://en.cppreference.com/w/cpp/types/nullptr_t</a> </p>

</div>
</div>
<a id="a955e0d5a5e84e9e394bf38a95c8ce380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955e0d5a5e84e9e394bf38a95c8ce380">&#9670;&nbsp;</a></span>ptrdiff_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a955e0d5a5e84e9e394bf38a95c8ce380">etl::ptrdiff_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a19bfe4995271e67306bab6dc974ed002">TETL_BUILTIN_PTRDIFF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#a955e0d5a5e84e9e394bf38a95c8ce380" title="etl::ptrdiff_t is the signed integer type of the result of subtracting two pointers.">etl::ptrdiff_t</a> is the signed integer type of the result of subtracting two pointers. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/ptrdiff_t">https://en.cppreference.com/w/cpp/types/ptrdiff_t</a> </p>

</div>
</div>
<a id="a9671046b2e5aea5a45a7f12fecc9f911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9671046b2e5aea5a45a7f12fecc9f911">&#9670;&nbsp;</a></span>size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#ab236bea848bc390350ba3fc38ae07819">TETL_BUILTIN_SIZET</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> is the unsigned integer type of the result of the sizeof operator. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/size_t">https://en.cppreference.com/w/cpp/types/size_t</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a0">numeric.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abb2ed7b5d4c5b80c8000cdf5e85bcf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2ed7b5d4c5b80c8000cdf5e85bcf5f">&#9670;&nbsp;</a></span>int_fast8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#abb2ed7b5d4c5b80c8000cdf5e85bcf5f">etl::int_fast8_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a3a65f3a332a5af06e36e13783ba42db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a65f3a332a5af06e36e13783ba42db3">&#9670;&nbsp;</a></span>int_fast16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a3a65f3a332a5af06e36e13783ba42db3">etl::int_fast16_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="a177099d663b48f0f92b67ca7cbdf65c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177099d663b48f0f92b67ca7cbdf65c3">&#9670;&nbsp;</a></span>int_fast32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a177099d663b48f0f92b67ca7cbdf65c3">etl::int_fast32_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="ab1150023b8ce4b5b4a8ea6a373e9b388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1150023b8ce4b5b4a8ea6a373e9b388">&#9670;&nbsp;</a></span>int_fast64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ab1150023b8ce4b5b4a8ea6a373e9b388">etl::int_fast64_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="a95e1f2b57192eb59d8896c3c5e3bb51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e1f2b57192eb59d8896c3c5e3bb51d">&#9670;&nbsp;</a></span>int_least8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a95e1f2b57192eb59d8896c3c5e3bb51d">etl::int_least8_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a5aa91b645d41d579ad9d546b1696bac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa91b645d41d579ad9d546b1696bac4">&#9670;&nbsp;</a></span>int_least16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a5aa91b645d41d579ad9d546b1696bac4">etl::int_least16_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="aecc620fcad636bc011a67f10a08fa104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc620fcad636bc011a67f10a08fa104">&#9670;&nbsp;</a></span>int_least32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aecc620fcad636bc011a67f10a08fa104">etl::int_least32_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="a668df81287b2fc3bec1db5bb30e1a68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668df81287b2fc3bec1db5bb30e1a68a">&#9670;&nbsp;</a></span>int_least64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a668df81287b2fc3bec1db5bb30e1a68a">etl::int_least64_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="ab74b36e22a5adda58be542d7c31f8109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74b36e22a5adda58be542d7c31f8109">&#9670;&nbsp;</a></span>int8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ab74b36e22a5adda58be542d7c31f8109">etl::int8_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 8 bits. </p>

</div>
</div>
<a id="a44df0d1723c3871b21fb46551504d4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44df0d1723c3871b21fb46551504d4f4">&#9670;&nbsp;</a></span>int16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a44df0d1723c3871b21fb46551504d4f4">etl::int16_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 16 bits. </p>

</div>
</div>
<a id="a6647b6b071a7156c723345a83e838db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6647b6b071a7156c723345a83e838db7">&#9670;&nbsp;</a></span>int32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a6647b6b071a7156c723345a83e838db7">etl::int32_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 32 bits. </p>

</div>
</div>
<a id="a4158519b6c914f0112e3e0f9547e8710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4158519b6c914f0112e3e0f9547e8710">&#9670;&nbsp;</a></span>int64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a4158519b6c914f0112e3e0f9547e8710">etl::int64_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 64 bits. </p>

</div>
</div>
<a id="a04395ca65e067ae9f19def97c62af3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04395ca65e067ae9f19def97c62af3ce">&#9670;&nbsp;</a></span>intmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a04395ca65e067ae9f19def97c62af3ce">etl::intmax_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#ad8678dda9c4b939fee5244864c53ada1">TETL_BUILTIN_INTMAX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum-width signed integer type. </p>

</div>
</div>
<a id="ac74f9bed34c8c76ba2dfee118b63ac26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74f9bed34c8c76ba2dfee118b63ac26">&#9670;&nbsp;</a></span>intptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac74f9bed34c8c76ba2dfee118b63ac26">etl::intptr_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a021098c463419df8b156d80c9153387e">TETL_BUILTIN_INTPTR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type capable of holding a pointer. </p>

</div>
</div>
<a id="ad77926b7a11780aa2676fc552c574ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77926b7a11780aa2676fc552c574ae7">&#9670;&nbsp;</a></span>uint_fast8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ad77926b7a11780aa2676fc552c574ae7">etl::uint_fast8_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a6412e0b86f8258a67d0cf3efc27f29ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6412e0b86f8258a67d0cf3efc27f29ca">&#9670;&nbsp;</a></span>uint_fast16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a6412e0b86f8258a67d0cf3efc27f29ca">etl::uint_fast16_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="aae8231f2a890b4a057d999a9a7d88cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8231f2a890b4a057d999a9a7d88cf9">&#9670;&nbsp;</a></span>uint_fast32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aae8231f2a890b4a057d999a9a7d88cf9">etl::uint_fast32_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="a26f7c13233dafa5cc0f8a3d49093ee1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f7c13233dafa5cc0f8a3d49093ee1d">&#9670;&nbsp;</a></span>uint_fast64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a26f7c13233dafa5cc0f8a3d49093ee1d">etl::uint_fast64_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="a9db9185a6357a3e71a91491298e8690c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db9185a6357a3e71a91491298e8690c">&#9670;&nbsp;</a></span>uint_least8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a9db9185a6357a3e71a91491298e8690c">etl::uint_least8_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a2694291a7c796beec5cfe0c006f185e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2694291a7c796beec5cfe0c006f185e1">&#9670;&nbsp;</a></span>uint_least16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a2694291a7c796beec5cfe0c006f185e1">etl::uint_least16_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="a7b343e0347d929b0ff4d34d643f9cf9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b343e0347d929b0ff4d34d643f9cf9e">&#9670;&nbsp;</a></span>uint_least32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a7b343e0347d929b0ff4d34d643f9cf9e">etl::uint_least32_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="af9447a983a1474ce60b01aa33610d45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9447a983a1474ce60b01aa33610d45e">&#9670;&nbsp;</a></span>uint_least64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#af9447a983a1474ce60b01aa33610d45e">etl::uint_least64_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="ae4884330ffa7c8d259566d1344e12209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4884330ffa7c8d259566d1344e12209">&#9670;&nbsp;</a></span>uint8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ae4884330ffa7c8d259566d1344e12209">etl::uint8_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 8 bits. </p>

</div>
</div>
<a id="a07faf2c6165a6ec08c1d7ce7b59c70f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07faf2c6165a6ec08c1d7ce7b59c70f9">&#9670;&nbsp;</a></span>uint16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a07faf2c6165a6ec08c1d7ce7b59c70f9">etl::uint16_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 16 bits. </p>

</div>
</div>
<a id="a45cd8f569fbe5bbe1bc46988b146bf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cd8f569fbe5bbe1bc46988b146bf43">&#9670;&nbsp;</a></span>uint32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a45cd8f569fbe5bbe1bc46988b146bf43">etl::uint32_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 32 bits. </p>

</div>
</div>
<a id="a75da701473a787f887fa0c35cb173588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75da701473a787f887fa0c35cb173588">&#9670;&nbsp;</a></span>uint64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a75da701473a787f887fa0c35cb173588">etl::uint64_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 64 bits. </p>

</div>
</div>
<a id="a91bd6bc49488600867f3af14e73936ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bd6bc49488600867f3af14e73936ff">&#9670;&nbsp;</a></span>uintmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a91bd6bc49488600867f3af14e73936ff">etl::uintmax_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a64175350ea04c19125422816cd6184e1">TETL_BUILTIN_UINTMAX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum-width unsigned integer type. </p>

</div>
</div>
<a id="aef1bda2cf8742dabfe32527f518cf5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1bda2cf8742dabfe32527f518cf5ac">&#9670;&nbsp;</a></span>uintptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aef1bda2cf8742dabfe32527f518cf5ac">etl::uintptr_t</a> = typedef <a class="el" href="builtin__types_8hpp.html#a3b013e093af0767d757a3606463295d9">TETL_BUILTIN_UINTPTR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type capable of holding a pointer. </p>

</div>
</div>
<a id="aae0eeae85a8a320c4b560b2c416d739a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0eeae85a8a320c4b560b2c416d739a">&#9670;&nbsp;</a></span>clock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aae0eeae85a8a320c4b560b2c416d739a">etl::clock_t</a> = typedef <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab825d27ed3dfbe0ed0a6d56ec8f43496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab825d27ed3dfbe0ed0a6d56ec8f43496">&#9670;&nbsp;</a></span>time_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ab825d27ed3dfbe0ed0a6d56ec8f43496">etl::time_t</a> = typedef <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic type capable of representing times. </p>
<p>Although not defined, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to POSIX time. </p>

</div>
</div>
<a id="a242f9848c8ce5c281284bf133ce1bc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242f9848c8ce5c281284bf133ce1bc94">&#9670;&nbsp;</a></span>wint_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">etl::wint_t</a> = typedef unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9fa9df1563f429e510c612727c974ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fa9df1563f429e510c612727c974ee">&#9670;&nbsp;</a></span>format_args</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac9fa9df1563f429e510c612727c974ee">etl::format_args</a> = typedef <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="namespaceetl.html#aa49c8d8025e0a5d18a2a0f3df0a3cc07">format_context</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4b85be0c7f71b9b0958fd7cc39e35c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b85be0c7f71b9b0958fd7cc39e35c3">&#9670;&nbsp;</a></span>wformat_args</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ab4b85be0c7f71b9b0958fd7cc39e35c3">etl::wformat_args</a> = typedef <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="namespaceetl.html#a7d6b3a02733a03dc5fb0cdcd3c1f7928">wformat_context</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa49c8d8025e0a5d18a2a0f3df0a3cc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49c8d8025e0a5d18a2a0f3df0a3cc07">&#9670;&nbsp;</a></span>format_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aa49c8d8025e0a5d18a2a0f3df0a3cc07">etl::format_context</a> = typedef <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;char&gt; &gt;, char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to formatting state consisting of the formatting arguments and the output iterator. </p>
<p>The first template argument is an output iterator that appends to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>, such as etl::back_insert_iterator&lt;etl::static_string&gt;. Implementations are encouraged to use an iterator to type-erased buffer type that supports appending to any contiguous and resizable container.</p>
<p>The behavior is undefined if OutputIt does not model output_iterator&lt;const CharT&amp;&gt;.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/basic_format_context">https://en.cppreference.com/w/cpp/utility/format/basic_format_context</a> </p>

</div>
</div>
<a id="a7d6b3a02733a03dc5fb0cdcd3c1f7928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6b3a02733a03dc5fb0cdcd3c1f7928">&#9670;&nbsp;</a></span>wformat_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a7d6b3a02733a03dc5fb0cdcd3c1f7928">etl::wformat_context</a> = typedef <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;wchar_t&gt; &gt;, wchar_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b23ca440a5d368e5cdda4b322e9fe31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b23ca440a5d368e5cdda4b322e9fe31">&#9670;&nbsp;</a></span>format_parse_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a4b23ca440a5d368e5cdda4b322e9fe31">etl::format_parse_context</a> = typedef <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a671044d4ad13b14eda4b8742ba2790e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671044d4ad13b14eda4b8742ba2790e7">&#9670;&nbsp;</a></span>wformat_parse_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a671044d4ad13b14eda4b8742ba2790e7">etl::wformat_parse_context</a> = typedef <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;wchar_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33d893d90400b4bba35516d905e4c885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d893d90400b4bba35516d905e4c885">&#9670;&nbsp;</a></span>format_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a33d893d90400b4bba35516d905e4c885">etl::format_string</a> = typedef <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;char, <a class="el" href="namespaceetl.html#af53ccea3515493c555e3a764ffea8ff0">type_identity_t</a>&lt;Args&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af67ccd4d8cf9499a9b76b57a5a6a3c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67ccd4d8cf9499a9b76b57a5a6a3c6d">&#9670;&nbsp;</a></span>wformat_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#af67ccd4d8cf9499a9b76b57a5a6a3c6d">etl::wformat_string</a> = typedef <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;wchar_t, <a class="el" href="namespaceetl.html#af53ccea3515493c555e3a764ffea8ff0">type_identity_t</a>&lt;Args&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e4d7671919f2ad18da41013ecd9dde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4d7671919f2ad18da41013ecd9dde4">&#9670;&nbsp;</a></span>diff_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a0e4d7671919f2ad18da41013ecd9dde4">etl::diff_t</a> = typedef typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt;<a class="el" href="namespaceetl.html#ac0c34af472196537fb719bde6ab1c4ad">etl::remove_cvref_t</a>&lt;Iter&gt; &gt;::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bc35dfd838fd831b02bd53096097def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc35dfd838fd831b02bd53096097def">&#9670;&nbsp;</a></span>stringbuf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a9bc35dfd838fd831b02bd53096097def">etl::stringbuf</a> = typedef <a class="el" href="structetl_1_1basic__stringbuf.html">basic_stringbuf</a>&lt;char, Capacity&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cc54c8127416c33c963bee08bc99596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc54c8127416c33c963bee08bc99596">&#9670;&nbsp;</a></span>streamoff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a8cc54c8127416c33c963bee08bc99596">etl::streamoff</a> = typedef long</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6a81fba06194ff9cf0d14e9dd9339a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a81fba06194ff9cf0d14e9dd9339a0">&#9670;&nbsp;</a></span>streamsize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aa6a81fba06194ff9cf0d14e9dd9339a0">etl::streamsize</a> = typedef <a class="el" href="namespaceetl.html#abffe34c79351f871acb3e0438b2ad488">make_signed_t</a>&lt;<a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91a7197a7953a7c1e620701f90bec2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a7197a7953a7c1e620701f90bec2cc">&#9670;&nbsp;</a></span>iter_difference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a91a7197a7953a7c1e620701f90bec2cc">etl::iter_difference_t</a> = typedef typename detail::iter_difference&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6106bae4778d251870adc7ae5b1974ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6106bae4778d251870adc7ae5b1974ef">&#9670;&nbsp;</a></span>iter_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::dereferenceable T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a6106bae4778d251870adc7ae5b1974ef">etl::iter_reference_t</a> = typedef decltype(*<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;T&amp;&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c22455efb7e072deb03e78241405e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c22455efb7e072deb03e78241405e56">&#9670;&nbsp;</a></span>iter_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a7c22455efb7e072deb03e78241405e56">etl::iter_value_t</a> = typedef typename detail::iter_value&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a314896b8468bbdbea59f862f4c5e8aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314896b8468bbdbea59f862f4c5e8aef">&#9670;&nbsp;</a></span>dextents</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , etl::size_t Rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a314896b8468bbdbea59f862f4c5e8aef">etl::dextents</a> = typedef typename detail::dextents_impl&lt;IndexType, <a class="el" href="namespaceetl.html#acca681165e818e6caaf5e237e8125ae8">etl::make_index_sequence</a>&lt;Rank&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8937b566b6510cbe3ede298d8b128f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8937b566b6510cbe3ede298d8b128f2b">&#9670;&nbsp;</a></span>new_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a8937b566b6510cbe3ede298d8b128f2b">etl::new_handler</a> = typedef void (*)()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#a8937b566b6510cbe3ede298d8b128f2b" title="etl::new_handler is the function pointer type (pointer to function that takes no arguments and return...">etl::new_handler</a> is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions etl::set_new_handler and etl::get_new_handler </p>

</div>
</div>
<a id="a56e01072f7d94c62bb328ea01c1588e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e01072f7d94c62bb328ea01c1588e1">&#9670;&nbsp;</a></span>xorshift16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a56e01072f7d94c62bb328ea01c1588e1">etl::xorshift16</a> = typedef <a class="el" href="structetl_1_1xorshift.html">xorshift</a>&lt;<a class="el" href="namespaceetl.html#a07faf2c6165a6ec08c1d7ce7b59c70f9">uint16_t</a>, 7, 9, 8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16-bit pseudo number generator <a href="http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html">http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html</a> <a href="https://codebase64.org/doku.php?id=base:16bit_xorshift_random_generator">https://codebase64.org/doku.php?id=base:16bit_xorshift_random_generator</a> </p>

</div>
</div>
<a id="ad5f97b463f89003915a42b98555c13bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f97b463f89003915a42b98555c13bf">&#9670;&nbsp;</a></span>xorshift32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ad5f97b463f89003915a42b98555c13bf">etl::xorshift32</a> = typedef <a class="el" href="structetl_1_1xorshift.html">xorshift</a>&lt;<a class="el" href="namespaceetl.html#a45cd8f569fbe5bbe1bc46988b146bf43">uint32_t</a>, 13, 17, 5&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32-bit pseudo number generator <a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a> </p>

</div>
</div>
<a id="ac41a230169af2e293e51036057534936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41a230169af2e293e51036057534936">&#9670;&nbsp;</a></span>xorshift64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac41a230169af2e293e51036057534936">etl::xorshift64</a> = typedef <a class="el" href="structetl_1_1xorshift.html">xorshift</a>&lt;<a class="el" href="namespaceetl.html#a75da701473a787f887fa0c35cb173588">uint64_t</a>, 13, 7, 17&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64-bit pseudo number generator <a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a> </p>

</div>
</div>
<a id="a7cc2ccd245f477d45cf1f6957c8f8993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc2ccd245f477d45cf1f6957c8f8993">&#9670;&nbsp;</a></span>atto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a7cc2ccd245f477d45cf1f6957c8f8993">etl::atto</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a837dad904f094bc29e24139565eec1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837dad904f094bc29e24139565eec1c5">&#9670;&nbsp;</a></span>femto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a837dad904f094bc29e24139565eec1c5">etl::femto</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab85e2cc66c84a64edf096334ea68d82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85e2cc66c84a64edf096334ea68d82f">&#9670;&nbsp;</a></span>pico</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ab85e2cc66c84a64edf096334ea68d82f">etl::pico</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab16ea857b72e93345fcd6fb255f7fe86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16ea857b72e93345fcd6fb255f7fe86">&#9670;&nbsp;</a></span>nano</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ab16ea857b72e93345fcd6fb255f7fe86">etl::nano</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56ee5013d725632677b4d1d93204c07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ee5013d725632677b4d1d93204c07b">&#9670;&nbsp;</a></span>micro</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a56ee5013d725632677b4d1d93204c07b">etl::micro</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc43923bf9757db3bbaa5a6e4d36a3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc43923bf9757db3bbaa5a6e4d36a3c6">&#9670;&nbsp;</a></span>milli</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#afc43923bf9757db3bbaa5a6e4d36a3c6">etl::milli</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95d8c20c69482c794a0cfb9e4428ca8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d8c20c69482c794a0cfb9e4428ca8d">&#9670;&nbsp;</a></span>centi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a95d8c20c69482c794a0cfb9e4428ca8d">etl::centi</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 100&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59f2e2c10ab4b06ed261d1e4a8358895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f2e2c10ab4b06ed261d1e4a8358895">&#9670;&nbsp;</a></span>deci</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a59f2e2c10ab4b06ed261d1e4a8358895">etl::deci</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 10&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acae5b099e4ead54343e6304a6371985b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae5b099e4ead54343e6304a6371985b">&#9670;&nbsp;</a></span>deca</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#acae5b099e4ead54343e6304a6371985b">etl::deca</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;10, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb">&#9670;&nbsp;</a></span>hecto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb">etl::hecto</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;100, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0f7df2b4a088f13d067ec91336ad6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f7df2b4a088f13d067ec91336ad6d8">&#9670;&nbsp;</a></span>kilo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ae0f7df2b4a088f13d067ec91336ad6d8">etl::kilo</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb8b8f156e99d25877de869998eca882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8b8f156e99d25877de869998eca882">&#9670;&nbsp;</a></span>mega</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#afb8b8f156e99d25877de869998eca882">etl::mega</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaa010c22727dfd8ede60afef156650c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa010c22727dfd8ede60afef156650c">&#9670;&nbsp;</a></span>giga</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aeaa010c22727dfd8ede60afef156650c">etl::giga</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d864adecb109d82a13a134020536ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d864adecb109d82a13a134020536ce7">&#9670;&nbsp;</a></span>tera</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a9d864adecb109d82a13a134020536ce7">etl::tera</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2de582631c8b0507fa316267f24ae3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2de582631c8b0507fa316267f24ae3b">&#9670;&nbsp;</a></span>peta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac2de582631c8b0507fa316267f24ae3b">etl::peta</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a525a461cc6d062b7138a777cadacac47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525a461cc6d062b7138a777cadacac47">&#9670;&nbsp;</a></span>exa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a525a461cc6d062b7138a777cadacac47">etl::exa</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a515e08f8ce11f32a154acd83b2fe6b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515e08f8ce11f32a154acd83b2fe6b00">&#9670;&nbsp;</a></span>ratio_add</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a515e08f8ce11f32a154acd83b2fe6b00">etl::ratio_add</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alias template ratio_add denotes the result of adding two exact rational fractions represented by the ratio specializations R1 and R2. </p>

</div>
</div>
<a id="a420acf1424e7ed7ae82f703ac31ff258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420acf1424e7ed7ae82f703ac31ff258">&#9670;&nbsp;</a></span>ratio_divide</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a420acf1424e7ed7ae82f703ac31ff258">etl::ratio_divide</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den, R1::den * R2::num&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alias template ratio_divide denotes the result of dividing two exact rational fractions represented by the ratio specializations R1 and R2. </p>

</div>
</div>
<a id="abbdaf3b94f7cb0830c812d5c8aabbe0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdaf3b94f7cb0830c812d5c8aabbe0b">&#9670;&nbsp;</a></span>ratio_multiply</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#abbdaf3b94f7cb0830c812d5c8aabbe0b">etl::ratio_multiply</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::num, R1::den * R2::den&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alias template ratio_multiply denotes the result of multiplying two exact rational fractions represented by the ratio specializations R1 and R2. </p>

</div>
</div>
<a id="a234acc6c1438740afe4f7766f1208784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234acc6c1438740afe4f7766f1208784">&#9670;&nbsp;</a></span>ratio_subtract</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a234acc6c1438740afe4f7766f1208784">etl::ratio_subtract</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den - R2::num * R1::den, R1::den * R2::den&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alias template ratio_subtract denotes the result of subtracting two exact rational fractions represented by the ratio specializations R1 and R2. </p>

</div>
</div>
<a id="a8dfb181ab4cdace72138dcfb3b7b8e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfb181ab4cdace72138dcfb3b7b8e27">&#9670;&nbsp;</a></span>static_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a> = typedef <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;char, Capacity&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'char'. </p>

</div>
</div>
<a id="a764367809b942e7602a985553294edba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764367809b942e7602a985553294edba">&#9670;&nbsp;</a></span>static_wstring</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a764367809b942e7602a985553294edba">etl::static_wstring</a> = typedef <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;wchar_t, Capacity&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'wchar_t'. </p>

</div>
</div>
<a id="a41ec92a1e825e31fc024b95f85aed1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ec92a1e825e31fc024b95f85aed1da">&#9670;&nbsp;</a></span>string_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a> = typedef <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt;char, <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt;char&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedefs for common character type. </p>

</div>
</div>
<a id="a700f0f867c8a351c79de3b290004521e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700f0f867c8a351c79de3b290004521e">&#9670;&nbsp;</a></span>tuple_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a700f0f867c8a351c79de3b290004521e">etl::tuple_element_t</a> = typedef typename <a class="el" href="structetl_1_1tuple__element.html">tuple_element</a>&lt;I, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06fe98569e6409cac789c54e1e563996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fe98569e6409cac789c54e1e563996">&#9670;&nbsp;</a></span>add_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a06fe98569e6409cac789c54e1e563996">etl::add_const_t</a> = typedef T const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97ebe7b76517ccaa9b434dbd1db3d992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ebe7b76517ccaa9b434dbd1db3d992">&#9670;&nbsp;</a></span>add_cv_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a97ebe7b76517ccaa9b434dbd1db3d992">etl::add_cv_t</a> = typedef T const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc2518533f04904417528e26d187b2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2518533f04904417528e26d187b2bb">&#9670;&nbsp;</a></span>add_lvalue_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#acc2518533f04904417528e26d187b2bb">etl::add_lvalue_reference_t</a> = typedef typename <a class="el" href="structetl_1_1add__lvalue__reference.html">etl::add_lvalue_reference</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ab42b86be16dbdbaa744a2caaca7e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab42b86be16dbdbaa744a2caaca7e80">&#9670;&nbsp;</a></span>add_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a2ab42b86be16dbdbaa744a2caaca7e80">etl::add_pointer_t</a> = typedef typename <a class="el" href="structetl_1_1add__pointer.html">etl::add_pointer</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1498f004a367863b7b1b4f0f8ca3f75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1498f004a367863b7b1b4f0f8ca3f75d">&#9670;&nbsp;</a></span>add_rvalue_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a1498f004a367863b7b1b4f0f8ca3f75d">etl::add_rvalue_reference_t</a> = typedef typename <a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8a2ecbbe3dd734b6c724afc995c9849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a2ecbbe3dd734b6c724afc995c9849">&#9670;&nbsp;</a></span>add_volatile_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#af8a2ecbbe3dd734b6c724afc995c9849">etl::add_volatile_t</a> = typedef T volatile</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89e24f91ae41b68d72dc83e45765ffe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e24f91ae41b68d72dc83e45765ffe3">&#9670;&nbsp;</a></span>aligned_storage_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Len, etl::size_t Align = alignof(detail::aligned_storage_impl&lt;Len&gt;)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a89e24f91ae41b68d72dc83e45765ffe3">etl::aligned_storage_t</a> = typedef typename <a class="el" href="structetl_1_1aligned__storage.html">etl::aligned_storage</a>&lt;Len, Align&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5633d0f4ab2cab13d3635ee77ecba9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5633d0f4ab2cab13d3635ee77ecba9ad">&#9670;&nbsp;</a></span>aligned_union_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Len, typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a5633d0f4ab2cab13d3635ee77ecba9ad">etl::aligned_union_t</a> = typedef typename <a class="el" href="structetl_1_1aligned__union.html">etl::aligned_union</a>&lt;Len, Types...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa19ff9e7939158584698cee4260e4471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19ff9e7939158584698cee4260e4471">&#9670;&nbsp;</a></span>bool_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">etl::bool_constant</a> = typedef <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;bool, B&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa107a29afbb5288d6dceb9fae86b07b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa107a29afbb5288d6dceb9fae86b07b8">&#9670;&nbsp;</a></span>true_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aa107a29afbb5288d6dceb9fae86b07b8">etl::true_type</a> = typedef <a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">bool_constant</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a466dc202e27dec8fa05a9fcc6ef47e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466dc202e27dec8fa05a9fcc6ef47e27">&#9670;&nbsp;</a></span>false_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a466dc202e27dec8fa05a9fcc6ef47e27">etl::false_type</a> = typedef <a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">bool_constant</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadad4ea85004a040c0e6e70341e2d221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadad4ea85004a040c0e6e70341e2d221">&#9670;&nbsp;</a></span>common_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aadad4ea85004a040c0e6e70341e2d221">etl::common_reference_t</a> = typedef typename <a class="el" href="structetl_1_1common__reference.html">common_reference</a>&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa474dd82a788a57735f0603b85954c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa474dd82a788a57735f0603b85954c37">&#9670;&nbsp;</a></span>common_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aa474dd82a788a57735f0603b85954c37">etl::common_type_t</a> = typedef typename <a class="el" href="structetl_1_1common__type.html">etl::common_type</a>&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27f0be4dd8251443fd1dbf06fa9c2bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f0be4dd8251443fd1dbf06fa9c2bde">&#9670;&nbsp;</a></span>conditional_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B, typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">etl::conditional_t</a> = typedef typename <a class="el" href="structetl_1_1conditional.html">etl::conditional</a>&lt;B, T, F&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaceeadc8f7b907c46772511ac5ec654c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaceeadc8f7b907c46772511ac5ec654c">&#9670;&nbsp;</a></span>decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">etl::decay_t</a> = typedef typename <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a2df4ab89284c8c5866afea3100f290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2df4ab89284c8c5866afea3100f290">&#9670;&nbsp;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B, typename T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a> = typedef typename <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt;B, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adee9f2213a709e3392d4d998d2a406f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee9f2213a709e3392d4d998d2a406f2">&#9670;&nbsp;</a></span>index_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#adee9f2213a709e3392d4d998d2a406f2">etl::index_constant</a> = typedef <a class="el" href="structetl_1_1integral__constant.html">etl::integral_constant</a>&lt;<a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>, I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93ed3feabd9624cf09aa604f49155cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ed3feabd9624cf09aa604f49155cc2">&#9670;&nbsp;</a></span>invoke_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... ArgTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a93ed3feabd9624cf09aa604f49155cc2">etl::invoke_result_t</a> = typedef typename <a class="el" href="structetl_1_1invoke__result.html">etl::invoke_result</a>&lt;F, ArgTypes...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c3c8b104138758267e7fc29e7aa2828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3c8b104138758267e7fc29e7aa2828">&#9670;&nbsp;</a></span>is_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a9c3c8b104138758267e7fc29e7aa2828">etl::is_constructible</a> = typedef detail::is_constructible_helper&lt;<a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">etl::void_t</a>&lt;&gt;, T, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abffe34c79351f871acb3e0438b2ad488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffe34c79351f871acb3e0438b2ad488">&#9670;&nbsp;</a></span>make_signed_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#abffe34c79351f871acb3e0438b2ad488">etl::make_signed_t</a> = typedef typename <a class="el" href="structetl_1_1make__signed.html">make_signed</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb2df53f4e399975501cf8300d451814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2df53f4e399975501cf8300d451814">&#9670;&nbsp;</a></span>make_unsigned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#acb2df53f4e399975501cf8300d451814">etl::make_unsigned_t</a> = typedef typename <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96e53fc126f7c9ebf9901856b9c2db22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e53fc126f7c9ebf9901856b9c2db22">&#9670;&nbsp;</a></span>remove_all_extents_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a96e53fc126f7c9ebf9901856b9c2db22">etl::remove_all_extents_t</a> = typedef typename <a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ceeb1a17bd47c943002a1c687be53c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ceeb1a17bd47c943002a1c687be53c1">&#9670;&nbsp;</a></span>remove_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a6ceeb1a17bd47c943002a1c687be53c1">etl::remove_const_t</a> = typedef typename <a class="el" href="structetl_1_1remove__const.html">etl::remove_const</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd0aad8fae1237db2f92705fe80729cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0aad8fae1237db2f92705fe80729cf">&#9670;&nbsp;</a></span>remove_cv_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">etl::remove_cv_t</a> = typedef <a class="el" href="namespaceetl.html#a6ceeb1a17bd47c943002a1c687be53c1">etl::remove_const_t</a>&lt;<a class="el" href="namespaceetl.html#a48541bce1229d664e678b7a89009200f">etl::remove_volatile_t</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0c34af472196537fb719bde6ab1c4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c34af472196537fb719bde6ab1c4ad">&#9670;&nbsp;</a></span>remove_cvref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac0c34af472196537fb719bde6ab1c4ad">etl::remove_cvref_t</a> = typedef <a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">etl::remove_cv_t</a>&lt;<a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">etl::remove_reference_t</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af678c3a5233d580ef71c70f11f076483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af678c3a5233d580ef71c70f11f076483">&#9670;&nbsp;</a></span>remove_extent_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#af678c3a5233d580ef71c70f11f076483">etl::remove_extent_t</a> = typedef typename <a class="el" href="structetl_1_1remove__extent.html">etl::remove_extent</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e186a746241ab4cfcf810655e8f7844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e186a746241ab4cfcf810655e8f7844">&#9670;&nbsp;</a></span>remove_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a5e186a746241ab4cfcf810655e8f7844">etl::remove_pointer_t</a> = typedef typename <a class="el" href="structetl_1_1remove__pointer.html">etl::remove_pointer</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab812e9b378e738c7b7b7fc34f4dab9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab812e9b378e738c7b7b7fc34f4dab9f3">&#9670;&nbsp;</a></span>remove_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">etl::remove_reference_t</a> = typedef typename <a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a7">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a48541bce1229d664e678b7a89009200f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48541bce1229d664e678b7a89009200f">&#9670;&nbsp;</a></span>remove_volatile_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a48541bce1229d664e678b7a89009200f">etl::remove_volatile_t</a> = typedef typename <a class="el" href="structetl_1_1remove__volatile.html">etl::remove_volatile</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af53ccea3515493c555e3a764ffea8ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53ccea3515493c555e3a764ffea8ff0">&#9670;&nbsp;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#af53ccea3515493c555e3a764ffea8ff0">etl::type_identity_t</a> = typedef T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fb4b27e61146521edc4ab6035681ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb4b27e61146521edc4ab6035681ed2">&#9670;&nbsp;</a></span>type_pack_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a9fb4b27e61146521edc4ab6035681ed2">etl::type_pack_element_t</a> = typedef typename <a class="el" href="structetl_1_1type__pack__element.html">type_pack_element</a>&lt;I, Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49061e75c4b48962719493fb046259e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49061e75c4b48962719493fb046259e2">&#9670;&nbsp;</a></span>underlying_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a49061e75c4b48962719493fb046259e2">etl::underlying_type_t</a> = typedef typename <a class="el" href="structetl_1_1underlying__type.html">etl::underlying_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a944255034d5f023db7654f5d8dbc9701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944255034d5f023db7654f5d8dbc9701">&#9670;&nbsp;</a></span>unwrap_ref_decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a944255034d5f023db7654f5d8dbc9701">etl::unwrap_ref_decay_t</a> = typedef typename <a class="el" href="structetl_1_1unwrap__ref__decay.html">etl::unwrap_ref_decay</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f76cc2621d7373b79e2fc034f160ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f76cc2621d7373b79e2fc034f160ee0">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">etl::void_t</a> = typedef void</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4271478b9ac53d8758a27dc93d55aa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4271478b9ac53d8758a27dc93d55aa8f">&#9670;&nbsp;</a></span>index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t... Ints&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a4271478b9ac53d8758a27dc93d55aa8f">etl::index_sequence</a> = typedef <a class="el" href="structetl_1_1integer__sequence.html">etl::integer_sequence</a>&lt;<a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>, Ints...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acca681165e818e6caaf5e237e8125ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca681165e818e6caaf5e237e8125ae8">&#9670;&nbsp;</a></span>make_index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#acca681165e818e6caaf5e237e8125ae8">etl::make_index_sequence</a> = typedef <a class="el" href="namespaceetl.html#ac5bd86337786fcf4b5b9ff86cdb9674d">etl::make_integer_sequence</a>&lt;<a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a131ba515ad6cb810a2d722fefb0a6325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131ba515ad6cb810a2d722fefb0a6325">&#9670;&nbsp;</a></span>index_sequence_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a131ba515ad6cb810a2d722fefb0a6325">etl::index_sequence_for</a> = typedef <a class="el" href="namespaceetl.html#acca681165e818e6caaf5e237e8125ae8">etl::make_index_sequence</a>&lt;sizeof...(T)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5bd86337786fcf4b5b9ff86cdb9674d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bd86337786fcf4b5b9ff86cdb9674d">&#9670;&nbsp;</a></span>make_integer_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac5bd86337786fcf4b5b9ff86cdb9674d">etl::make_integer_sequence</a> = typedef <a class="el" href="builtin__functions_8hpp.html#a303c6144751de3e45c44990112e8b1cb">TETL_BUILTIN_INT_SEQ</a>(T, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef7110ca07ee5b481d99d9ae57a977ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7110ca07ee5b481d99d9ae57a977ed">&#9670;&nbsp;</a></span>variant_alternative_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">etl::variant_alternative_t</a> = typedef typename <a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a>&lt;I, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aadba129a7dc760f449b09b7fafeb63a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadba129a7dc760f449b09b7fafeb63a8">&#9670;&nbsp;</a></span>endian</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8">etl::endian</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the endianness of all scalar types. If all scalar types are little-endian, <code><a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796">endian::native</a></code> equals <code><a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8aaae6635e044ac56046b2893a529b5114">endian::little</a></code>. If all scalar types are big-endian, <code><a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796">endian::native</a></code> equals <code><a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8ad861877da56b8b4ceb35c8cbfdf65bb4">endian::big</a></code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/endian">https://en.cppreference.com/w/cpp/types/endian</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aadba129a7dc760f449b09b7fafeb63a8aaae6635e044ac56046b2893a529b5114"></a>little&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aadba129a7dc760f449b09b7fafeb63a8ad861877da56b8b4ceb35c8cbfdf65bb4"></a>big&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796"></a>native&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="af524d0acb625979997f7a2dd1c0ea944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af524d0acb625979997f7a2dd1c0ea944">&#9670;&nbsp;</a></span>chars_format</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#af524d0acb625979997f7a2dd1c0ea944">etl::chars_format</a> : <a class="el" href="namespaceetl.html#ae4884330ffa7c8d259566d1344e12209">etl::uint8_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A BitmaskType used to specify floating-point formatting for to_chars and from_chars. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af524d0acb625979997f7a2dd1c0ea944a55a95650a66b53ecbb960b53d985b964"></a>scientific&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af524d0acb625979997f7a2dd1c0ea944acec315e3d0975e5cc2811d5d8725f149"></a>fixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af524d0acb625979997f7a2dd1c0ea944ab8d1b43eae73587ba56baef574709ecb"></a>hex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af524d0acb625979997f7a2dd1c0ea944a958153f1b8b96ec4c4eb2147429105d9"></a>general&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad4892bd9af0bd3ad759fb95ab241247c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4892bd9af0bd3ad759fb95ab241247c">&#9670;&nbsp;</a></span>float_denorm_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247c">etl::float_denorm_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247cadc095ee49d9e6884cd67bc20a4c73287"></a>denorm_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247caf254439f29ec6166a1a6fb7b09efd141"></a>denorm_absent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247ca5a085126714d6734d58691edaa278aa5"></a>denorm_present&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0cdec522db16c755ade7c7222bf8af92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdec522db16c755ade7c7222bf8af92">&#9670;&nbsp;</a></span>float_round_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92">etl::float_round_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92afd0fa1de009f9a47f51a0ec9c23aa10b"></a>round_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a00004115cf199c1cd29d07f78679a63d"></a>round_toward_zero&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a1fc678348a02cf4262fb59153d5b73c3"></a>round_to_nearest&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a274b79e7a1a164b8b9eea17dda4751c0"></a>round_toward_infinity&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92ac6babddc09b7dbf6e3daf12455e3417f"></a>round_toward_neg_infinity&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a91722a64a739818dbac515ddd4ea5387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91722a64a739818dbac515ddd4ea5387">&#9670;&nbsp;</a></span>align_val_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#a91722a64a739818dbac515ddd4ea5387">etl::align_val_t</a> : <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Both new-expression and delete-expression, when used with objects whose alignment requirement is greater than the default, pass that alignment requirement as an argument of type align_val_t to the selected allocation/deallocation function. </p>

</div>
</div>
<a id="abf855e66ccd0c031e0994ed578f1c170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf855e66ccd0c031e0994ed578f1c170">&#9670;&nbsp;</a></span>errc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170">etl::errc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The scoped enumeration <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170" title="The scoped enumeration etl::errc defines the values of portable error conditions that correspond to t...">etl::errc</a> defines the values of portable error conditions that correspond to the POSIX error codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8ab69162f060cc46b805b3265ad1cdf1"></a>address_family_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8e2bc80599069d337b43dff6edfb6891"></a>address_in_use&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a20abf2ffbf6e82e36405843f269d6438"></a>address_not_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ab5580b198f691ab2df12f5e2ab974373"></a>already_connected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a1b245b26b5ea3428c050d7f1503d7715"></a>argument_list_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a4b82222a0895b538d0597092b3ceab3e"></a>argument_out_of_domain&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aaf169f73a82794128aa491c4b4f1c071"></a>bad_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a9941c5c8c58ff058b870e94e96ac38e1"></a>bad_file_descriptor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ac7944ab5d2e25bf75b267d070b506d1c"></a>bad_message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2f0338eed54503152be1d31c93c9c2f1"></a>broken_pipe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2f8f27a7eef1ad585c7ab6f25a6c2c79"></a>connection_aborted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a81cf222a9b1530171fdfd66c3f734989"></a>connection_already_in_progress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a53793ee58fc24168a0d6549c3cb2df8e"></a>connection_refused&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abf39bfc8665384194e343c08ab344405"></a>connection_reset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6177070a517d51a4382ab0d7c88e5b58"></a>cross_device_link&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a326032e01f2a5e14c7f730f4d03d753a"></a>destination_address_required&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ab3ab5338a00f49c4451851cc5442f370"></a>device_or_resource_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6a336135d33e62f49edc55f29354e12e"></a>directory_not_empty&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a4dfaf9c996cf045f32d17edc9754fc95"></a>executable_format_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a41edf636e3c7b59f797348fc58472258"></a>file_exists&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa1e14bfb89b41ddf654b1772c8fd2e74"></a>file_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6e56e6ed055b9771b8192a4f229fee27"></a>filename_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa33c516bbdfb179cef733c8daeb97bed"></a>function_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170afe2377fbd16d7f335474e1df7d6376bf"></a>host_unreachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a054e5b4ff59331386872de744d661719"></a>identifier_removed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a53a9e57a679708b2d8ff0ccd8ec96b18"></a>illegal_byte_sequence&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a45fe7da1767194b580aeba752d7b44ae"></a>inappropriate_io_control_operation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170afadb76763385627e57ec386c9b6038f0"></a>interrupted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ae55d43eabeefe5a8271b4a3c898bd18f"></a>invalid_argument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abd86a2c65caf6a270b916234ab321ce3"></a>invalid_seek&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170acccc32f2a5f7dc7b87d2f85daea66789"></a>io_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170af3c51d7ea75a76f26c0a2bdc00c4e006"></a>is_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ade5f4bc2f8a4690176e22e83196b9fd3"></a>message_size&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a93b16d34b1689f66f0cfed60e99c0009"></a>network_down&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a0e1d200ae35ede416bf85f84093ce37a"></a>network_reset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a608a68344b4eb1fe0690861a83828816"></a>network_unreachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a618ead44397b73cf0baa08b460b66c39"></a>no_buffer_space&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad08d4c854a6810cebd2a8ab61876f919"></a>no_child_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170add431dfaf61ea842693dca8be1ebcaf7"></a>no_link&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a58688487c3e24313637a76bd29881e64"></a>no_lock_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aeec0f03ad92584c78835c10ab79d7f42"></a>no_message_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170acec935db07cfc57caafa37e98eafb213"></a>no_message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abed8a9032d9366c28582a0ad59a31525"></a>no_protocol_option&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a1a5334dd8d1ca56e33887bd44630641b"></a>no_space_on_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad8b1d94a0ac09c6d55b2ed68f0836142"></a>no_stream_resources&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a5c83a012eac17bbf458df5804801e373"></a>no_such_device_or_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170af42b2e58729e2783b683c8610977fc22"></a>no_such_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2e70fc89b08f26fa3fc77694c91e8f7a"></a>no_such_file_or_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad91a9b8a734f2bef4b778f89806cbab7"></a>no_such_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a21e867ca95e1dfecff4701863547dcec"></a>not_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a22ac64bb14c46bcbc338a21950b6e722"></a>not_a_socket&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6e752b7a04543e5052b2d0dd05eca0fa"></a>not_a_stream&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a69c2dbb5917ca550a862e9c1c839bca1"></a>not_connected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aafdb5594dc3e484fc1bfd7c564d550c1"></a>not_enough_memory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa55e82356e9721946aa9ba954733c6f0"></a>not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170afd3d0bdcc9eb9e68534b7d055c5fe586"></a>operation_canceled&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a4c7eb50b6d86ac8a130ebebc18dbe263"></a>operation_in_progress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8344b3d509942f035d5e303022f9b986"></a>operation_not_permitted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a69bf074bf052ee4c9047b62fe7c24569"></a>operation_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a738abdaead9cd7b2e2ea19a34764b385"></a>operation_would_block&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2abac2fa6722c56b2ea17ac6c4097f68"></a>owner_dead&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ae8ee838822072f02738dbd7d97ea03fc"></a>permission_denied&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a9665c745d0a9132d8da6ed55e89a0564"></a>protocol_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa2635acef8b9a3e1c40923829722d472"></a>protocol_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a06108efce8ef1cd8aa4cc440f8b4317f"></a>read_only_file_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aed65f7649c6f0e365673d65a9d8119d8"></a>resource_deadlock_would_occur&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ae46a97ea2906921c8c626890bde832cf"></a>resource_unavailable_try_again&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8e0fafb181567cc468e1ee81983d739d"></a>result_out_of_range&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6805059549401365b824b54573a6f46e"></a>state_not_recoverable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ac1a620a30954dc9402a811453c2c3e3f"></a>stream_timeout&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad2f80f12d22bb099fcf1062db660b567"></a>text_file_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a56c27b1ab1a5a5a0eae853cabb4dc0c1"></a>timed_out&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a3130d1d4e000cdc1e7c47013e313c10e"></a>too_many_files_open_in_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aed2c33c8fe874cfeba6f4a7747c62d05"></a>too_many_files_open&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abfe22fc9b27a8ff13186aba60b6bc5c8"></a>too_many_links&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a33c78baca1480479c88aa4d50cb68206"></a>too_many_symbolic_link_levels&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a143653b075bff946193644ba6d97fa5d"></a>value_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a81cac28a38438710de9856af4a8bcd0b"></a>wrong_protocol_type&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a035e7d2ea0f6aebad724e7fab40495d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035e7d2ea0f6aebad724e7fab40495d5">&#9670;&nbsp;</a></span>implementation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#a035e7d2ea0f6aebad724e7fab40495d5">etl::implementation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a035e7d2ea0f6aebad724e7fab40495d5aed920a9dd5bae2e1c4f11aab8f5784e1"></a>freestanding&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a035e7d2ea0f6aebad724e7fab40495d5a734d3030ff72ad8d9678efa82b1db7d2"></a>hosted&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a2f63a594bf7e2b29cb07e1868483ee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f63a594bf7e2b29cb07e1868483ee53">&#9670;&nbsp;</a></span>language_standard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">etl::language_standard</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration for the currently selected C++ standard version. Unlike the official macro <code>__cplusplus</code>, these values only include the published year. This is to make the actual values smaller and therfore fit on smaller word sized chips. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2f63a594bf7e2b29cb07e1868483ee53a6289bbfa378818f7066ccad5847da5a2"></a>cpp_17&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2f63a594bf7e2b29cb07e1868483ee53a4c7aabdc3eb0d845c62edfb822b0fe5a"></a>cpp_20&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2f63a594bf7e2b29cb07e1868483ee53af7d98f68372c9de30cc2d571b75b19d7"></a>cpp_23&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2f63a594bf7e2b29cb07e1868483ee53af94629088b2e56f93753526b629a62ff"></a>cpp_26&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a46270726b5073fd6eeefb5ccd9ed1f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46270726b5073fd6eeefb5ccd9ed1f72">&#9670;&nbsp;</a></span>bubble_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::bubble_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. <a href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a>. </p>

</div>
</div>
<a id="a1cc149eb7abea4405c02e767e7860dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc149eb7abea4405c02e767e7860dae">&#9670;&nbsp;</a></span>bubble_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::bubble_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f9162720047d01bb438874bf56df5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9162720047d01bb438874bf56df5d2">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::count </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;InputIt&gt;::difference_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts the elements that are equal to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">value</td><td>The value to search for.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a> </p>

</div>
</div>
<a id="a9be834c1a5353b7d9b51d77cd30a9654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be834c1a5353b7d9b51d77cd30a9654">&#9670;&nbsp;</a></span>equal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the range <code>[first1, last1)</code> is equal to the range <code>[first2, first2 + (last1 - first1))</code>, and false otherwise. </p>

</div>
</div>
<a id="a934bfc901fe1ed60e93f7f9b9fb34079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934bfc901fe1ed60e93f7f9b9fb34079">&#9670;&nbsp;</a></span>equal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dda20bb1c4958e2a9ce23f6ebd4fb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dda20bb1c4958e2a9ce23f6ebd4fb9c">&#9670;&nbsp;</a></span>equal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19bb44dc832eef8b58d30b1cc70411ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bb44dc832eef8b58d30b1cc70411ff">&#9670;&nbsp;</a></span>equal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a292ca875d178a8cfb23a5b2f74d5ed33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292ca875d178a8cfb23a5b2f74d5ed33">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::equal_range </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;ForwardIt, ForwardIt&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements equivalent to value in the range <code>[first, last)</code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">https://en.cppreference.com/w/cpp/algorithm/equal_range</a> </p>

</div>
</div>
<a id="af67b5001d764da2ece198e4fc86fde26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67b5001d764da2ece198e4fc86fde26">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::equal_range </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;ForwardIt, ForwardIt&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a086d2ed75d087dea9497d60549d77485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086d2ed75d087dea9497d60549d77485">&#9670;&nbsp;</a></span>exchange_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::exchange_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort">https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort</a>. </p>

</div>
</div>
<a id="a9635d27783910f84b9a83730f26f2c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9635d27783910f84b9a83730f26f2c19">&#9670;&nbsp;</a></span>exchange_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::exchange_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa11bb84e871a5db6b2a230e5ef065234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11bb84e871a5db6b2a230e5ef065234">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the given value to the elements in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ad5ac240345a96ad39668967bf8bdf76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ac240345a96ad39668967bf8bdf76f">&#9670;&nbsp;</a></span>fill_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIt , typename Size , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fill_n </td>
          <td>(</td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the given value to the first count elements in the range beginning at <code>first</code> if <code>count &gt; 0</code>. Does nothing otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator one past the last element assigned if <code>count &gt; 0</code>, <code>first</code> otherwise. </dd></dl>

</div>
</div>
<a id="a074d4da4cb7d3a678c5ae1fce471ddfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074d4da4cb7d3a678c5ae1fce471ddfb">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element equal to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">value</td><td>Value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="algorithm_8cpp-example.html#a0">algorithm.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7c8d78c0146673a9463dc7c68540b963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8d78c0146673a9463dc7c68540b963">&#9670;&nbsp;</a></span>find_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find_end </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>sFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>sLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt1
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the last occurrence of the sequence [sFirst, sLast) in the range <code>[first, last)</code>. Elements are compared using the given binary predicate p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for </td></tr>
    <tr><td class="paramname">p</td><td>Binary predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the beginning of last occurrence of the sequence [sFirst, sLast) in range <code>[first, last)</code>. If [sFirst, sLast) is empty or if no such sequence is found, last is returned. </dd></dl>

</div>
</div>
<a id="a67a3af0f6b1ea2008b53ed21446814f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a3af0f6b1ea2008b53ed21446814f5">&#9670;&nbsp;</a></span>find_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find_end </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>sFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>sLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt1
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea99982a37144ad397257540600269a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea99982a37144ad397257540600269a0">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find_first_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>sFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>sLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). Elements are compared using the given binary predicate pred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">pred</td><td>Predicate which returns ​true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find_first_of">https://en.cppreference.com/w/cpp/algorithm/find_first_of</a> </p>

</div>
</div>
<a id="a4931d3f143272627df883beae8bd9bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4931d3f143272627df883beae8bd9bd5">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find_first_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>sFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>sLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find_first_of">https://en.cppreference.com/w/cpp/algorithm/find_first_of</a> </p>

</div>
</div>
<a id="a9c802502e6a81c3b77d98dbcaf030c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c802502e6a81c3b77d98dbcaf030c19">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find_if </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate p returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Unary predicate which returns ​true for the required element.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>

</div>
</div>
<a id="a29e68ff6f7166005f9862c8772fa43fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e68ff6f7166005f9862c8772fa43fd">&#9670;&nbsp;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find_if_not </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate q returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Unary predicate which returns ​true for the required element.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>

</div>
</div>
<a id="a3ad01de69ea01da886464fc3ef1390cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad01de69ea01da886464fc3ef1390cc">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename UnaryFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::for_each </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunc&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; UnaryFunc
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, last)</code> in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range to apply the function to. </td></tr>
    <tr><td class="paramname">last</td><td>The range to apply the function to. </td></tr>
    <tr><td class="paramname">f</td><td>Function object, to be applied to the result of dereferencing every iterator in the range.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/for_each">https://en.cppreference.com/w/cpp/algorithm/for_each</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="algorithm_8cpp-example.html#a1">algorithm.cpp</a>, and <a class="el" href="set_8cpp-example.html#a1">set.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab9839f986201c53e618b3435d27ad43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9839f986201c53e618b3435d27ad43a">&#9670;&nbsp;</a></span>for_each_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Size , typename UnaryFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::for_each_n </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunc&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, first + n]</code> in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range to apply the function to. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements to apply the function to. </td></tr>
    <tr><td class="paramname">f</td><td>Function object, to be applied to the result of dereferencing every iterator in the range.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/for_each_n">https://en.cppreference.com/w/cpp/algorithm/for_each_n</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="algorithm_8cpp-example.html#a2">algorithm.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0b963791bdb1da038a64b23555f245c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b963791bdb1da038a64b23555f245c4">&#9670;&nbsp;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Generator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::generate </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns each element in range <code>[first, last)</code> a value generated by the given function object g. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">g</td><td>Generator function object that will be called.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/generate">https://en.cppreference.com/w/cpp/algorithm/generate</a> </p>

</div>
</div>
<a id="ab984bfa2eb0fd6da7369b629ca3acdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984bfa2eb0fd6da7369b629ca3acdc7">&#9670;&nbsp;</a></span>generate_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIt , typename SizeT , typename Generator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::generate_n </td>
          <td>(</td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeT&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns values, generated by given function object <code>g</code>, to the first count elements in the range beginning at <code>first</code>, if <code>count &gt; 0</code>. Does nothing otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">count</td><td>Number of the elements to generate. </td></tr>
    <tr><td class="paramname">g</td><td>Generator function object that will be called.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/generate_n">https://en.cppreference.com/w/cpp/algorithm/generate_n</a> </p>

</div>
</div>
<a id="a72d92f2387c738f0636ab8495aa18613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d92f2387c738f0636ab8495aa18613">&#9670;&nbsp;</a></span>gnome_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::gnome_sort </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Gnome_sort">https://en.wikipedia.org/wiki/Gnome_sort</a>. </p>

</div>
</div>
<a id="add4a4559a0af0147ebc0d7572dbc142e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4a4559a0af0147ebc0d7572dbc142e">&#9670;&nbsp;</a></span>gnome_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::gnome_sort </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc7d9a038b385aff889235d470b837e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7d9a038b385aff889235d470b837e4">&#9670;&nbsp;</a></span>includes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::includes </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the sorted range <code>[first2, last2)</code> is a subsequence of the sorted range <code>[first1, last1)</code>. Both ranges must be sorted. </p>

</div>
</div>
<a id="a2f97df033ed5dc7c5458f991078633d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f97df033ed5dc7c5458f991078633d9">&#9670;&nbsp;</a></span>includes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::includes </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8a63b710f7e13e8142d025fe5f2ef94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a63b710f7e13e8142d025fe5f2ef94">&#9670;&nbsp;</a></span>inplace_merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::inplace_merge </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>mid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). </p>
<p>A sequence [first, last) is said to be sorted with respect to a comparator comp if for any iterator it pointing comp(*(it + n), *it) evaluates to false.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/inplace_merge">https://en.cppreference.com/w/cpp/algorithm/inplace_merge</a> </p>

</div>
</div>
<a id="a0e9e7376359b4a88a505f218d6aa0ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9e7376359b4a88a505f218d6aa0ddc">&#9670;&nbsp;</a></span>inplace_merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::inplace_merge </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>mid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0080a41003199426077c02b6175ae904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0080a41003199426077c02b6175ae904">&#9670;&nbsp;</a></span>insertion_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::insertion_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. <a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a>. </p>

</div>
</div>
<a id="a5e6d5b25a5beae6b886f7eaccb6ccfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6d5b25a5beae6b886f7eaccb6ccfd2">&#9670;&nbsp;</a></span>insertion_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::insertion_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a577d3ae817b5678a0a0b91213a403c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577d3ae817b5678a0a0b91213a403c21">&#9670;&nbsp;</a></span>is_partitioned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_partitioned </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements in the range <code>[first, last)</code> that satisfy the predicate p appear before all elements that don't. Also returns true if the range is empty. <a href="https://en.cppreference.com/w/cpp/algorithm/is_partitioned">https://en.cppreference.com/w/cpp/algorithm/is_partitioned</a>. </p>

</div>
</div>
<a id="a01459034f5f84e415ed7c9f73700b54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01459034f5f84e415ed7c9f73700b54f">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there exists a permutation of the elements in the range <code>[first1, last1)</code> that makes that range equal to the range <code>[first2, last2)</code>, where <code>last2</code> denotes <code>first2 + (last1 - first1)</code> if it was not given. </p>

</div>
</div>
<a id="adc05db4110903905f00fc26bb6de03a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc05db4110903905f00fc26bb6de03a1">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a671187bf1a3dd1a99a1acfada1927fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671187bf1a3dd1a99a1acfada1927fcf">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_sorted </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the elements in range <code>[first, last)</code> are sorted in non-descending order. </p>

</div>
</div>
<a id="ab728b1a920fd45e985ed73b9874fcb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab728b1a920fd45e985ed73b9874fcb7d">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_sorted </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26cb4df55d0b061279b599134e294f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cb4df55d0b061279b599134e294f22">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04cca9919e02704d1dd11db707e679ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cca9919e02704d1dd11db707e679ee">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the range <code>[first, last)</code> and finds the largest range beginning at <code>first</code> in which the elements are sorted in non-descending order. </p>

</div>
</div>
<a id="aa18b878794474881fce640e7a163abf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18b878794474881fce640e7a163abf3">&#9670;&nbsp;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iter_swap </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the values of the elements the given iterators are pointing to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Iterators to the elements to swap. </td></tr>
    <tr><td class="paramname">b</td><td>Iterators to the elements to swap.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/iter_swap">https://en.cppreference.com/w/cpp/algorithm/iter_swap</a> </p>

</div>
</div>
<a id="a73951d21be0807534a52bbd26b866f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73951d21be0807534a52bbd26b866f7b">&#9670;&nbsp;</a></span>lexicographical_compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the first range <code>[f1, l1)</code> is lexicographically less than the second range <code>[f2, l2)</code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare</a> </p>

</div>
</div>
<a id="a386a232aa903a5387aa91c4ed5194d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386a232aa903a5387aa91c4ed5194d9f">&#9670;&nbsp;</a></span>lexicographical_compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>l2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a779ffb051a7e52e4702eb01aa18f167f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779ffb051a7e52e4702eb01aa18f167f">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lower_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is not less than (i.e. greater or equal to) value, or last if no such element is found. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a> </p>

</div>
</div>
<a id="a9fb1800f39f2305708f67187a3a49993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb1800f39f2305708f67187a3a49993">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lower_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fdd0cf88f36f44f8fe8ec8327cfac74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdd0cf88f36f44f8fe8ec8327cfac74">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b. </p>

</div>
</div>
<a id="a220fbd23aca7dbc728c200471ed114c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220fbd23aca7dbc728c200471ed114c8">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b, using a compare function. </p>

</div>
</div>
<a id="abc62e1e0c57de79b8b007265bc308ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc62e1e0c57de79b8b007265bc308ec2">&#9670;&nbsp;</a></span>max_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="aedcf261d2d7377e2284ab3f5738b34e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcf261d2d7377e2284ab3f5738b34e1">&#9670;&nbsp;</a></span>max_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="a9ee09e4768fc381002cd7dc14e8e561b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee09e4768fc381002cd7dc14e8e561b">&#9670;&nbsp;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::merge </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into one sorted range beginning at <code>destination</code>. </p>

</div>
</div>
<a id="a6d0face2f5fe06333854b6b120bd6bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0face2f5fe06333854b6b120bd6bad">&#9670;&nbsp;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::merge </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bffa34e9bd6075ec150aa9e30153950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bffa34e9bd6075ec150aa9e30153950">&#9670;&nbsp;</a></span>merge_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::merge_sort </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a>. </p>

</div>
</div>
<a id="a4da0fcb091026bf11e56eb257e9d3bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da0fcb091026bf11e56eb257e9d3bc5">&#9670;&nbsp;</a></span>merge_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::merge_sort </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adae1500815312b248e453896d5439b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae1500815312b248e453896d5439b63">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b. </p>

</div>
</div>
<a id="a479c4a8315ae3ef2d1128858d723afc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479c4a8315ae3ef2d1128858d723afc2">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b, using a compare function. </p>

</div>
</div>
<a id="a71878538e0e2b2f8026ed657836382c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71878538e0e2b2f8026ed657836382c0">&#9670;&nbsp;</a></span>min_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="a4af4c7706179eef16ba76242c48518a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af4c7706179eef16ba76242c48518a9">&#9670;&nbsp;</a></span>min_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="ae81f900b934c83cdb278826ede239e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81f900b934c83cdb278826ede239e6b">&#9670;&nbsp;</a></span>minmax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::minmax </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T const&amp;, T const&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest and the greatest of the given values. </p>

</div>
</div>
<a id="a1a85dc58adf499e8f90a9e9c4eb0594a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a85dc58adf499e8f90a9e9c4eb0594a">&#9670;&nbsp;</a></span>minmax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::minmax </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T const&amp;, T const&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest and the greatest of the given values. </p>

</div>
</div>
<a id="adf3573e5fccf8f6ff5d8636e23b1ffa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3573e5fccf8f6ff5d8636e23b1ffa0">&#9670;&nbsp;</a></span>minmax_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::minmax_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;ForwardIt, ForwardIt&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest and greatest element in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="a3442eebc68bb878d66ab8a37478ff679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3442eebc68bb878d66ab8a37478ff679">&#9670;&nbsp;</a></span>minmax_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::minmax_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;ForwardIt, ForwardIt&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest and greatest element in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="a5674e86a91ac9cb808d365aa09d5d07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5674e86a91ac9cb808d365aa09d5d07f">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::mismatch </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;InputIt1, InputIt2&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first mismatching pair of elements from two ranges: one defined by <code>[first1, last1)</code> and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). Elements are compared using the given binary predicate pred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The first range of the elements. </td></tr>
    <tr><td class="paramname">last1</td><td>The first range of the elements. </td></tr>
    <tr><td class="paramname">first2</td><td>The second range of the elements. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns ​true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/mismatch">https://en.cppreference.com/w/cpp/algorithm/mismatch</a> </p>

</div>
</div>
<a id="ae399b1c12f42fcf2365021710f1e1667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae399b1c12f42fcf2365021710f1e1667">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::mismatch </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;InputIt1, InputIt2&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85be5a2493fc37bb07bab46871d7732b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85be5a2493fc37bb07bab46871d7732b">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::mismatch </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;InputIt1, InputIt2&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8936cbbb27640ce6d9411dd5bc4859b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8936cbbb27640ce6d9411dd5bc4859b3">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::mismatch </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;InputIt1, InputIt2&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b8df3814fc65f04932c2f0d09a56107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8df3814fc65f04932c2f0d09a56107">&#9670;&nbsp;</a></span>move() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::move </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the elements in the range <code>[first, last)</code>, to another range beginning at destination, starting from first and proceeding to <code>last - 1</code>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">destination</td><td>The beginning of the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element past the last element moved.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/move">https://en.cppreference.com/w/cpp/algorithm/move</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="optional_8cpp-example.html#a2">optional.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a739385d15b43be76e906acbc6e6459a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739385d15b43be76e906acbc6e6459a5">&#9670;&nbsp;</a></span>move_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt1 , typename BidirIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::move_backward </td>
          <td>(</td>
          <td class="paramtype">BidirIt1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt2&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; BidirIt2
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the elements from the range <code>[first, last)</code>, to another range ending at destination. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">destination</td><td>End of the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator in the destination range, pointing at the last element moved.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/move_backward">https://en.cppreference.com/w/cpp/algorithm/move_backward</a> </p>

</div>
</div>
<a id="ae2b5fe643bd62734bbb66af22e88544c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b5fe643bd62734bbb66af22e88544c">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::none_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for no elements in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ade97d95e33160e2176476b303cacc224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade97d95e33160e2176476b303cacc224">&#9670;&nbsp;</a></span>nth_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nth_element </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>nth_element is a partial sorting algorithm that rearranges elements in <code>[first, last)</code> such that: </p>
<ul>
<li>The element pointed at by nth is changed to whatever element would occur in that position if <code>[first, last)</code> were sorted.</li>
<li>All of the elements before this new nth element are less than or equal to the elements after the new nth element.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/nth_element">https://en.cppreference.com/w/cpp/algorithm/nth_element</a> </p>

</div>
</div>
<a id="a31997e04071d6cfa4b887e46783efbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31997e04071d6cfa4b887e46783efbf3">&#9670;&nbsp;</a></span>nth_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nth_element </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61d1bed984c0aceff254e912cf251c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d1bed984c0aceff254e912cf251c6e">&#9670;&nbsp;</a></span>partial_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::partial_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rearranges elements such that the range <code>[first, middle)</code> contains the sorted <code>middle - first</code> smallest elements in the range <code>[first, last)</code>. The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range <code>[middle, last)</code> is unspecified. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/partial_sort">https://en.cppreference.com/w/cpp/algorithm/partial_sort</a> </p>

</div>
</div>
<a id="adf059ef9f744ed7d731faa69834ddc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf059ef9f744ed7d731faa69834ddc9a">&#9670;&nbsp;</a></span>partial_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::partial_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94c256595c3b4e99c28c50d5f1c0d73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c256595c3b4e99c28c50d5f1c0d73f">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::partition </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved. </p>

</div>
</div>
<a id="ad34f1c15b38f8436c5d6dcc1f9f38491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34f1c15b38f8436c5d6dcc1f9f38491">&#9670;&nbsp;</a></span>partition_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt1 , typename OutputIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::partition_copy </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt1&#160;</td>
          <td class="paramname"><em>destinationTrue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt2&#160;</td>
          <td class="paramname"><em>destinationFalse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;OutputIt1, OutputIt2&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code> to two different ranges depending on the value returned by the predicate p. The elements that satisfy the predicate p are copied to the range beginning at destination_true. The rest of the elements are copied to the range beginning at destination_false. </p>
<p>The behavior is undefined if the input range overlaps either of the output ranges. </p>

</div>
</div>
<a id="a8d4c550073b16bc102ef6b2447cc31d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4c550073b16bc102ef6b2447cc31d6">&#9670;&nbsp;</a></span>partition_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::partition_point </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the partitioned (as if by partition) range [first, last) and locates the end of the first partition, that is, the first element that does not satisfy p or last if all elements satisfy p. </p>

</div>
</div>
<a id="adde454dc915d0c4c32bd8041b0bd8ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde454dc915d0c4c32bd8041b0bd8ecf">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::remove </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range. </p>

</div>
</div>
<a id="a7e0bacdf9416ed0db41e5527c7bb1b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0bacdf9416ed0db41e5527c7bb1b29">&#9670;&nbsp;</a></span>remove_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::remove_copy </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements that are equal to value. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element copied. </dd></dl>

</div>
</div>
<a id="a68dc3e941f0f6b0d00f923fec94b6694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dc3e941f0f6b0d00f923fec94b6694">&#9670;&nbsp;</a></span>remove_copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements for which predicate p returns true. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element copied. </dd></dl>

</div>
</div>
<a id="a5dc5f42480a4033b9a58cb5c7236fbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc5f42480a4033b9a58cb5c7236fbee">&#9670;&nbsp;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::remove_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range. </p>

</div>
</div>
<a id="ab115e24caa45f16f79bb770a6e3cbbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab115e24caa45f16f79bb770a6e3cbbab">&#9670;&nbsp;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::replace </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>oldValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements that are equal to old_value. </p>

</div>
</div>
<a id="a290953b933269399f045b7e2b37d97b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290953b933269399f045b7e2b37d97b7">&#9670;&nbsp;</a></span>replace_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::replace_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements for which predicate p returns true. </p>

</div>
</div>
<a id="aa198aa5e9e5759947d51496cede4e6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa198aa5e9e5759947d51496cede4e6f6">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::reverse </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of the elements in the range <code>[first, last)</code>. Behaves as if applying iter_swap to every pair of iterators <code>first + i</code>, <code>(last-i) - 1</code> for each non-negative <code>i &lt; (last - first) / 2</code>. </p>

</div>
</div>
<a id="ae0246fc85a8996116ecfe4be33cd1495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0246fc85a8996116ecfe4be33cd1495">&#9670;&nbsp;</a></span>reverse_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::reverse_copy </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code> to another range beginning at d_first in such a way that the elements in the new range are in reverse order. </p>
<p>If the source and destination ranges (that is, <code>[first, last)</code> and [d_first, d_first+(last-first)) respectively) overlap, the behavior is undefined. </p>

</div>
</div>
<a id="a1c0cdef8cb8f1fb054c43f8aadb43d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0cdef8cb8f1fb054c43f8aadb43d36">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rotate </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>nFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotation on a range of elements. </p>
<p>Specifically, rotate swaps the elements in the range [first, last) in such a way that the element n_first becomes the first element of the new range and n_first - 1 becomes the last element. A precondition of this function is that [first, n_first) and [n_first, last) are valid ranges. </p>

</div>
</div>
<a id="ad0d28d5f25cdee05003b4190e57dd519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d28d5f25cdee05003b4190e57dd519">&#9670;&nbsp;</a></span>rotate_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rotate_copy </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>nFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at destination in such a way, that the element <code>nFirst</code> becomes the first element of the new range and <code>nFirst - 1</code> becomes the last element. </p>

</div>
</div>
<a id="af39a57bc56c6f3c0bf94045777e9f274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39a57bc56c6f3c0bf94045777e9f274">&#9670;&nbsp;</a></span>search() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIt1 , typename FwdIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::search </td>
          <td>(</td>
          <td class="paramtype">FwdIt1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt2&#160;</td>
          <td class="paramname"><em>sFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt2&#160;</td>
          <td class="paramname"><em>sLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; FwdIt1
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range <code>[first, last)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns ​true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/search">https://en.cppreference.com/w/cpp/algorithm/search</a> </p>

</div>
</div>
<a id="a5e8c774a650ce6535a79e6a11dd90fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8c774a650ce6535a79e6a11dd90fdf">&#9670;&nbsp;</a></span>search() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIt1 , typename FwdIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::search </td>
          <td>(</td>
          <td class="paramtype">FwdIt1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt2&#160;</td>
          <td class="paramname"><em>sFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt2&#160;</td>
          <td class="paramname"><em>sLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; FwdIt1
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21a90d9aad4e00eb080d9dce99472a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a90d9aad4e00eb080d9dce99472a40">&#9670;&nbsp;</a></span>search() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIt , typename Searcher &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::search </td>
          <td>(</td>
          <td class="paramtype">FwdIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Searcher const &amp;&#160;</td>
          <td class="paramname"><em>searcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; FwdIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a047bb8dc9dd92624ad901db1d27e5d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047bb8dc9dd92624ad901db1d27e5d83">&#9670;&nbsp;</a></span>search_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Size , typename ValueT , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::search_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value. </p>

</div>
</div>
<a id="a6c8fcaf19422ff5c92791797f6373260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8fcaf19422ff5c92791797f6373260">&#9670;&nbsp;</a></span>search_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Size , typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::search_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a563244b70e444026e7ddee3ad609b4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563244b70e444026e7ddee3ad609b4a5">&#9670;&nbsp;</a></span>set_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::set_difference </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same. </p>

</div>
</div>
<a id="a50c804f0766a786779b7c17886e601a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c804f0766a786779b7c17886e601a2">&#9670;&nbsp;</a></span>set_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::set_difference </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6670fa3cc294c702e9b6245c55a1da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6670fa3cc294c702e9b6245c55a1da4">&#9670;&nbsp;</a></span>set_intersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::set_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges. </p>

</div>
</div>
<a id="a47a31828bddd42fb93f6afb491bd4b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a31828bddd42fb93f6afb491bd4b4f">&#9670;&nbsp;</a></span>set_intersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::set_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40c7a269a772f000cb710d042d7aee20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c7a269a772f000cb710d042d7aee20">&#9670;&nbsp;</a></span>set_symmetric_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes symmetric difference of two sorted ranges: the elements that are found in either of the ranges, but not in both of them are copied to the range beginning at destination. The resulting range is also sorted. </p>

</div>
</div>
<a id="ac0e87148d2ced5612a3f9f09fd4eb941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e87148d2ced5612a3f9f09fd4eb941">&#9670;&nbsp;</a></span>set_symmetric_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9009346ce6e69bac2a9406592192aef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9009346ce6e69bac2a9406592192aef1">&#9670;&nbsp;</a></span>set_union() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::set_union </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges. </p>

</div>
</div>
<a id="a4c31225d785d8d6b0702705ce2706c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c31225d785d8d6b0702705ce2706c53">&#9670;&nbsp;</a></span>set_union() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::set_union </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9df8e5c73b49b744646fa291c63525c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df8e5c73b49b744646fa291c63525c1">&#9670;&nbsp;</a></span>shift_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::shift_left </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt const&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; ForwardIt &gt;::difference_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts the elements in the range [first, last) by n positions. </p>
<p>Shifts the elements towards the beginning of the range. If n == 0 || n &gt;= last - first, there are no effects. If n &lt; 0, the behavior is undefined. Otherwise, for every integer i in [0, last - first - n), moves the element originally at position first + n + i to position first + i. The moves are performed in increasing order of i starting from ​0​. </p>

</div>
</div>
<a id="a828f0e293b30f2af1151a2de5ef8d26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828f0e293b30f2af1151a2de5ef8d26e">&#9670;&nbsp;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidiIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::shift_right </td>
          <td>(</td>
          <td class="paramtype">BidiIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidiIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; BidiIt &gt;::difference_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; BidiIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts the elements in the range [first, last) by n positions. </p>
<p>Shifts the elements towards the end of the range. If n &lt;= 0 || n &gt;= last - first, there are no effects. Otherwise, for every integer i in [0, last - first - n), moves the element originally at position first + i to position first + n + i.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/shift">https://en.cppreference.com/w/cpp/algorithm/shift</a></p>
<dl class="section note"><dt>Note</dt><dd>The standard specifies that this algorithm should also work with legacy forward iterators. I don't know how to implement that without dynamic memory, so forward iterators are not supported. </dd></dl>

</div>
</div>
<a id="adda62f64ad31faeb43dab1bbe8b2a664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda62f64ad31faeb43dab1bbe8b2a664">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is not guaranteed to be preserved. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a> </p>

</div>
</div>
<a id="a29031b0fee25653ff42e6fab29670267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29031b0fee25653ff42e6fab29670267">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04627f836421020d549c77618e404bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04627f836421020d549c77618e404bef">&#9670;&nbsp;</a></span>stable_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stable_partition </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; BidirIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved. </p>

</div>
</div>
<a id="aba546db0dc7852f32bae5b43c1cbb973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba546db0dc7852f32bae5b43c1cbb973">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stable_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equivalent elements is guaranteed to be preserved. Elements are compared using the given comparison function comp. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/stable_sort">https://en.cppreference.com/w/cpp/algorithm/stable_sort</a> </p>

</div>
</div>
<a id="a018602a1181cba5553c619612ae2bf58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018602a1181cba5553c619612ae2bf58">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stable_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2864370cd9173ff7ac8fb507dd6779a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2864370cd9173ff7ac8fb507dd6779a">&#9670;&nbsp;</a></span>swap_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::swap_ranges </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt2
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges elements between range <code>[first1 ,last1)</code> and another range starting at <code>first2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The first range of elements to swap. </td></tr>
    <tr><td class="paramname">last1</td><td>The first range of elements to swap. </td></tr>
    <tr><td class="paramname">first2</td><td>Beginning of the second range of elements to swap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element exchanged in the range beginning with <code>first2</code>.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap_ranges">https://en.cppreference.com/w/cpp/algorithm/swap_ranges</a> </p>

</div>
</div>
<a id="a4467ebe5b0d985e1661eb04cb65fab6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4467ebe5b0d985e1661eb04cb65fab6a">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename UnaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::transform </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function to a range and stores the result in another range, beginning at dest. The unary operation op is applied to the range defined by <code>[first, last)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first range of elements to transform. </td></tr>
    <tr><td class="paramname">last</td><td>The first range of elements to transform. </td></tr>
    <tr><td class="paramname">dest</td><td>The beginning of the destination range, may be equal to first. </td></tr>
    <tr><td class="paramname">op</td><td>Unary operation function object that will be applied.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform">https://en.cppreference.com/w/cpp/algorithm/transform</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="string_8cpp-example.html#a4">string.cpp</a>, and <a class="el" href="vector_8cpp-example.html#a5">vector.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab2860fb376fc216b93922e036f8ead03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2860fb376fc216b93922e036f8ead03">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename BinaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::transform </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ff9322bfeec8125aeb86d43fee6fade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9322bfeec8125aeb86d43fee6fade">&#9670;&nbsp;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unique </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range. </p>

</div>
</div>
<a id="a438b893eeeaa7e54c01596344dbc939d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438b893eeeaa7e54c01596344dbc939d">&#9670;&nbsp;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unique </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range. </p>

</div>
</div>
<a id="ab8e100f1e4a026e9d4789c972b7a4c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e100f1e4a026e9d4789c972b7a4c8d">&#9670;&nbsp;</a></span>unique_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unique_copy </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied. </p>
<p>Elements are compared using the given binary predicate pred. The behavior is undefined if it is not an equivalence relation. </p>

</div>
</div>
<a id="a7c63f087df9180e1901cc4105a3a0363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c63f087df9180e1901cc4105a3a0363">&#9670;&nbsp;</a></span>unique_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unique_copy </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied. </p>
<p>Elements are compared using operator==. The behavior is undefined if it is not an equivalence relation. </p>

</div>
</div>
<a id="a9b32d22be5cb9bbaaf24e21d8b700bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b32d22be5cb9bbaaf24e21d8b700bcb">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::upper_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is greater than <code>value</code>, or last if no such element is found. </p>
<p>The range <code>[first, last)</code> must be partitioned with respect to the expression <code>!(value &lt; element)</code> or <code>!comp(value, element)</code>, i.e., all elements for which the expression is true must precede all elements for which the expression is false. A fully-sorted range meets this criterion. </p>

</div>
</div>
<a id="a3448c90cac95ec2e155cf8ac02b6c592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3448c90cac95ec2e155cf8ac02b6c592">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::upper_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5a13233ebf471c62f35f40b21128884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a13233ebf471c62f35f40b21128884">&#9670;&nbsp;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1array.html">etl::array</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U...&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structetl_1_1array.html">array</a>&lt; T, 1+sizeof...(U)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="array_8cpp-example.html#a1">array.cpp</a>, and <a class="el" href="set_8cpp-example.html#a0">set.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad707bbff2e759a5d868a7bfb7d6bc4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad707bbff2e759a5d868a7bfb7d6bc4c5">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for array. Swaps the contents of lhs and rhs. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a8">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad78053f3dad1753bf6896680da407b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78053f3dad1753bf6896680da407b07">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="vector_8cpp-example.html#a1">vector.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a147d125b8b1ac3e64edd3a64e62f28f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147d125b8b1ac3e64edd3a64e62f28f0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaabb772977543ab7c5b19143ff371cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabb772977543ab7c5b19143ff371cff">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a6f6a8d3734cee3199f36a9c97e00e286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6a8d3734cee3199f36a9c97e00e286">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c1451f7dad0eb2205217d548a8f9583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1451f7dad0eb2205217d548a8f9583">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39feefa1e12cd8485e5ac5b1cf25ca5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39feefa1e12cd8485e5ac5b1cf25ca5a">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86b7094f524bee0b6d0e32e83e6d18e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b7094f524bee0b6d0e32e83e6d18e2">&#9670;&nbsp;</a></span>get() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Index, typename T , size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> -&gt; T&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the Ith element element from the array. I must be an integer value in range [0, N). This is enforced at compile time as opposed to at() or operator[]. </p>

</div>
</div>
<a id="a55a288e79c781974b0178e21cc9cc012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a288e79c781974b0178e21cc9cc012">&#9670;&nbsp;</a></span>get() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Index, typename T , size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> -&gt; T const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac584a8e745af05dc346a19d0395a878b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac584a8e745af05dc346a19d0395a878b">&#9670;&nbsp;</a></span>get() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Index, typename T , size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a631f38db521ab83ff5467fb29405d74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631f38db521ab83ff5467fb29405d74a">&#9670;&nbsp;</a></span>get() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Index, typename T , size_t Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> -&gt; T const&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac52800519f8ed99c7279ac0e850ab049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52800519f8ed99c7279ac0e850ab049">&#9670;&nbsp;</a></span>to_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_array </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>a</em>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1array.html">array</a>&lt;<a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">remove_cv_t</a>&lt;T&gt;, N&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a array from the one dimensional built-in array a. The elements of the array are copy-initialized from the corresponding element of a. Copying or moving multidimensional built-in array is not supported. </p>

</div>
</div>
<a id="aa365aab3fcf0745f5ea688b372f3aca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa365aab3fcf0745f5ea688b372f3aca7">&#9670;&nbsp;</a></span>to_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_array </td>
          <td>(</td>
          <td class="paramtype">T(&amp;&amp;)&#160;</td>
          <td class="paramname"><em>a</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a877cfa73ea6690339843c3f5b79ca3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877cfa73ea6690339843c3f5b79ca3a7">&#9670;&nbsp;</a></span>requires() <span class="overload">[1/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::detail::sufficiently_trivial T, etl::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> !&#160;</td>
          <td class="paramname"> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a321af167e669a0c72a867748fffff377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321af167e669a0c72a867748fffff377">&#9670;&nbsp;</a></span>uninitialized_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1uninitialized__array.html">etl::uninitialized_array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6c0bdae2655a0ed9121aeca58640e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c0bdae2655a0ed9121aeca58640e9a">&#9670;&nbsp;</a></span>data() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; T const* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a4">numeric.cpp</a>, and <a class="el" href="set_8cpp-example.html#a4">set.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0db1ad433c808f8aabe48a2061e633dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db1ad433c808f8aabe48a2061e633dc">&#9670;&nbsp;</a></span>size() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto etl::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a10">numeric.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2836fac65c2a00e47c70508d8d837b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2836fac65c2a00e47c70508d8d837b3e">&#9670;&nbsp;</a></span>requires() <span class="overload">[2/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype">detail::bit_castable_types&lt; To, From &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt; To
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a value of type To by reinterpreting the object representation of from. Every bit in the value representation of the returned To object is equal to the corresponding bit in the object representation of from. </p>
<p>The values of padding bits in the returned To object are unspecified. If there is no value of type To corresponding to the value representation produced, the behavior is undefined. If there are multiple such values, which value is produced is unspecified. This overload only participates in overload resolution if sizeof(To) == sizeof(From) and both To and From are TriviallyCopyable types.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/bit_cast">https://en.cppreference.com/w/cpp/numeric/bit_cast</a> </p>

</div>
</div>
<a id="aa397d9f8380425b5e72d55d7f7f16b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa397d9f8380425b5e72d55d7f7f16b10">&#9670;&nbsp;</a></span>bit_ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::bit_ceil </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the smallest integral power of two that is not smaller than x. If that value is not representable in UInt, the behavior is undefined. Call to this function is permitted in constant evaluation only if the undefined behavior does not occur. </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The smallest integral power of two that is not smaller than x. </dd></dl>

</div>
</div>
<a id="a344157c15560dd640719de8ecf9a311a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344157c15560dd640719de8ecf9a311a">&#9670;&nbsp;</a></span>bit_floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::bit_floor </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If x is not zero, calculates the largest integral power of two that is not greater than x. If x is zero, returns zero. </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>Zero if x is zero; otherwise, the largest integral power of two that is not greater than x. </dd></dl>

</div>
</div>
<a id="a7f9cca4b68917b48f46849a03007d9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9cca4b68917b48f46849a03007d9a9">&#9670;&nbsp;</a></span>bit_width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::bit_width </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If x is not zero, calculates the number of bits needed to store the value x, that is, 1+⌊log2(x)⌋. If x is zero, returns zero. </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type). </p>

</div>
</div>
<a id="ad4adeee8eaea36f5d0716abfe81148ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4adeee8eaea36f5d0716abfe81148ba">&#9670;&nbsp;</a></span>byteswap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::byteswap </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the bytes in the given integer value n. </p>
<p><a class="el" href="namespaceetl.html#ad4adeee8eaea36f5d0716abfe81148ba" title="Reverses the bytes in the given integer value n.">etl::byteswap</a> participates in overload resolution only if T satisfies integral, i.e., T is an integer type. The program is ill-formed if T has padding bits.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/byteswap">https://en.cppreference.com/w/cpp/numeric/byteswap</a> </p>

</div>
</div>
<a id="a4ce080db93d1da7b7ac5322f3edab4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce080db93d1da7b7ac5322f3edab4fa">&#9670;&nbsp;</a></span>countl_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::countl_one </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of consecutive 1 ("one") bits in the value of x, starting from the most significant bit ("left"). </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of consecutive 1 bits in the value of x, starting from the most significant bit. </dd></dl>

</div>
</div>
<a id="ac6df380fce74364ad8da2b39c516c24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6df380fce74364ad8da2b39c516c24e">&#9670;&nbsp;</a></span>countl_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::countl_zero </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of consecutive 0 bits in the value of x, starting from the most significant bit ("left"). </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of consecutive 0 bits in the value of x, starting from the most significant bit. </dd></dl>

</div>
</div>
<a id="a0e3fbba99f7fed7abe96381c03de2e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3fbba99f7fed7abe96381c03de2e54">&#9670;&nbsp;</a></span>countr_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::countr_one </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of consecutive 1 bits in the value of x, starting from the least significant bit ("right"). </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of consecutive 1 bits in the value of x, starting from the least significant bit. </dd></dl>

</div>
</div>
<a id="a9a5490ba02f948e6f27acbe515d47eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5490ba02f948e6f27acbe515d47eab">&#9670;&nbsp;</a></span>countr_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::countr_zero </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of consecutive 0 bits in the value of x, starting from the least significant bit ("right"). </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of consecutive 0 bits in the value of x, starting from the least significant bit. </dd></dl>

</div>
</div>
<a id="a0997ae09365ac687cb26999f55fbe724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0997ae09365ac687cb26999f55fbe724">&#9670;&nbsp;</a></span>flip_bit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::flip_bit </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4862a11212e1db1497182b3c5e7acab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4862a11212e1db1497182b3c5e7acab4">&#9670;&nbsp;</a></span>flip_bit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Bit, etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::flip_bit </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af064bf9681c55a5f04915eeceb13348a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af064bf9681c55a5f04915eeceb13348a">&#9670;&nbsp;</a></span>has_single_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::has_single_bit </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if x is an integral power of two. </p>
<p>This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>true if x is an integral power of two; otherwise false. </dd></dl>

</div>
</div>
<a id="a6ec2a511f8b5137e02416b9e4e8dc237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec2a511f8b5137e02416b9e4e8dc237">&#9670;&nbsp;</a></span>operator&amp;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3cb02b81d1ba34fc33b94555749fa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cb02b81d1ba34fc33b94555749fa92">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator| </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af622835231ee77bf2d29dd490bcbb2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af622835231ee77bf2d29dd490bcbb2bf">&#9670;&nbsp;</a></span>operator^() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator^ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92caafb1e73d48a1d1847f64093be44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92caafb1e73d48a1d1847f64093be44c">&#9670;&nbsp;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator~ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2e027dfa37f613a9d94fe1ee90e7517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e027dfa37f613a9d94fe1ee90e7517">&#9670;&nbsp;</a></span>operator|=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator|= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc72777ea30905ff52e4ce6d3448b3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc72777ea30905ff52e4ce6d3448b3e8">&#9670;&nbsp;</a></span>operator&amp;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79f94aefe628a0474274befd3437bf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f94aefe628a0474274befd3437bf64">&#9670;&nbsp;</a></span>operator^=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator^= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e754daac238cd635c52a571019370d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e754daac238cd635c52a571019370d9">&#9670;&nbsp;</a></span>popcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::popcount </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of 1 bits in the value of x. </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type). </p>

</div>
</div>
<a id="ace9159d861c5d8c5ed5708b8381fa19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9159d861c5d8c5ed5708b8381fa19a">&#9670;&nbsp;</a></span>reset_bit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::reset_bit </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecd9ef98d7cd14ca276c8df92dc00a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd9ef98d7cd14ca276c8df92dc00a64">&#9670;&nbsp;</a></span>reset_bit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Bit, etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::reset_bit </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bbf35871b94190f98acbfc57d75c63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbf35871b94190f98acbfc57d75c63c">&#9670;&nbsp;</a></span>rotl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rotl </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the result of bitwise left-rotating the value of x by s positions. This operation is also known as a left circular shift. </p>

</div>
</div>
<a id="a74ebdfe26048f199e0778622f63a6653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ebdfe26048f199e0778622f63a6653">&#9670;&nbsp;</a></span>rotr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rotr </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the result of bitwise right-rotating the value of x by s positions. This operation is also known as a right circular shift. </p>

</div>
</div>
<a id="af8da66a736f8e15a2cf4dd681f6ab863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8da66a736f8e15a2cf4dd681f6ab863">&#9670;&nbsp;</a></span>set_bit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::set_bit </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84a5560970454768aa47bb8d4c5722ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a5560970454768aa47bb8d4c5722ee">&#9670;&nbsp;</a></span>set_bit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Bit, etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::set_bit </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6446130881cadc4edfba7f0ec4b01d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6446130881cadc4edfba7f0ec4b01d5f">&#9670;&nbsp;</a></span>test_bit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::test_bit </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d062f57d0edbd6d850d13e600e385ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d062f57d0edbd6d850d13e600e385ee">&#9670;&nbsp;</a></span>test_bit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Bit, etl::standard_unsigned_integer UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::test_bit </td>
          <td>(</td>
          <td class="paramtype">UInt&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6eaaf991a15c82d1ea08c9932f513126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eaaf991a15c82d1ea08c9932f513126">&#9670;&nbsp;</a></span>operator&amp;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;N&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary AND between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="ad704bd3a387f58880d2d97024dea9e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad704bd3a387f58880d2d97024dea9e71">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;N&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary OR between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="a7238e53a5804e54ed1c1fbeb962f74b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7238e53a5804e54ed1c1fbeb962f74b1">&#9670;&nbsp;</a></span>operator^() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;N&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary XOR between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="ad57d9658b5bfda3c9dc53d1a0bd95ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57d9658b5bfda3c9dc53d1a0bd95ca7">&#9670;&nbsp;</a></span>default_assert_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::default_assert_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1assert__msg.html">assert_msg</a> const &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default assert handler. This will be called, if an assertion is triggered at runtime. </p>

</div>
</div>
<a id="a0ebfa4dc6da592b5c2d73f10ba7490dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebfa4dc6da592b5c2d73f10ba7490dc">&#9670;&nbsp;</a></span>isalnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isalnum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is an alphanumeric character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is an alphanumeric character, 0 otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isalnum">https://en.cppreference.com/w/cpp/string/byte/isalnum</a> </p>

</div>
</div>
<a id="a89ad095d93b811823b48e7b0486be7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ad095d93b811823b48e7b0486be7de">&#9670;&nbsp;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isalpha </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is an alphabetic character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is an alphabetic character, 0 otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isalpha">https://en.cppreference.com/w/cpp/string/byte/isalpha</a> </p>

</div>
</div>
<a id="acca9707732972162ec02317639d2154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca9707732972162ec02317639d2154b">&#9670;&nbsp;</a></span>isblank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isblank </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (0x20) and horizontal tab (0x09) are classified as blank characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a blank character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isblank">https://en.cppreference.com/w/cpp/string/byte/isblank</a> </p>

</div>
</div>
<a id="a037d91a684e54521c31eefa609c57f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037d91a684e54521c31eefa609c57f0f">&#9670;&nbsp;</a></span>iscntrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iscntrl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a control character as classified by the currently installed C locale. In the default, "C" locale, the control characters are the characters with the codes 0x00-0x1F and 0x7F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a control character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/iscntrl">https://en.cppreference.com/w/cpp/string/byte/iscntrl</a> </p>

</div>
</div>
<a id="a743aaa8e35549baecb60a7a37fbccb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743aaa8e35549baecb60a7a37fbccb7a">&#9670;&nbsp;</a></span>isdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isdigit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is one of the 10 decimal digits: 0123456789. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a numeric character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isdigit">https://en.cppreference.com/w/cpp/string/byte/isdigit</a> </p>

</div>
</div>
<a id="a3fcb7b22dcd166bd67a94b6b7f7da42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcb7b22dcd166bd67a94b6b7f7da42e">&#9670;&nbsp;</a></span>isgraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isgraph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is graphic (has a graphical representation) as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a punctuation character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isgraph">https://en.cppreference.com/w/cpp/string/byte/isgraph</a> </p>

</div>
</div>
<a id="a334ab4709b4cf8c1f5053016825c3bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334ab4709b4cf8c1f5053016825c3bd7">&#9670;&nbsp;</a></span>islower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::islower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is classified as a lowercase character according to the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a lowercase letter, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/islower">https://en.cppreference.com/w/cpp/string/byte/islower</a> </p>

</div>
</div>
<a id="a8da49fe7c1e61918bbf7dd210e655d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da49fe7c1e61918bbf7dd210e655d8c">&#9670;&nbsp;</a></span>isprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isprint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if ch is a printable character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a punctuation character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isprint">https://en.cppreference.com/w/cpp/string/byte/isprint</a> </p>

</div>
</div>
<a id="a531a127903fbd0d7545d9a69bf13bb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531a127903fbd0d7545d9a69bf13bb3c">&#9670;&nbsp;</a></span>ispunct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ispunct </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a punctuation character as classified by the current C locale. </p>
<p>The default C locale classifies the characters !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~ as punctuation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a punctuation character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/ispunct">https://en.cppreference.com/w/cpp/string/byte/ispunct</a> </p>

</div>
</div>
<a id="a3c87145259e2ce0061ac810fee723978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c87145259e2ce0061ac810fee723978">&#9670;&nbsp;</a></span>isspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isspace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is whitespace character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a whitespace character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isspace">https://en.cppreference.com/w/cpp/string/byte/isspace</a> </p>

</div>
</div>
<a id="a2b1e3ecf65c20a6bd5f0b06139694269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1e3ecf65c20a6bd5f0b06139694269">&#9670;&nbsp;</a></span>isupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isupper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is classified as a uppercase character according to the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a uppercase letter, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isupper">https://en.cppreference.com/w/cpp/string/byte/isupper</a> </p>

</div>
</div>
<a id="a77b0bd8474428652100d3db55092e788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b0bd8474428652100d3db55092e788">&#9670;&nbsp;</a></span>isxdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isxdigit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a hexadecimal numeric character (0123456789abcdefABCDEF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a hexadecimal numeric character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isxdigit">https://en.cppreference.com/w/cpp/string/byte/isxdigit</a> </p>

</div>
</div>
<a id="a25b969e80e81b5a412d56884fc5bfcf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b969e80e81b5a412d56884fc5bfcf2">&#9670;&nbsp;</a></span>tolower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tolower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given character to lowercase according to the character conversion rules defined by the default C locale. </p>
<p>In the default "C" locale, the following uppercase letters <b>ABCDEFGHIJKLMNOPQRSTUVWXYZ</b> are replaced with respective lowercase letters <b>abcdefghijklmnopqrstuvwxyz</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lowercase version of ch or unmodified ch if no lowercase version is listed in the current C locale.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/tolower">https://en.cppreference.com/w/cpp/string/byte/tolower</a> </p>

</div>
</div>
<a id="a2b46f5faca236c0de0b9f378c22498c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b46f5faca236c0de0b9f378c22498c1">&#9670;&nbsp;</a></span>toupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::toupper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given character to uppercase according to the character conversion rules defined by the default C locale. </p>
<p>In the default "C" locale, the following lowercase letters <b>abcdefghijklmnopqrstuvwxyz</b> are replaced with respective uppercase letters <b>ABCDEFGHIJKLMNOPQRSTUVWXYZ</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted character or ch if no uppercase version is defined by the current C locale.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/toupper">https://en.cppreference.com/w/cpp/string/byte/toupper</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="string_8cpp-example.html#a3">string.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1c1ffcebf3ee4f04cf5987def83d0070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1ffcebf3ee4f04cf5987def83d0070">&#9670;&nbsp;</a></span>isfinite() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isfinite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a587d2d42acd3ff40d56a98cdb84e1f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587d2d42acd3ff40d56a98cdb84e1f57">&#9670;&nbsp;</a></span>isinf() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8311e8c453fbb5b2e5eea1ed6aead74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8311e8c453fbb5b2e5eea1ed6aead74">&#9670;&nbsp;</a></span>isnan() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8840adb5e14e1239b4830cdd7e17f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8840adb5e14e1239b4830cdd7e17f29">&#9670;&nbsp;</a></span>isnormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isnormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92f672431014d52f52f9ce327fd19b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f672431014d52f52f9ce327fd19b81">&#9670;&nbsp;</a></span>signbit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::signbit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3af75f924fd190d7f6d474cb87ef402f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af75f924fd190d7f6d474cb87ef402f">&#9670;&nbsp;</a></span>requires() <span class="overload">[3/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceetl.html#aa602e717add57122f28f5186a8399a87">same_as</a>&lt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>, bool &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyzes the character sequence [first,last) for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value. </p>

</div>
</div>
<a id="a452f2e21f389de11e116d5ebf191b039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452f2e21f389de11e116d5ebf191b039">&#9670;&nbsp;</a></span>requires() <span class="overload">[4/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceetl.html#aa602e717add57122f28f5186a8399a87">same_as</a>&lt; T, bool &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. </p>
<p>Integer formatters: value is converted to a string of digits in the given base (with no redundant leading zeroes). Digits in the range 10..35 (inclusive) are represented as lowercase characters a..z. If value is less than zero, the representation starts with a minus sign. The library provides overloads for all signed and unsigned integer types and for the type char as the type of the parameter value. </p>

</div>
</div>
<a id="ad9ace77006d897bb11f9e75fc01c6d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ace77006d897bb11f9e75fc01c6d54">&#9670;&nbsp;</a></span>acos() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>. </p>

</div>
</div>
<a id="ad6d6dec7881376a3795507e224cfc794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d6dec7881376a3795507e224cfc794">&#9670;&nbsp;</a></span>acosf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acosf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>. </p>

</div>
</div>
<a id="a4747095fd6649df58b77e797a7b6a4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4747095fd6649df58b77e797a7b6a4ae">&#9670;&nbsp;</a></span>acos() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>. </p>

</div>
</div>
<a id="aab37e22cd4d9b76197860d41f6d61722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab37e22cd4d9b76197860d41f6d61722">&#9670;&nbsp;</a></span>acos() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acos </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>. </p>

</div>
</div>
<a id="a1f170557969dafd889c9c4af8c86e6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f170557969dafd889c9c4af8c86e6f7">&#9670;&nbsp;</a></span>acosl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acosl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>. </p>

</div>
</div>
<a id="a5ca6badc84ba20bc9540c1aecd9ed972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca6badc84ba20bc9540c1aecd9ed972">&#9670;&nbsp;</a></span>acos() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acos </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acos">https://en.cppreference.com/w/cpp/numeric/math/acos</a>. </p>

</div>
</div>
<a id="a90cae0f69c6df3ad62b9d18a2edfe8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cae0f69c6df3ad62b9d18a2edfe8bd">&#9670;&nbsp;</a></span>acosh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acosh </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>. </p>

</div>
</div>
<a id="aadf8da6a971811befc7625a7c6a9c0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf8da6a971811befc7625a7c6a9c0bf">&#9670;&nbsp;</a></span>acoshf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acoshf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>. </p>

</div>
</div>
<a id="a3f78ba5c1b76fcd56f3de95d66338445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f78ba5c1b76fcd56f3de95d66338445">&#9670;&nbsp;</a></span>acosh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acosh </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>. </p>

</div>
</div>
<a id="a24d388cd651b91d71eeac81bec72bcf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d388cd651b91d71eeac81bec72bcf1">&#9670;&nbsp;</a></span>acosh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acosh </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>. </p>

</div>
</div>
<a id="a8cd4f8c867eb336638c2e85925a11ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd4f8c867eb336638c2e85925a11ceb">&#9670;&nbsp;</a></span>acoshl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acoshl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>. </p>

</div>
</div>
<a id="aa208046cad1bdd0cefca2833574c9dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa208046cad1bdd0cefca2833574c9dfa">&#9670;&nbsp;</a></span>acosh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::acosh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/acosh">https://en.cppreference.com/w/cpp/numeric/math/acosh</a>. </p>

</div>
</div>
<a id="aa3fb71bd1279ffa3c0ac934adeec55b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fb71bd1279ffa3c0ac934adeec55b1">&#9670;&nbsp;</a></span>asin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>. </p>

</div>
</div>
<a id="a33eb37ff3fb73d04a8d0b6f1a8edf312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33eb37ff3fb73d04a8d0b6f1a8edf312">&#9670;&nbsp;</a></span>asinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asinf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>. </p>

</div>
</div>
<a id="afd5d32ddd2f8d6786e0f347bbfa9f453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5d32ddd2f8d6786e0f347bbfa9f453">&#9670;&nbsp;</a></span>asin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>. </p>

</div>
</div>
<a id="a74316d1000b469ad778ba8be2a7a837d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74316d1000b469ad778ba8be2a7a837d">&#9670;&nbsp;</a></span>asin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asin </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>. </p>

</div>
</div>
<a id="a938272f1d29c45dfeab834395bca9635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938272f1d29c45dfeab834395bca9635">&#9670;&nbsp;</a></span>asinl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asinl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>. </p>

</div>
</div>
<a id="a621a072ae9ca2d5a6e7156b82595c520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621a072ae9ca2d5a6e7156b82595c520">&#9670;&nbsp;</a></span>asin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asin </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asin">https://en.cppreference.com/w/cpp/numeric/math/asin</a>. </p>

</div>
</div>
<a id="aea8f020e1fb089580ce1ce2e92007d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8f020e1fb089580ce1ce2e92007d03">&#9670;&nbsp;</a></span>asinh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asinh </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>. </p>

</div>
</div>
<a id="ac985377c2d80c7a118366794fd0e660a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac985377c2d80c7a118366794fd0e660a">&#9670;&nbsp;</a></span>asinhf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asinhf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>. </p>

</div>
</div>
<a id="a922efdb95c11f4715bcbde248c8079d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922efdb95c11f4715bcbde248c8079d8">&#9670;&nbsp;</a></span>asinh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asinh </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>. </p>

</div>
</div>
<a id="ad13ae7860d3df16f57de06f8f8eac566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13ae7860d3df16f57de06f8f8eac566">&#9670;&nbsp;</a></span>asinh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asinh </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>. </p>

</div>
</div>
<a id="a3742eb491fd2e6a7f8173cb7bbfd01be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3742eb491fd2e6a7f8173cb7bbfd01be">&#9670;&nbsp;</a></span>asinhl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asinhl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>. </p>

</div>
</div>
<a id="a979329f95265c316f75cda198a8c6219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979329f95265c316f75cda198a8c6219">&#9670;&nbsp;</a></span>asinh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::asinh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/asinh">https://en.cppreference.com/w/cpp/numeric/math/asinh</a>. </p>

</div>
</div>
<a id="a65f8ad4a2909bbebbccfd140525f7c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f8ad4a2909bbebbccfd140525f7c8f">&#9670;&nbsp;</a></span>atan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atan </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>. </p>

</div>
</div>
<a id="a953ddfaa8dc761bf2a3cae7cf03ec743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953ddfaa8dc761bf2a3cae7cf03ec743">&#9670;&nbsp;</a></span>atanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atanf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>. </p>

</div>
</div>
<a id="a11dbb4af5e9f689d738347804fd05f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dbb4af5e9f689d738347804fd05f90">&#9670;&nbsp;</a></span>atan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>. </p>

</div>
</div>
<a id="a2b8a8b9108f9ce5f69505e9152a659d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8a8b9108f9ce5f69505e9152a659d7">&#9670;&nbsp;</a></span>atan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atan </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>. </p>

</div>
</div>
<a id="ab422245244dbf22608b198e007417b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab422245244dbf22608b198e007417b9d">&#9670;&nbsp;</a></span>atanl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atanl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>. </p>

</div>
</div>
<a id="ab76f32464a65bbf8c839d67f702b2c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76f32464a65bbf8c839d67f702b2c81">&#9670;&nbsp;</a></span>atan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the principal value of the arc tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atan">https://en.cppreference.com/w/cpp/numeric/math/atan</a>. </p>

</div>
</div>
<a id="a3d2b99c8ac12b4ede3490b55bc38ace7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2b99c8ac12b4ede3490b55bc38ace7">&#9670;&nbsp;</a></span>atan2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atan2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/atan2">https://en.cppreference.com/w/cpp/numeric/math/atan2</a> </p>

</div>
</div>
<a id="a8b28d5ed840d65898bb4bc7663cc6813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b28d5ed840d65898bb4bc7663cc6813">&#9670;&nbsp;</a></span>atan2f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atan2f </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/atan2">https://en.cppreference.com/w/cpp/numeric/math/atan2</a> </p>

</div>
</div>
<a id="a5900f3d1e6a74988a7f45cd04a3627ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5900f3d1e6a74988a7f45cd04a3627ae">&#9670;&nbsp;</a></span>atan2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atan2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/atan2">https://en.cppreference.com/w/cpp/numeric/math/atan2</a> </p>

</div>
</div>
<a id="a2c6967d95f89156650197ea75f1f3ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6967d95f89156650197ea75f1f3ba7">&#9670;&nbsp;</a></span>atan2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atan2 </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/atan2">https://en.cppreference.com/w/cpp/numeric/math/atan2</a> </p>

</div>
</div>
<a id="a037863b294d960041c163520b22381e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037863b294d960041c163520b22381e1">&#9670;&nbsp;</a></span>atan2l()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atan2l </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/atan2">https://en.cppreference.com/w/cpp/numeric/math/atan2</a> </p>

</div>
</div>
<a id="a12216cfa04c0976057427be27c64c696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12216cfa04c0976057427be27c64c696">&#9670;&nbsp;</a></span>atanh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atanh </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>. </p>

</div>
</div>
<a id="a8783263cfdd3d32199d0cc1257e0c04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8783263cfdd3d32199d0cc1257e0c04c">&#9670;&nbsp;</a></span>atanhf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atanhf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>. </p>

</div>
</div>
<a id="aabb11729ba246f5a4098bc553a292295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb11729ba246f5a4098bc553a292295">&#9670;&nbsp;</a></span>atanh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atanh </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>. </p>

</div>
</div>
<a id="a6def40d7b11e3e930b6bc1927d8aff69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6def40d7b11e3e930b6bc1927d8aff69">&#9670;&nbsp;</a></span>atanh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atanh </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>. </p>

</div>
</div>
<a id="a6e6c389cab358ec81ddee4010aa8f450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6c389cab358ec81ddee4010aa8f450">&#9670;&nbsp;</a></span>atanhl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atanhl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>. </p>

</div>
</div>
<a id="a0dbab5667618a4498791559fed34db3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbab5667618a4498791559fed34db3b">&#9670;&nbsp;</a></span>atanh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atanh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/atanh">https://en.cppreference.com/w/cpp/numeric/math/atanh</a>. </p>

</div>
</div>
<a id="aefd33d209fa34a26154dec7971f43ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd33d209fa34a26154dec7971f43ce9">&#9670;&nbsp;</a></span>beta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::beta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the beta function of x and y. <a href="https://en.cppreference.com/w/cpp/numeric/special_functions/beta">https://en.cppreference.com/w/cpp/numeric/special_functions/beta</a>. </p>

</div>
</div>
<a id="a5bb892bd770281574939e288765165ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb892bd770281574939e288765165ea">&#9670;&nbsp;</a></span>betaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::betaf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the beta function of x and y. <a href="https://en.cppreference.com/w/cpp/numeric/special_functions/beta">https://en.cppreference.com/w/cpp/numeric/special_functions/beta</a>. </p>

</div>
</div>
<a id="a1572e65836d75f30b200de7dd2cdc272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1572e65836d75f30b200de7dd2cdc272">&#9670;&nbsp;</a></span>betal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::betal </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the beta function of x and y. <a href="https://en.cppreference.com/w/cpp/numeric/special_functions/beta">https://en.cppreference.com/w/cpp/numeric/special_functions/beta</a>. </p>

</div>
</div>
<a id="a8714f7ac18944189736a0c986f88b950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8714f7ac18944189736a0c986f88b950">&#9670;&nbsp;</a></span>ceil() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ceil </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>. </p>

</div>
</div>
<a id="ae7c45cc3c430eb3f9bfbbf4c573faefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c45cc3c430eb3f9bfbbf4c573faefe">&#9670;&nbsp;</a></span>ceilf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ceilf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>. </p>

</div>
</div>
<a id="a199b60a1d291d73e6a88cb7688fcc6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199b60a1d291d73e6a88cb7688fcc6b7">&#9670;&nbsp;</a></span>ceil() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ceil </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>. </p>

</div>
</div>
<a id="aacd0ff04f746f500187517b5b60f48a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd0ff04f746f500187517b5b60f48a7">&#9670;&nbsp;</a></span>ceil() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ceil </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>. </p>

</div>
</div>
<a id="afee2633ec94191433e72d07c9d85cee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee2633ec94191433e72d07c9d85cee3">&#9670;&nbsp;</a></span>ceill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ceill </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>. </p>

</div>
</div>
<a id="a263d08d9bc4ecbeaaed9467440a5fd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263d08d9bc4ecbeaaed9467440a5fd6b">&#9670;&nbsp;</a></span>ceil() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ceil </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the smallest integer value not less than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">https://en.cppreference.com/w/cpp/numeric/math/ceil</a>. </p>

</div>
</div>
<a id="a17223939b148fdd815e90f732a5d2ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17223939b148fdd815e90f732a5d2ed8">&#9670;&nbsp;</a></span>copysign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copysign </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sgn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a floating point value with the magnitude of mag and the sign of sgn. </p>
<p><a class="el" href="namespaceetl.html#a17223939b148fdd815e90f732a5d2ed8" title="Composes a floating point value with the magnitude of mag and the sign of sgn.">etl::copysign</a> is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, signbit may also be used)</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/copysign">https://en.cppreference.com/w/cpp/numeric/math/copysign</a></p>
<dl class="section return"><dt>Returns</dt><dd>If no errors occur, the floating point value with the magnitude of mag and the sign of sgn is returned. If mag is NaN, then NaN with the sign of sgn is returned. If sgn is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations. </dd></dl>

</div>
</div>
<a id="a74a3b66b7eaf7fba405c4fabd12b9032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a3b66b7eaf7fba405c4fabd12b9032">&#9670;&nbsp;</a></span>copysignf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copysignf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sgn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a floating point value with the magnitude of mag and the sign of sgn. </p>
<p><a class="el" href="namespaceetl.html#a17223939b148fdd815e90f732a5d2ed8" title="Composes a floating point value with the magnitude of mag and the sign of sgn.">etl::copysign</a> is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, signbit may also be used)</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/copysign">https://en.cppreference.com/w/cpp/numeric/math/copysign</a></p>
<dl class="section return"><dt>Returns</dt><dd>If no errors occur, the floating point value with the magnitude of mag and the sign of sgn is returned. If mag is NaN, then NaN with the sign of sgn is returned. If sgn is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations. </dd></dl>

</div>
</div>
<a id="a4c9633a12193b92425f88a20c5f991da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9633a12193b92425f88a20c5f991da">&#9670;&nbsp;</a></span>copysign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copysign </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sgn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a floating point value with the magnitude of mag and the sign of sgn. </p>
<p><a class="el" href="namespaceetl.html#a17223939b148fdd815e90f732a5d2ed8" title="Composes a floating point value with the magnitude of mag and the sign of sgn.">etl::copysign</a> is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, signbit may also be used)</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/copysign">https://en.cppreference.com/w/cpp/numeric/math/copysign</a></p>
<dl class="section return"><dt>Returns</dt><dd>If no errors occur, the floating point value with the magnitude of mag and the sign of sgn is returned. If mag is NaN, then NaN with the sign of sgn is returned. If sgn is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations. </dd></dl>

</div>
</div>
<a id="a12f0ba6ef64b11393c3807cdc25ecc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f0ba6ef64b11393c3807cdc25ecc2b">&#9670;&nbsp;</a></span>copysign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copysign </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>mag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>sgn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a floating point value with the magnitude of mag and the sign of sgn. </p>
<p><a class="el" href="namespaceetl.html#a17223939b148fdd815e90f732a5d2ed8" title="Composes a floating point value with the magnitude of mag and the sign of sgn.">etl::copysign</a> is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, signbit may also be used)</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/copysign">https://en.cppreference.com/w/cpp/numeric/math/copysign</a></p>
<dl class="section return"><dt>Returns</dt><dd>If no errors occur, the floating point value with the magnitude of mag and the sign of sgn is returned. If mag is NaN, then NaN with the sign of sgn is returned. If sgn is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations. </dd></dl>

</div>
</div>
<a id="a61b8f4abe1c15892a342be040ed0e231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b8f4abe1c15892a342be040ed0e231">&#9670;&nbsp;</a></span>copysignl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copysignl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>mag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>sgn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes a floating point value with the magnitude of mag and the sign of sgn. </p>
<p><a class="el" href="namespaceetl.html#a17223939b148fdd815e90f732a5d2ed8" title="Composes a floating point value with the magnitude of mag and the sign of sgn.">etl::copysign</a> is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, signbit may also be used)</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/copysign">https://en.cppreference.com/w/cpp/numeric/math/copysign</a></p>
<dl class="section return"><dt>Returns</dt><dd>If no errors occur, the floating point value with the magnitude of mag and the sign of sgn is returned. If mag is NaN, then NaN with the sign of sgn is returned. If sgn is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations. </dd></dl>

</div>
</div>
<a id="a4906f1caf2586cc2563fc0faf2f7ea30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4906f1caf2586cc2563fc0faf2f7ea30">&#9670;&nbsp;</a></span>cos() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>. </p>

</div>
</div>
<a id="a73d17a837d13ea55344804cb5c64322c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d17a837d13ea55344804cb5c64322c">&#9670;&nbsp;</a></span>cosf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cosf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>. </p>

</div>
</div>
<a id="aab6c7ef0dbdd2323343636f79a74f8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6c7ef0dbdd2323343636f79a74f8af">&#9670;&nbsp;</a></span>cos() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>. </p>

</div>
</div>
<a id="a07734dc481f156ef3959fb891782b58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07734dc481f156ef3959fb891782b58f">&#9670;&nbsp;</a></span>cos() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cos </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>. </p>

</div>
</div>
<a id="aed9df8dfe51ba4bb2b189f503a7cdd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9df8dfe51ba4bb2b189f503a7cdd75">&#9670;&nbsp;</a></span>cosl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cosl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>. </p>

</div>
</div>
<a id="af4e34ec5e84f9fb625cf7ee93df783c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e34ec5e84f9fb625cf7ee93df783c4">&#9670;&nbsp;</a></span>cos() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cos </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/cos">https://en.cppreference.com/w/cpp/numeric/math/cos</a>. </p>

</div>
</div>
<a id="ab03b4314a7a0c72385ecb062322e815a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03b4314a7a0c72385ecb062322e815a">&#9670;&nbsp;</a></span>cosh() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cosh </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>. </p>

</div>
</div>
<a id="a4c2950fdc398f70b0545b2721f57deff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2950fdc398f70b0545b2721f57deff">&#9670;&nbsp;</a></span>coshf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::coshf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>. </p>

</div>
</div>
<a id="a85c430223db452246c909a258dac5d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c430223db452246c909a258dac5d01">&#9670;&nbsp;</a></span>cosh() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cosh </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>. </p>

</div>
</div>
<a id="aa686c109054fee0ccbe9233313fe5811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa686c109054fee0ccbe9233313fe5811">&#9670;&nbsp;</a></span>cosh() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cosh </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>. </p>

</div>
</div>
<a id="a32ea3e46f7aa043f3a6229e91281655d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ea3e46f7aa043f3a6229e91281655d">&#9670;&nbsp;</a></span>coshl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::coshl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>. </p>

</div>
</div>
<a id="a0497aee842a4aa4f6a0d3c07af34bf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0497aee842a4aa4f6a0d3c07af34bf27">&#9670;&nbsp;</a></span>cosh() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cosh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a>. </p>

</div>
</div>
<a id="a67a87be7c2a7789cc2af84f5620b6ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a87be7c2a7789cc2af84f5620b6ba0">&#9670;&nbsp;</a></span>erf() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::erf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>. </p>

</div>
</div>
<a id="ad16b4888b71e83519b5ef69e90ea6956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16b4888b71e83519b5ef69e90ea6956">&#9670;&nbsp;</a></span>erff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::erff </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>. </p>

</div>
</div>
<a id="acf55df46265ad2dda32d84405c47185d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf55df46265ad2dda32d84405c47185d">&#9670;&nbsp;</a></span>erf() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::erf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>. </p>

</div>
</div>
<a id="a27ece4e3c2d0449f2cf42ca64c72eae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ece4e3c2d0449f2cf42ca64c72eae5">&#9670;&nbsp;</a></span>erf() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::erf </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>. </p>

</div>
</div>
<a id="a843da4273caef9b48e4cdfc9b7c2c369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843da4273caef9b48e4cdfc9b7c2c369">&#9670;&nbsp;</a></span>erfl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::erfl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>. </p>

</div>
</div>
<a id="ac4f46c302ddbc1a6e7a6fea6cfdc3ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f46c302ddbc1a6e7a6fea6cfdc3ae2">&#9670;&nbsp;</a></span>erf() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::erf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a>. </p>

</div>
</div>
<a id="a9acc3b86f099266b7744b6cb388ed894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acc3b86f099266b7744b6cb388ed894">&#9670;&nbsp;</a></span>exp() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::exp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>. </p>

</div>
</div>
<a id="a3bb2a8337db1101a51fa8bf0c9c93aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb2a8337db1101a51fa8bf0c9c93aff">&#9670;&nbsp;</a></span>expf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::expf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>. </p>

</div>
</div>
<a id="a5c94fca30d8f6813d56cd0db16e1f2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c94fca30d8f6813d56cd0db16e1f2af">&#9670;&nbsp;</a></span>exp() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::exp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>. </p>

</div>
</div>
<a id="a92f7208d978374f6fdc4b3caa77a5942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f7208d978374f6fdc4b3caa77a5942">&#9670;&nbsp;</a></span>exp() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::exp </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>. </p>

</div>
</div>
<a id="ad23063bd3e5e1848b1cd8f0adee2bdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23063bd3e5e1848b1cd8f0adee2bdd0">&#9670;&nbsp;</a></span>expl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::expl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>. </p>

</div>
</div>
<a id="a8a06161d90cdf8b9af35ddf334a8db2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a06161d90cdf8b9af35ddf334a8db2d">&#9670;&nbsp;</a></span>exp() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::exp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v <a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a>. </p>

</div>
</div>
<a id="af0241333848ee2ec2b8a53dc9ba0e19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0241333848ee2ec2b8a53dc9ba0e19e">&#9670;&nbsp;</a></span>fdim() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fdim </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if x≤y), returns +0. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fdim">https://en.cppreference.com/w/cpp/numeric/math/fdim</a> </p>

</div>
</div>
<a id="ad8e19893929bbc794be4206bec3f1ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e19893929bbc794be4206bec3f1ffa">&#9670;&nbsp;</a></span>fdimf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fdimf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if x≤y), returns +0. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fdim">https://en.cppreference.com/w/cpp/numeric/math/fdim</a> </p>

</div>
</div>
<a id="a7954b159301cbd51a00f4159449458af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7954b159301cbd51a00f4159449458af">&#9670;&nbsp;</a></span>fdim() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fdim </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if x≤y), returns +0. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fdim">https://en.cppreference.com/w/cpp/numeric/math/fdim</a> </p>

</div>
</div>
<a id="a96b3f1bd599452cab3d60f96db64c0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b3f1bd599452cab3d60f96db64c0f7">&#9670;&nbsp;</a></span>fdim() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fdim </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if x≤y), returns +0. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fdim">https://en.cppreference.com/w/cpp/numeric/math/fdim</a> </p>

</div>
</div>
<a id="a9f7dc714d464e428c74c9f4082a93ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7dc714d464e428c74c9f4082a93ea2">&#9670;&nbsp;</a></span>fdiml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fdiml </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if x≤y), returns +0. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fdim">https://en.cppreference.com/w/cpp/numeric/math/fdim</a> </p>

</div>
</div>
<a id="a177bda599c52cf225f0288ec9043b8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177bda599c52cf225f0288ec9043b8bb">&#9670;&nbsp;</a></span>floor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::floor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>. </p>

</div>
</div>
<a id="ac9e3263a0f395c13cab460b75b0f55ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e3263a0f395c13cab460b75b0f55ef">&#9670;&nbsp;</a></span>floorf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::floorf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>. </p>

</div>
</div>
<a id="a6604cf790ab829d40c3b4daa730c7c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6604cf790ab829d40c3b4daa730c7c08">&#9670;&nbsp;</a></span>floor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::floor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>. </p>

</div>
</div>
<a id="a5790bd430f29dc6eeced561fa3a5c054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5790bd430f29dc6eeced561fa3a5c054">&#9670;&nbsp;</a></span>floor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::floor </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>. </p>

</div>
</div>
<a id="ab2443c1dedde3d2c7efcbffd1c5fa693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2443c1dedde3d2c7efcbffd1c5fa693">&#9670;&nbsp;</a></span>floorl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::floorl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>. </p>

</div>
</div>
<a id="af61d4eb26e65da7afe6e0c669e78967b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61d4eb26e65da7afe6e0c669e78967b">&#9670;&nbsp;</a></span>floor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::floor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a>. </p>

</div>
</div>
<a id="a69e7db11940223760db9220304003446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e7db11940223760db9220304003446">&#9670;&nbsp;</a></span>fma() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fma </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma">https://en.cppreference.com/w/cpp/numeric/math/fma</a> </p>

</div>
</div>
<a id="a1060e4829c9f215f998aa669f07907fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1060e4829c9f215f998aa669f07907fe">&#9670;&nbsp;</a></span>fmaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmaf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma">https://en.cppreference.com/w/cpp/numeric/math/fma</a> </p>

</div>
</div>
<a id="afaa52aafdd0d75fd5757bc6048241627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa52aafdd0d75fd5757bc6048241627">&#9670;&nbsp;</a></span>fma() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma">https://en.cppreference.com/w/cpp/numeric/math/fma</a> </p>

</div>
</div>
<a id="a12b982d85defc10bdabb054f0f6da09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b982d85defc10bdabb054f0f6da09a">&#9670;&nbsp;</a></span>fma() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fma </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma">https://en.cppreference.com/w/cpp/numeric/math/fma</a> </p>

</div>
</div>
<a id="a4eeb30986666cfb17836f4a95c1ae432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eeb30986666cfb17836f4a95c1ae432">&#9670;&nbsp;</a></span>fmal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmal </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma">https://en.cppreference.com/w/cpp/numeric/math/fma</a> </p>

</div>
</div>
<a id="a4cbefc5ea76f13ee1827d6ece5530ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbefc5ea76f13ee1827d6ece5530ddf">&#9670;&nbsp;</a></span>fmax() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmax </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmax">https://en.cppreference.com/w/cpp/numeric/math/fmax</a> </p>

</div>
</div>
<a id="a20521caa4fff8d2a62c7d10d77041c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20521caa4fff8d2a62c7d10d77041c20">&#9670;&nbsp;</a></span>fmaxf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmaxf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmax">https://en.cppreference.com/w/cpp/numeric/math/fmax</a> </p>

</div>
</div>
<a id="a02198785b5008814ed4bc399d219bd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02198785b5008814ed4bc399d219bd05">&#9670;&nbsp;</a></span>fmax() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmax </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmax">https://en.cppreference.com/w/cpp/numeric/math/fmax</a> </p>

</div>
</div>
<a id="a2ccdc206cb2bbd9ede91a7368c9e5e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccdc206cb2bbd9ede91a7368c9e5e28">&#9670;&nbsp;</a></span>fmax() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmax </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmax">https://en.cppreference.com/w/cpp/numeric/math/fmax</a> </p>

</div>
</div>
<a id="a81aa1fe211f2730e008f27a200e45394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81aa1fe211f2730e008f27a200e45394">&#9670;&nbsp;</a></span>fmaxl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmaxl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmax">https://en.cppreference.com/w/cpp/numeric/math/fmax</a> </p>

</div>
</div>
<a id="a7b6dcbdef161930c194abe91e999fa5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6dcbdef161930c194abe91e999fa5a">&#9670;&nbsp;</a></span>fmin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmin">https://en.cppreference.com/w/cpp/numeric/math/fmin</a> </p>

</div>
</div>
<a id="a97261b40d0dadb99feb19718529cb0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97261b40d0dadb99feb19718529cb0a4">&#9670;&nbsp;</a></span>fminf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fminf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmin">https://en.cppreference.com/w/cpp/numeric/math/fmin</a> </p>

</div>
</div>
<a id="ab3f5a59fa8f7da66f4b0e8fe9c75eaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f5a59fa8f7da66f4b0e8fe9c75eaa8">&#9670;&nbsp;</a></span>fmin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmin">https://en.cppreference.com/w/cpp/numeric/math/fmin</a> </p>

</div>
</div>
<a id="a3b7993c9e609fbaadfb6d3c8e2601edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7993c9e609fbaadfb6d3c8e2601edc">&#9670;&nbsp;</a></span>fmin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmin </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmin">https://en.cppreference.com/w/cpp/numeric/math/fmin</a> </p>

</div>
</div>
<a id="af48da4e487f08e68385af8cd0fd1d5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48da4e487f08e68385af8cd0fd1d5ac">&#9670;&nbsp;</a></span>fminl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fminl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmin">https://en.cppreference.com/w/cpp/numeric/math/fmin</a> </p>

</div>
</div>
<a id="a1ed8605479832389e41046ec57b9ebf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed8605479832389e41046ec57b9ebf3">&#9670;&nbsp;</a></span>fmod() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmod </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a>. </p>

</div>
</div>
<a id="ad5edc9a4f5aaf05aaee40f53925a2907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5edc9a4f5aaf05aaee40f53925a2907">&#9670;&nbsp;</a></span>fmodf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmodf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a>. </p>

</div>
</div>
<a id="ab8cfcffa563969a705bb10c8a19708f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cfcffa563969a705bb10c8a19708f0">&#9670;&nbsp;</a></span>fmod() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmod </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a>. </p>

</div>
</div>
<a id="a93062354e3cf23623c19cdf4e38e7379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93062354e3cf23623c19cdf4e38e7379">&#9670;&nbsp;</a></span>fmod() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmod </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a>. </p>

</div>
</div>
<a id="ae62dab0cf57549d61a2af609727b1a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62dab0cf57549d61a2af609727b1a63">&#9670;&nbsp;</a></span>fmodl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fmodl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a>. </p>

</div>
</div>
<a id="a69fcd9a9618412844bfb6cb9790394b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fcd9a9618412844bfb6cb9790394b3">&#9670;&nbsp;</a></span>hypot() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::hypot </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a48afde86c3996c23be30bae9346a7403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48afde86c3996c23be30bae9346a7403">&#9670;&nbsp;</a></span>hypotf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::hypotf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a71f30dc3ac97f258a80f04b8ea39336b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f30dc3ac97f258a80f04b8ea39336b">&#9670;&nbsp;</a></span>hypot() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::hypot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="abdda7a6eb1bcb8686e3769837c959f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdda7a6eb1bcb8686e3769837c959f07">&#9670;&nbsp;</a></span>hypot() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::hypot </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a3aafdc892d2301b2f0a571692519ab0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aafdc892d2301b2f0a571692519ab0f">&#9670;&nbsp;</a></span>hypotl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::hypotl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a946e30be3d028206c7b77b42a718d305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946e30be3d028206c7b77b42a718d305">&#9670;&nbsp;</a></span>hypot() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::hypot </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="aa8b6df01c497a4410ee0c90dcac298cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b6df01c497a4410ee0c90dcac298cb">&#9670;&nbsp;</a></span>hypot() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::hypot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a080df550166a2674a8353362f290a0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080df550166a2674a8353362f290a0b3">&#9670;&nbsp;</a></span>hypot() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::hypot </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a80bf904f99630edb18fcb3a07117779f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bf904f99630edb18fcb3a07117779f">&#9670;&nbsp;</a></span>isfinite() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isfinite </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. <a href="https://en.cppreference.com/w/cpp/numeric/math/isfinite">https://en.cppreference.com/w/cpp/numeric/math/isfinite</a>. </p>

</div>
</div>
<a id="a813ce51b2632847f81eed1858528ff8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813ce51b2632847f81eed1858528ff8e">&#9670;&nbsp;</a></span>isfinite() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isfinite </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae33b9666e620117df47e7cd5c2faae53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33b9666e620117df47e7cd5c2faae53">&#9670;&nbsp;</a></span>isfinite() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isfinite </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47ef6491e0baea008f09e77e8bdd1893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ef6491e0baea008f09e77e8bdd1893">&#9670;&nbsp;</a></span>isinf() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isinf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a positive or negative infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>true if arg is infinite, false otherwise <a href="https://en.cppreference.com/w/cpp/numeric/math/isinf">https://en.cppreference.com/w/cpp/numeric/math/isinf</a> </dd></dl>

</div>
</div>
<a id="a0bd9c92fc417d48f3b71a556c288f34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd9c92fc417d48f3b71a556c288f34d">&#9670;&nbsp;</a></span>isinf() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isinf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac63899ba5cdbbcbe25e867baaa11c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac63899ba5cdbbcbe25e867baaa11c8a">&#9670;&nbsp;</a></span>isinf() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isinf </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d1a47d9c6cc8ec82135f104f9b5c5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1a47d9c6cc8ec82135f104f9b5c5d6">&#9670;&nbsp;</a></span>isinf() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a605d9e24e916cbbc8f38c7e377eb792d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605d9e24e916cbbc8f38c7e377eb792d">&#9670;&nbsp;</a></span>isnan() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isnan </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a not-a-number (NaN) value. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/isnan">https://en.cppreference.com/w/cpp/numeric/math/isnan</a> </p>

</div>
</div>
<a id="ac4da86e5987c4a4fc2368f5195645c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4da86e5987c4a4fc2368f5195645c3f">&#9670;&nbsp;</a></span>isnan() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isnan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b1b06749558d3368fe928aba61d3b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1b06749558d3368fe928aba61d3b46">&#9670;&nbsp;</a></span>isnan() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isnan </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e91eb4fc3291fad0f13f2c74c57cd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e91eb4fc3291fad0f13f2c74c57cd8f">&#9670;&nbsp;</a></span>isnan() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a not-a-number (NaN) value. <a href="https://en.cppreference.com/w/cpp/numeric/math/isnan">https://en.cppreference.com/w/cpp/numeric/math/isnan</a>. </p>

</div>
</div>
<a id="ac6bb19442837ee1b2540b722ce1c342e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bb19442837ee1b2540b722ce1c342e">&#9670;&nbsp;</a></span>lerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point Float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lerp </td>
          <td>(</td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a+t(b−a), i.e. the linear interpolation between a and b for the parameter t (or extrapolation, when t is outside the range [0,1]). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/lerp">https://en.cppreference.com/w/cpp/numeric/lerp</a> </p>

</div>
</div>
<a id="a7c9b7f32c9ebfadabdad501a192d828c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9b7f32c9ebfadabdad501a192d828c">&#9670;&nbsp;</a></span>lgamma() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lgamma </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a655f9724695ea0b1ec56bbc092789817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655f9724695ea0b1ec56bbc092789817">&#9670;&nbsp;</a></span>lgammaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lgammaf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a4ea2c01b0ca8e4e672c7797bc873547e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea2c01b0ca8e4e672c7797bc873547e">&#9670;&nbsp;</a></span>lgamma() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lgamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a6af7825a746fbacdf9c207c50b52328d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af7825a746fbacdf9c207c50b52328d">&#9670;&nbsp;</a></span>lgamma() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lgamma </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a9644a8b5362db2ea680cbe5c99b06b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9644a8b5362db2ea680cbe5c99b06b1c">&#9670;&nbsp;</a></span>lgammal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lgammal </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a0343114e62c2670e654d329ab0e1bdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0343114e62c2670e654d329ab0e1bdd0">&#9670;&nbsp;</a></span>lgamma() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lgamma </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a4a169fd90c749bd105c7ed917785c555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a169fd90c749bd105c7ed917785c555">&#9670;&nbsp;</a></span>log() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a57095382e9dbd0566b08e4928b380a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57095382e9dbd0566b08e4928b380a0b">&#9670;&nbsp;</a></span>logf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::logf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a572772bba893a4526620c49993f0ebfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572772bba893a4526620c49993f0ebfc">&#9670;&nbsp;</a></span>log() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a82265667a848fe03195c421e0d9fc14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82265667a848fe03195c421e0d9fc14f">&#9670;&nbsp;</a></span>log() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a2e443c1bfefaffc909930e82ad506e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e443c1bfefaffc909930e82ad506e9c">&#9670;&nbsp;</a></span>logl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::logl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a901ea4277603b09bc1fd59c203d1a5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901ea4277603b09bc1fd59c203d1a5bb">&#9670;&nbsp;</a></span>log() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a7f12f27fcd6d0d687061563bf72ff1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f12f27fcd6d0d687061563bf72ff1a1">&#9670;&nbsp;</a></span>log10() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log10 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>. </p>

</div>
</div>
<a id="a78fee06d1d407f722148dab0c23494b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fee06d1d407f722148dab0c23494b7">&#9670;&nbsp;</a></span>log10f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log10f </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>. </p>

</div>
</div>
<a id="ae4a3fb089d374229a5797e5bfef6ebf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a3fb089d374229a5797e5bfef6ebf4">&#9670;&nbsp;</a></span>log10() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log10 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>. </p>

</div>
</div>
<a id="a48a16ee742583cc34fd0d79feeb82c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a16ee742583cc34fd0d79feeb82c3c">&#9670;&nbsp;</a></span>log10() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log10 </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>. </p>

</div>
</div>
<a id="acacfe4fb5b126adc548949313389927b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacfe4fb5b126adc548949313389927b">&#9670;&nbsp;</a></span>log10l()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log10l </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>. </p>

</div>
</div>
<a id="ab1f5caf83538c35d9898a64b78f3d19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f5caf83538c35d9898a64b78f3d19d">&#9670;&nbsp;</a></span>log10() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log10 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a>. </p>

</div>
</div>
<a id="a498813413a98af25e2555e2c54c3256a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498813413a98af25e2555e2c54c3256a">&#9670;&nbsp;</a></span>log1p() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log1p </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="a9b2b22c8715dcf83abd59bb75cb1cdde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2b22c8715dcf83abd59bb75cb1cdde">&#9670;&nbsp;</a></span>log1pf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log1pf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="aaf80a0d8a6fa5bfa402fc5423250e31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf80a0d8a6fa5bfa402fc5423250e31f">&#9670;&nbsp;</a></span>log1p() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log1p </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="a20be7ea716031c69f74aebe909736eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20be7ea716031c69f74aebe909736eb7">&#9670;&nbsp;</a></span>log1p() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log1p </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="a25518821ccfbec031fc0d965aa7270bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25518821ccfbec031fc0d965aa7270bd">&#9670;&nbsp;</a></span>log1pl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log1pl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="ae364b66bba492ce1f0d8cf6cc89926ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae364b66bba492ce1f0d8cf6cc89926ed">&#9670;&nbsp;</a></span>log1p() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log1p </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="namespaceetl.html#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="a187674def6f3f8cb678932d3bae9cbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187674def6f3f8cb678932d3bae9cbec">&#9670;&nbsp;</a></span>log2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>. </p>

</div>
</div>
<a id="a032e2d84a89ad296cc05740845401979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032e2d84a89ad296cc05740845401979">&#9670;&nbsp;</a></span>log2f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log2f </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>. </p>

</div>
</div>
<a id="ad48c54e709d90829fb78c40b755c71c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48c54e709d90829fb78c40b755c71c7">&#9670;&nbsp;</a></span>log2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>. </p>

</div>
</div>
<a id="aa32086c2c749843ddb53344256a91fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32086c2c749843ddb53344256a91fce">&#9670;&nbsp;</a></span>log2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log2 </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>. </p>

</div>
</div>
<a id="aa3fa117f9915cf0572aa57acab4fe659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fa117f9915cf0572aa57acab4fe659">&#9670;&nbsp;</a></span>log2l()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log2l </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>. </p>

</div>
</div>
<a id="a9c53fd481eb75ee3e6bc3ab5cd1b307f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c53fd481eb75ee3e6bc3ab5cd1b307f">&#9670;&nbsp;</a></span>log2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a>. </p>

</div>
</div>
<a id="ad47ed33940ef738b996d13c4fe6b819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47ed33940ef738b996d13c4fe6b819a">&#9670;&nbsp;</a></span>lrint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lrint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="aedd52080b573db11d8e765f46f8e7765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd52080b573db11d8e765f46f8e7765">&#9670;&nbsp;</a></span>lrintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lrintf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="a974d3c30726d8fcb3d66b335f97b2db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974d3c30726d8fcb3d66b335f97b2db0">&#9670;&nbsp;</a></span>lrint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lrint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="ad9d8ad90ada2dcf269313c7d4cb1d088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d8ad90ada2dcf269313c7d4cb1d088">&#9670;&nbsp;</a></span>lrint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lrint </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="ae9f3372f28a951d577490cd5afe08ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f3372f28a951d577490cd5afe08ff0">&#9670;&nbsp;</a></span>lrintl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lrintl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="a197984681c0d3089f3809b6769021ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197984681c0d3089f3809b6769021ac0">&#9670;&nbsp;</a></span>lrint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lrint </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="ad500c9f92de07b192872ebf1d8c85bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad500c9f92de07b192872ebf1d8c85bbd">&#9670;&nbsp;</a></span>llrint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::llrint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="acfebe6109cc6e6cdf8f6910ef52966f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfebe6109cc6e6cdf8f6910ef52966f4">&#9670;&nbsp;</a></span>llrintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::llrintf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="ae026db8a513ac677c58931204032ea87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae026db8a513ac677c58931204032ea87">&#9670;&nbsp;</a></span>llrint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::llrint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="a72786dec8ee1f7facc0e026e8793ea29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72786dec8ee1f7facc0e026e8793ea29">&#9670;&nbsp;</a></span>llrint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::llrint </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="a06be44ea5149be36d471ea497927242b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06be44ea5149be36d471ea497927242b">&#9670;&nbsp;</a></span>llrintl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::llrintl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="adcfc54e2b11311c629c920867ab2f0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfc54e2b11311c629c920867ab2f0cb">&#9670;&nbsp;</a></span>llrint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::llrint </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="a21120c1b64cbc4c4d446f0859a011d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21120c1b64cbc4c4d446f0859a011d82">&#9670;&nbsp;</a></span>nanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nanf </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the implementation-defined character string arg into the corresponding quiet NaN value. </p>
<p>Returns the quiet NaN value that corresponds to the identifying string arg or zero if the implementation does not support quiet NaNs.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nan">https://en.cppreference.com/w/cpp/numeric/math/nan</a> </p>

</div>
</div>
<a id="a7e0c6b512cfa1423e392e02430121c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0c6b512cfa1423e392e02430121c44">&#9670;&nbsp;</a></span>nan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nan </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the implementation-defined character string arg into the corresponding quiet NaN value. </p>
<p>Returns the quiet NaN value that corresponds to the identifying string arg or zero if the implementation does not support quiet NaNs.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nan">https://en.cppreference.com/w/cpp/numeric/math/nan</a> </p>

</div>
</div>
<a id="ae289a4c91b473e5e1302aa1b0142b48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae289a4c91b473e5e1302aa1b0142b48d">&#9670;&nbsp;</a></span>nanl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nanl </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the implementation-defined character string arg into the corresponding quiet NaN value. </p>
<p>Returns the quiet NaN value that corresponds to the identifying string arg or zero if the implementation does not support quiet NaNs.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nan">https://en.cppreference.com/w/cpp/numeric/math/nan</a> </p>

</div>
</div>
<a id="a59be8945c5efec1cdc9860dd0a8f04ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59be8945c5efec1cdc9860dd0a8f04ed">&#9670;&nbsp;</a></span>nextafter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nextafter </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next representable value of from in the direction of to. If from equals to, to is returned. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nextafter">https://en.cppreference.com/w/cpp/numeric/math/nextafter</a> </p>

</div>
</div>
<a id="a7c0420dd56139b0939734e1952cbb1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0420dd56139b0939734e1952cbb1c4">&#9670;&nbsp;</a></span>nextafterf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nextafterf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next representable value of from in the direction of to. If from equals to, to is returned. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nextafter">https://en.cppreference.com/w/cpp/numeric/math/nextafter</a> </p>

</div>
</div>
<a id="a3f83e49db9982e87ce21075dc80cf9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f83e49db9982e87ce21075dc80cf9a5">&#9670;&nbsp;</a></span>nextafter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nextafter </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next representable value of from in the direction of to. If from equals to, to is returned. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nextafter">https://en.cppreference.com/w/cpp/numeric/math/nextafter</a> </p>

</div>
</div>
<a id="a6c50dace9bf8c161755a654d025b1421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c50dace9bf8c161755a654d025b1421">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::pow </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>. </p>

</div>
</div>
<a id="a50df9a7ff64e02368510aff26def2e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50df9a7ff64e02368510aff26def2e97">&#9670;&nbsp;</a></span>powf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::powf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>. </p>

</div>
</div>
<a id="a2ab20e2642b65c1856de9ceff906cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab20e2642b65c1856de9ceff906cc3a">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::pow </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>. </p>

</div>
</div>
<a id="a2b0f48eee9fb05aa553bc44ece921abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0f48eee9fb05aa553bc44ece921abe">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::pow </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>. </p>

</div>
</div>
<a id="a6011900d6daacd4ae59b01436a7b9f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6011900d6daacd4ae59b01436a7b9f1b">&#9670;&nbsp;</a></span>powl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::powl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>. </p>

</div>
</div>
<a id="a77e30624b74c2fca7355bc13cff7c57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e30624b74c2fca7355bc13cff7c57c">&#9670;&nbsp;</a></span>pow() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::pow </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iexp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>. </p>

</div>
</div>
<a id="a4fbc8c440f669809de2fb38d14bd958a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbc8c440f669809de2fb38d14bd958a">&#9670;&nbsp;</a></span>pow() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::pow </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iexp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>. </p>

</div>
</div>
<a id="ae4b3dd1df06d2bf8daf01c17e169d36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b3dd1df06d2bf8daf01c17e169d36c">&#9670;&nbsp;</a></span>pow() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::pow </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iexp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of base raised to the power exp <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a>. </p>

</div>
</div>
<a id="ad02a7e8321924bb554b336b84c2ee60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02a7e8321924bb554b336b84c2ee60d">&#9670;&nbsp;</a></span>remainder() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::remainder </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of the floating point division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a>. </p>

</div>
</div>
<a id="a11dd6c6fa125a008a2226c4f2a8b225f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dd6c6fa125a008a2226c4f2a8b225f">&#9670;&nbsp;</a></span>remainderf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::remainderf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of the floating point division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a>. </p>

</div>
</div>
<a id="ad3bce49452ed33940fa9b1c8d2585072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bce49452ed33940fa9b1c8d2585072">&#9670;&nbsp;</a></span>remainder() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::remainder </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of the floating point division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a>. </p>

</div>
</div>
<a id="a999d51f2384d0b2fbfd76288906b3e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999d51f2384d0b2fbfd76288906b3e2d">&#9670;&nbsp;</a></span>remainder() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::remainder </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of the floating point division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a>. </p>

</div>
</div>
<a id="a2f1521d8219ac8ccb84c5de502919411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1521d8219ac8ccb84c5de502919411">&#9670;&nbsp;</a></span>remainderl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::remainderl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of the floating point division operation x/y. <a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a>. </p>

</div>
</div>
<a id="accd8b50cafa711d52c60a19ca80dee8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd8b50cafa711d52c60a19ca80dee8f">&#9670;&nbsp;</a></span>rint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a285bdc5b020e3beb9ee509210e207dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285bdc5b020e3beb9ee509210e207dd5">&#9670;&nbsp;</a></span>rintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rintf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a315cfa1d5908f72cf3aff4979a814dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315cfa1d5908f72cf3aff4979a814dd3">&#9670;&nbsp;</a></span>rint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a8c6deedd67292f24e059f4a0a6f62f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6deedd67292f24e059f4a0a6f62f1a">&#9670;&nbsp;</a></span>rint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rint </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a36cb8315104a3f48b9fb3e304aa2a6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cb8315104a3f48b9fb3e304aa2a6dd">&#9670;&nbsp;</a></span>rintl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rintl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a1d6a250e98656b00833eb33ee493b12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6a250e98656b00833eb33ee493b12b">&#9670;&nbsp;</a></span>rint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rint </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a653865fab50c43932f405e8e140e1ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653865fab50c43932f405e8e140e1ced">&#9670;&nbsp;</a></span>round() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::round </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="a8200750f9da147ccc3c2f647156ed7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8200750f9da147ccc3c2f647156ed7bb">&#9670;&nbsp;</a></span>roundf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::roundf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="a7e261cc501d3a147de6d342131c222af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e261cc501d3a147de6d342131c222af">&#9670;&nbsp;</a></span>round() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::round </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="a5029f46266d011b01975c90e160ab5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5029f46266d011b01975c90e160ab5d9">&#9670;&nbsp;</a></span>round() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::round </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="a3ec2b94f73e269d1e72241957410aa01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec2b94f73e269d1e72241957410aa01">&#9670;&nbsp;</a></span>roundl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::roundl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="ae0f6ec1f24e0018a43cc5a4017ad7305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f6ec1f24e0018a43cc5a4017ad7305">&#9670;&nbsp;</a></span>round() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::round </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="a5ba0ce5c59de256a555eeaae79891ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba0ce5c59de256a555eeaae79891ad0">&#9670;&nbsp;</a></span>signbit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::signbit </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is negative. </p>
<p>This function detects the sign bit of zeroes, infinities, and NaNs. Along with <a class="el" href="namespaceetl.html#a17223939b148fdd815e90f732a5d2ed8" title="Composes a floating point value with the magnitude of mag and the sign of sgn.">etl::copysign</a>, <a class="el" href="namespaceetl.html#a92f672431014d52f52f9ce327fd19b81">etl::signbit</a> is one of the only two portable ways to examine the sign of a NaN.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/signbit">https://en.cppreference.com/w/cpp/numeric/math/signbit</a> </p>

</div>
</div>
<a id="ae16ba0e54e5210e5103728c522ef59c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16ba0e54e5210e5103728c522ef59c1">&#9670;&nbsp;</a></span>signbit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::signbit </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is negative. </p>
<p>This function detects the sign bit of zeroes, infinities, and NaNs. Along with <a class="el" href="namespaceetl.html#a17223939b148fdd815e90f732a5d2ed8" title="Composes a floating point value with the magnitude of mag and the sign of sgn.">etl::copysign</a>, <a class="el" href="namespaceetl.html#a92f672431014d52f52f9ce327fd19b81">etl::signbit</a> is one of the only two portable ways to examine the sign of a NaN.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/signbit">https://en.cppreference.com/w/cpp/numeric/math/signbit</a> </p>

</div>
</div>
<a id="a6394d0dfcf05ed36d1a93ed7384b3ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6394d0dfcf05ed36d1a93ed7384b3ab4">&#9670;&nbsp;</a></span>signbit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::signbit </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is negative. </p>
<p>This function detects the sign bit of zeroes, infinities, and NaNs. Along with <a class="el" href="namespaceetl.html#a17223939b148fdd815e90f732a5d2ed8" title="Composes a floating point value with the magnitude of mag and the sign of sgn.">etl::copysign</a>, <a class="el" href="namespaceetl.html#a92f672431014d52f52f9ce327fd19b81">etl::signbit</a> is one of the only two portable ways to examine the sign of a NaN.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/signbit">https://en.cppreference.com/w/cpp/numeric/math/signbit</a> </p>

</div>
</div>
<a id="ae3992e7303a218d44e01d6aae6b18a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3992e7303a218d44e01d6aae6b18a92">&#9670;&nbsp;</a></span>sin() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>. </p>

</div>
</div>
<a id="aa57bb2bd32cddffe62ba6a5c56f71189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57bb2bd32cddffe62ba6a5c56f71189">&#9670;&nbsp;</a></span>sinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sinf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>. </p>

</div>
</div>
<a id="a9e32ccfd656cf4acc0e47b2b4b1d3b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e32ccfd656cf4acc0e47b2b4b1d3b7d">&#9670;&nbsp;</a></span>sin() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>. </p>

</div>
</div>
<a id="a31420163d28801f6cb0eaffb9ebee8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31420163d28801f6cb0eaffb9ebee8b7">&#9670;&nbsp;</a></span>sin() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sin </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>. </p>

</div>
</div>
<a id="a8a0b05c4763f8e1661d067f91a5cbbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0b05c4763f8e1661d067f91a5cbbec">&#9670;&nbsp;</a></span>sinl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sinl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>. </p>

</div>
</div>
<a id="af76d0c4880759c4f43e1719488834341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76d0c4880759c4f43e1719488834341">&#9670;&nbsp;</a></span>sin() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sin </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the osine of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a>. </p>

</div>
</div>
<a id="a81ea280e9468d3bccca526a7cbc73651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ea280e9468d3bccca526a7cbc73651">&#9670;&nbsp;</a></span>sinh() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sinh </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>. </p>

</div>
</div>
<a id="a2410ac3995142466f68376374b9d4ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2410ac3995142466f68376374b9d4ec3">&#9670;&nbsp;</a></span>sinhf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sinhf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>. </p>

</div>
</div>
<a id="a134b303ad71ff97a362470bf0d51aeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134b303ad71ff97a362470bf0d51aeea">&#9670;&nbsp;</a></span>sinh() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sinh </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>. </p>

</div>
</div>
<a id="ac254ab46d592daba270994a02a06afbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac254ab46d592daba270994a02a06afbb">&#9670;&nbsp;</a></span>sinh() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sinh </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>. </p>

</div>
</div>
<a id="ab2d2c54a18b0472cabe0c5a66b6daf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d2c54a18b0472cabe0c5a66b6daf30">&#9670;&nbsp;</a></span>sinhl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sinhl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>. </p>

</div>
</div>
<a id="ac40d2d23c8e8fccf96b3b782e667c210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40d2d23c8e8fccf96b3b782e667c210">&#9670;&nbsp;</a></span>sinh() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sinh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a>. </p>

</div>
</div>
<a id="a2e6d19ae1f2df5e1e7f62db7a939946d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6d19ae1f2df5e1e7f62db7a939946d">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sqrt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>. </p>

</div>
</div>
<a id="a5f9f94a766a382b51806352f5e757526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9f94a766a382b51806352f5e757526">&#9670;&nbsp;</a></span>sqrtf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sqrtf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>. </p>

</div>
</div>
<a id="a7e65e7903be2c1a9749a5249e6c790f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e65e7903be2c1a9749a5249e6c790f8">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sqrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>. </p>

</div>
</div>
<a id="a5c22d86b18b9a040289d082be62c4ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c22d86b18b9a040289d082be62c4ec7">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sqrt </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>. </p>

</div>
</div>
<a id="a1b08acd2af82eed59a672ca38721e263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b08acd2af82eed59a672ca38721e263">&#9670;&nbsp;</a></span>sqrtl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sqrtl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>. </p>

</div>
</div>
<a id="acb720e73aa27e1f9c5a3a2bc830bef84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb720e73aa27e1f9c5a3a2bc830bef84">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sqrt </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a>. </p>

</div>
</div>
<a id="aa3e43e254d59d4cd608b1d9f1399167d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e43e254d59d4cd608b1d9f1399167d">&#9670;&nbsp;</a></span>tan() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tan </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>. </p>

</div>
</div>
<a id="ab7cd684aadcdf2df4696dd5c9ae99ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cd684aadcdf2df4696dd5c9ae99ea2">&#9670;&nbsp;</a></span>tanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tanf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>. </p>

</div>
</div>
<a id="a2e6be38a86dc3804ad690b2ea4f3c082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6be38a86dc3804ad690b2ea4f3c082">&#9670;&nbsp;</a></span>tan() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>. </p>

</div>
</div>
<a id="abf39aea93d6cef89e6b047068532251f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf39aea93d6cef89e6b047068532251f">&#9670;&nbsp;</a></span>tan() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tan </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>. </p>

</div>
</div>
<a id="a8821d6a54a089020394afeddd92eb20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8821d6a54a089020394afeddd92eb20c">&#9670;&nbsp;</a></span>tanl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tanl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>. </p>

</div>
</div>
<a id="a82108d39542689318c049d79b7a1443b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82108d39542689318c049d79b7a1443b">&#9670;&nbsp;</a></span>tan() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). <a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a>. </p>

</div>
</div>
<a id="a94a06c6155118cf0eea70d7f72e7ee26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a06c6155118cf0eea70d7f72e7ee26">&#9670;&nbsp;</a></span>tanh() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tanh </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>. </p>

</div>
</div>
<a id="a0b71e15eca59ee5d5814c5df7de5f540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b71e15eca59ee5d5814c5df7de5f540">&#9670;&nbsp;</a></span>tanhf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tanhf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>. </p>

</div>
</div>
<a id="a338f420d3e517380454cff3e76c275de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338f420d3e517380454cff3e76c275de">&#9670;&nbsp;</a></span>tanh() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tanh </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>. </p>

</div>
</div>
<a id="abaa9bf0ccb082968efc0da1be519a4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa9bf0ccb082968efc0da1be519a4d3">&#9670;&nbsp;</a></span>tanh() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tanh </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>. </p>

</div>
</div>
<a id="a770ad213930a5de35a7e4d8efbb65c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770ad213930a5de35a7e4d8efbb65c16">&#9670;&nbsp;</a></span>tanhl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tanhl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>. </p>

</div>
</div>
<a id="a9de6b5cc89e28e1ba7eac7465f380fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de6b5cc89e28e1ba7eac7465f380fba">&#9670;&nbsp;</a></span>tanh() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tanh </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg <a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a>. </p>

</div>
</div>
<a id="a304d035a3a2740c7fef43426fcf3b9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304d035a3a2740c7fef43426fcf3b9cb">&#9670;&nbsp;</a></span>tgamma() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tgamma </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>. </p>

</div>
</div>
<a id="aba0533d6b346e372e13a35a00e4fe5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0533d6b346e372e13a35a00e4fe5ac">&#9670;&nbsp;</a></span>tgammaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tgammaf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>. </p>

</div>
</div>
<a id="a8d14d3d27f8694d9d4b771100bd4c74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d14d3d27f8694d9d4b771100bd4c74e">&#9670;&nbsp;</a></span>tgamma() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tgamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>. </p>

</div>
</div>
<a id="a7455e948ac61779dbd3be0c44190e569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7455e948ac61779dbd3be0c44190e569">&#9670;&nbsp;</a></span>tgamma() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tgamma </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>. </p>

</div>
</div>
<a id="a6252e2a52632b3b841f2b21455c2fa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6252e2a52632b3b841f2b21455c2fa7a">&#9670;&nbsp;</a></span>tgammal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tgammal </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>. </p>

</div>
</div>
<a id="ae31c7fddeeebae7fde466c96fafadd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31c7fddeeebae7fde466c96fafadd4c">&#9670;&nbsp;</a></span>tgamma() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tgamma </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a>. </p>

</div>
</div>
<a id="a77e4586e25e102b1dcd61e06b661ac2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e4586e25e102b1dcd61e06b661ac2d">&#9670;&nbsp;</a></span>trunc() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::trunc </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>. </p>

</div>
</div>
<a id="a9c5336aa0b394c2196ad1b8f15b2441b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5336aa0b394c2196ad1b8f15b2441b">&#9670;&nbsp;</a></span>truncf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::truncf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>. </p>

</div>
</div>
<a id="aa8316f5c97f691318a53cf91fd135894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8316f5c97f691318a53cf91fd135894">&#9670;&nbsp;</a></span>trunc() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::trunc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>. </p>

</div>
</div>
<a id="aa33b0697205c635cb1e294cfecbcfd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33b0697205c635cb1e294cfecbcfd46">&#9670;&nbsp;</a></span>trunc() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::trunc </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>. </p>

</div>
</div>
<a id="aa86cd183532a15f7fb8fa893a9db7d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86cd183532a15f7fb8fa893a9db7d44">&#9670;&nbsp;</a></span>truncl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::truncl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>. </p>

</div>
</div>
<a id="af9896e22ccd29baf6a2bca31d48f6e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9896e22ccd29baf6a2bca31d48f6e4b">&#9670;&nbsp;</a></span>trunc() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::trunc </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. <a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a>. </p>

</div>
</div>
<a id="a1d038b8a789971cb7319f23919ae1d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d038b8a789971cb7319f23919ae1d1f">&#9670;&nbsp;</a></span>is_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a>&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83376b31eb27942ae5c71f06c91decc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83376b31eb27942ae5c71f06c91decc8">&#9670;&nbsp;</a></span>is_neq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_neq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a>&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ec1b19096d66a3614daa7bc0ec0c564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec1b19096d66a3614daa7bc0ec0c564">&#9670;&nbsp;</a></span>is_lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a>&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46b3b676935f0ab36310d8f87b00da2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b3b676935f0ab36310d8f87b00da2d">&#9670;&nbsp;</a></span>is_lteq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_lteq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a>&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52bd271610a81bd07da4d1f15f55ce2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bd271610a81bd07da4d1f15f55ce2b">&#9670;&nbsp;</a></span>is_gt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a>&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ff127460a7b71fec87f3156800a3972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff127460a7b71fec87f3156800a3972">&#9670;&nbsp;</a></span>is_gteq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_gteq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a>&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77deb75e76886e1049e79b9acef5a4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77deb75e76886e1049e79b9acef5a4fa">&#9670;&nbsp;</a></span>abs() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06165982b4ed16fe2e57476b46f4ad08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06165982b4ed16fe2e57476b46f4ad08">&#9670;&nbsp;</a></span>arg() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12078097d0f7a8a5b20b23d8c22a9ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12078097d0f7a8a5b20b23d8c22a9ff2">&#9670;&nbsp;</a></span>arg() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Float &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::arg </td>
          <td>(</td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt;Float&gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt;Float&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58b71dddaa8945219c1a544cf165ef0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b71dddaa8945219c1a544cf165ef0c">&#9670;&nbsp;</a></span>arg() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::arg </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt;Integer&gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt;double&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2348f97d6b5181e2a119bafbde11ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2348f97d6b5181e2a119bafbde11ba2">&#9670;&nbsp;</a></span>requires() <span class="overload">[5/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93401bd9402632426cada76f529d6b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93401bd9402632426cada76f529d6b9f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa112bbaeebf7afad6d876c4291b195c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa112bbaeebf7afad6d876c4291b195c8">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a650bebf4618f883ada09c2039a4b725b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650bebf4618f883ada09c2039a4b725b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac21b902b9c3ad85f752def9d8b61e99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21b902b9c3ad85f752def9d8b61e99c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4cbf5d3ec0e799c656a8c39087e0718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cbf5d3ec0e799c656a8c39087e0718">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator+ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82931442d5539449fd23546e25bb86ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82931442d5539449fd23546e25bb86ae">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a499c18a06cffd9fb9930ba800faa4801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499c18a06cffd9fb9930ba800faa4801">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48f5c49d6dab738f50f9729f5e38ffcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f5c49d6dab738f50f9729f5e38ffcb">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator- </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62d31064099961389d855da11c34cd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d31064099961389d855da11c34cd31">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0dea59a34e6077f3bfdbf0bedc4bc6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dea59a34e6077f3bfdbf0bedc4bc6bf">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9e69e867df1a1b9564f6825a59062b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e69e867df1a1b9564f6825a59062b8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator* </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5e1ecd06afff7b886ff8690bf298584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e1ecd06afff7b886ff8690bf298584">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a73215990ea73911836054392d33c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a73215990ea73911836054392d33c25">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77987b5129ca33aaac1cc7f239d3f0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77987b5129ca33aaac1cc7f239d3f0ba">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator/ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2e6646ea6ece6aac46299e9d0ae0204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e6646ea6ece6aac46299e9d0ae0204">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af1dbf6c912f63446fe62ca363ce14874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dbf6c912f63446fe62ca363ce14874">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89a8fc7be9c1bc3f843a73e0e4084a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a8fc7be9c1bc3f843a73e0e4084a15">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19652b6d64df0961e5821c4df232fcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19652b6d64df0961e5821c4df232fcc5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf4c2db5ab66a07bf724a38c83659acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4c2db5ab66a07bf724a38c83659acd">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd1eb7312810a052d5df24b678a67965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1eb7312810a052d5df24b678a67965">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46ff15d018c17347ac61e95ac1a30764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ff15d018c17347ac61e95ac1a30764">&#9670;&nbsp;</a></span>conj() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::conj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acce7ac5a8dbb8ecf4841a23057e1126b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce7ac5a8dbb8ecf4841a23057e1126b">&#9670;&nbsp;</a></span>conj() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Float &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::conj </td>
          <td>(</td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt;Float&gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt;Float&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5c80be7a4d685217616326a04620a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c80be7a4d685217616326a04620a45">&#9670;&nbsp;</a></span>conj() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::conj </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt;Integer&gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt;double&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a270bd6f09628db22fe5bd8b51dd0b715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270bd6f09628db22fe5bd8b51dd0b715">&#9670;&nbsp;</a></span>cos() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46256752d5c736599fc58eff97661928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46256752d5c736599fc58eff97661928">&#9670;&nbsp;</a></span>cosh() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cosh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3f08cccdf78e0bd6d348c9650dac539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f08cccdf78e0bd6d348c9650dac539">&#9670;&nbsp;</a></span>imag() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::imag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc1933c315d97e15c015707f12c7569b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1933c315d97e15c015707f12c7569b">&#9670;&nbsp;</a></span>imag() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Float &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::imag </td>
          <td>(</td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt;Float&gt;, Float&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4b5cb305b608dff6b0e0726fa3e9aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b5cb305b608dff6b0e0726fa3e9aa0">&#9670;&nbsp;</a></span>imag() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::imag </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt;Integer&gt;, double&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dab176f001bd0087f3f8652eace5c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dab176f001bd0087f3f8652eace5c93">&#9670;&nbsp;</a></span>log() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb87c5a1d5623bb01299fd23324b1565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb87c5a1d5623bb01299fd23324b1565">&#9670;&nbsp;</a></span>log10() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af87ec2d3c345ee05d9ccf2b964c9158a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87ec2d3c345ee05d9ccf2b964c9158a">&#9670;&nbsp;</a></span>norm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6bf99267593c4eb629576e903080e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bf99267593c4eb629576e903080e90">&#9670;&nbsp;</a></span>norm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Float &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::norm </td>
          <td>(</td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt;Float&gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt;Float&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbeee9ca7179220480db518183c9501e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbeee9ca7179220480db518183c9501e">&#9670;&nbsp;</a></span>norm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::norm </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt;Integer&gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt;double&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a408755ab767193cae4b002c03906843a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408755ab767193cae4b002c03906843a">&#9670;&nbsp;</a></span>polar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::polar </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>theta</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1complex.html">etl::complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ef5852f3127713fd9350fb575a52096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef5852f3127713fd9350fb575a52096">&#9670;&nbsp;</a></span>real() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::real </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fac133cf1602f9bec2fd91ac8e93fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fac133cf1602f9bec2fd91ac8e93fbf">&#9670;&nbsp;</a></span>real() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Float &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::real </td>
          <td>(</td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt;Float&gt;, Float&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a371a4a57669e09596d80f1ff4198aae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371a4a57669e09596d80f1ff4198aae5">&#9670;&nbsp;</a></span>real() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::real </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt;Integer&gt;, double&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7eb16919c024711d1b7fbb969fb0f099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb16919c024711d1b7fbb969fb0f099">&#9670;&nbsp;</a></span>sin() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6776dd33fc56dbf0aaf7a9c1ececb72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6776dd33fc56dbf0aaf7a9c1ececb72c">&#9670;&nbsp;</a></span>sinh() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sinh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9543be08a43b5b97cd0ed98b44932467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9543be08a43b5b97cd0ed98b44932467">&#9670;&nbsp;</a></span>tan() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb57b849230e292fb874b066ae1eb6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb57b849230e292fb874b066ae1eb6f2">&#9670;&nbsp;</a></span>tanh() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f88510fb558792c06ba4d60e131fdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f88510fb558792c06ba4d60e131fdd1">&#9670;&nbsp;</a></span>to_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return Int(b);</code> </p>

</div>
</div>
<a id="afc904547fdea8181f43e29bdd2499a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc904547fdea8181f43e29bdd2499a18">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift);</code> </p>

</div>
</div>
<a id="a3715f231cbbd499f1ae94cb720235a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3715f231cbbd499f1ae94cb720235a0a">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift);</code> </p>

</div>
</div>
<a id="afa5333e22ae93bd22aa8bd647619966a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5333e22ae93bd22aa8bd647619966a">&#9670;&nbsp;</a></span>operator&lt;&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&amp;

</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return b = b &lt;&lt; shift;</code> </p>

</div>
</div>
<a id="a071dbaa078a310d6e8bd2aa0eb028695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071dbaa078a310d6e8bd2aa0eb028695">&#9670;&nbsp;</a></span>operator&gt;&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return b = b &gt;&gt; shift;</code> </p>

</div>
</div>
<a id="ab1165be7031be3bc4b2ca83ab0f4da3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1165be7031be3bc4b2ca83ab0f4da3d">&#9670;&nbsp;</a></span>operator|() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) | static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="a49515e2d52191477551bdd9dada0ffe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49515e2d52191477551bdd9dada0ffe7">&#9670;&nbsp;</a></span>operator&amp;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) &amp; static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="a52bf67065e04389a339bfcffa2d58de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bf67065e04389a339bfcffa2d58de7">&#9670;&nbsp;</a></span>operator^() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) ^ static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="a6cb428553f8379a8f3920c202cd85993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb428553f8379a8f3920c202cd85993">&#9670;&nbsp;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator~ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(~static_cast&lt;unsigned int&gt;(b));</code> </p>

</div>
</div>
<a id="a5809b0b530dbcedb43f8300cee97c4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5809b0b530dbcedb43f8300cee97c4d7">&#9670;&nbsp;</a></span>operator|=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs | rhs;</code> </p>

</div>
</div>
<a id="abe619a854c58b98dd311ab0411dd1870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe619a854c58b98dd311ab0411dd1870">&#9670;&nbsp;</a></span>operator&amp;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs &amp; rhs;</code> </p>

</div>
</div>
<a id="acdab0f40108ae4c427a26dd401a81418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdab0f40108ae4c427a26dd401a81418">&#9670;&nbsp;</a></span>operator^=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs ^ rhs;</code> </p>

</div>
</div>
<a id="af70c570009ef313782a1d98cfdadb585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70c570009ef313782a1d98cfdadb585">&#9670;&nbsp;</a></span>atof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atof </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>

</div>
</div>
<a id="a3c7960c7c5d175e0f3618b82c78bcdb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7960c7c5d175e0f3618b82c78bcdb2">&#9670;&nbsp;</a></span>atoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atoi </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="ac7f3cb11f38d582981fb054f50f8a39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f3cb11f38d582981fb054f50f8a39c">&#9670;&nbsp;</a></span>atol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atol </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="afbc340d657073dbc2d05ea36759ac0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc340d657073dbc2d05ea36759ac0e4">&#9670;&nbsp;</a></span>atoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::atoll </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; long long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="a1ac545280f6ddc88082f02e4a7db6736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac545280f6ddc88082f02e4a7db6736">&#9670;&nbsp;</a></span>div() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::div </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1div__t.html">div_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a1b084ea5ad111474f8921643c3de3931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b084ea5ad111474f8921643c3de3931">&#9670;&nbsp;</a></span>labs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::labs </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="a43b5e9350f1530967470589c83376b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b5e9350f1530967470589c83376b30">&#9670;&nbsp;</a></span>div() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::div </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="ab7b706a74e1efaf3c98804627fba671c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b706a74e1efaf3c98804627fba671c">&#9670;&nbsp;</a></span>ldiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ldiv </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a03c11a988c576e5879aa5b6517da8d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c11a988c576e5879aa5b6517da8d3e">&#9670;&nbsp;</a></span>llabs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::llabs </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; long long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="a3ea0cf9ba86f1635030cb6a8f03c88b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea0cf9ba86f1635030cb6a8f03c88b0">&#9670;&nbsp;</a></span>div() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::div </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="ac6958cfa96164c754c7859d22d8e5a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6958cfa96164c754c7859d22d8e5a95">&#9670;&nbsp;</a></span>lldiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lldiv </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a1305ac2417af24cbfd08da05eeb1c32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1305ac2417af24cbfd08da05eeb1c32d">&#9670;&nbsp;</a></span>strtod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strtod </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const **&#160;</td>
          <td class="paramname"><em>last</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4">&#9670;&nbsp;</a></span>strtof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strtof </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const **&#160;</td>
          <td class="paramname"><em>last</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="a4892f7bf3b9db8e5a5b3476de9f04c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4892f7bf3b9db8e5a5b3476de9f04c07">&#9670;&nbsp;</a></span>strtol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strtol </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const **&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtol">https://en.cppreference.com/w/cpp/string/byte/strtol</a> </p>

</div>
</div>
<a id="a53416ace17ca278512fca91c7ba514a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53416ace17ca278512fca91c7ba514a9">&#9670;&nbsp;</a></span>strtoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strtoll </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const **&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtol">https://en.cppreference.com/w/cpp/string/byte/strtol</a> </p>

</div>
</div>
<a id="af4b910e11532f3565d81bd36ff4e4c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b910e11532f3565d81bd36ff4e4c10">&#9670;&nbsp;</a></span>strtold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strtold </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const **&#160;</td>
          <td class="paramname"><em>last</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="a4e80359aae6a19c6d0dc9aee1ba6fcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e80359aae6a19c6d0dc9aee1ba6fcb5">&#9670;&nbsp;</a></span>strtoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strtoul </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const **&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; unsigned long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtoul">https://en.cppreference.com/w/cpp/string/byte/strtoul</a> </p>

</div>
</div>
<a id="a760b4a7bd2816e64811c98ac8e21e5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760b4a7bd2816e64811c98ac8e21e5c3">&#9670;&nbsp;</a></span>strtoull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strtoull </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const **&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; unsigned long long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtoul">https://en.cppreference.com/w/cpp/string/byte/strtoul</a> </p>

</div>
</div>
<a id="a652d4e77b1294b6c89f3b26e64390c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652d4e77b1294b6c89f3b26e64390c60">&#9670;&nbsp;</a></span>memchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::memchr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr. </p>
<p>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by ptr is smaller than count, but the match is found within the array, the behavior is well-defined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/memchr">https://en.cppreference.com/w/cpp/string/byte/memchr</a></p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the location of the character, or a null pointer if no such character is found. </dd></dl>

</div>
</div>
<a id="a017dcc9819e43ade5bb455dda0ded667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017dcc9819e43ade5bb455dda0ded667">&#9670;&nbsp;</a></span>memchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::memchr </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr. </p>
<p>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by ptr is smaller than count, but the match is found within the array, the behavior is well-defined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/memchr">https://en.cppreference.com/w/cpp/string/byte/memchr</a></p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the location of the character, or a null pointer if no such character is found. </dd></dl>

</div>
</div>
<a id="a1a7fa1c3f3f946c9269a7aa241e3efcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7fa1c3f3f946c9269a7aa241e3efcf">&#9670;&nbsp;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="namespaceetl.html#abfee8229e9528f5285c42fde7abbe4b6" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead. </p>

</div>
</div>
<a id="abfee8229e9528f5285c42fde7abbe4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfee8229e9528f5285c42fde7abbe4b6">&#9670;&nbsp;</a></span>memmove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap. </p>

</div>
</div>
<a id="a055dc327ea35a394f661ca98bf2b08ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055dc327ea35a394f661ca98bf2b08ad">&#9670;&nbsp;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the value of c (converted to an unsigned char) into each of the ﬁrst n characters of the object pointed to by s. </p>

</div>
</div>
<a id="abbb9a3999d07c6ea33b804dc470d6db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb9a3999d07c6ea33b804dc470d6db3">&#9670;&nbsp;</a></span>strcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of the character string pointed to by src to the end of the character string pointed to by dest. The character src[0] replaces the null terminator at the end of dest. The resulting byte string is null-terminated. </p>
<p>The behavior is undefined if the destination array is not large enough for the contents of both src and dest and the terminating null character. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="ae924f4675f1be06ee9610b8998d20101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae924f4675f1be06ee9610b8998d20101">&#9670;&nbsp;</a></span>strchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strchr </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strchr">https://en.cppreference.com/w/cpp/string/byte/strchr</a> </p>

</div>
</div>
<a id="afdaf5ecef57c791ea8f5d102444af26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaf5ecef57c791ea8f5d102444af26f">&#9670;&nbsp;</a></span>strchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strchr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strchr">https://en.cppreference.com/w/cpp/string/byte/strchr</a> </p>

</div>
</div>
<a id="a2b99355fef2ddb6740fbda691efe5591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b99355fef2ddb6740fbda691efe5591">&#9670;&nbsp;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strcmp </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the C string lhs to the C string rhs. </p>
<p>This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached. </p>

</div>
</div>
<a id="ac72afd377245fa4f73d8c4c49b5e42fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72afd377245fa4f73d8c4c49b5e42fd">&#9670;&nbsp;</a></span>strcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the character string pointed to by src, including the null terminator, to the character array whose first element is pointed to by dest. </p>
<p>The behavior is undefined if the dest array is not large enough. The behavior is undefined if the strings overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="a07b32f2701df8bd44d7cff9b1ea93c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b32f2701df8bd44d7cff9b1ea93c2c">&#9670;&nbsp;</a></span>strcspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strcspn </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment of the byte string pointed to by dest, that consists of only the characters not found in byte string pointed to by src. </p>
<p>The function name stands for "complementary span"</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strcspn">https://en.cppreference.com/w/cpp/string/byte/strcspn</a> </p>

</div>
</div>
<a id="a1f52f9a0c2a72681b011673eb4d16997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f52f9a0c2a72681b011673eb4d16997">&#9670;&nbsp;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strlen </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the C string str. </p>

</div>
</div>
<a id="a3a52c188c85f66642fdcd0b2a5c0f343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a52c188c85f66642fdcd0b2a5c0f343">&#9670;&nbsp;</a></span>strncat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strncat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> const&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a byte string pointed to by src to a byte string pointed to by dest. At most count characters are copied. The resulting byte string is null-terminated. </p>
<p>The destination byte string must have enough space for the contents of both dest and src plus the terminating null character, except that the size of src is limited to count. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="a86ea9bb99dc7df1c93691e27036d4e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ea9bb99dc7df1c93691e27036d4e4c">&#9670;&nbsp;</a></span>strncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strncmp </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> const&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares at most count characters of two possibly null-terminated arrays. The comparison is done lexicographically. Characters following the null character are not compared. </p>
<p>The behavior is undefined when access occurs past the end of either array lhs or rhs. The behavior is undefined when either lhs or rhs is the null pointer. </p>

</div>
</div>
<a id="a591fc182edd0e8beef7af369c2dd772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591fc182edd0e8beef7af369c2dd772f">&#9670;&nbsp;</a></span>strncpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strncpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> const&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies at most count characters of the byte string pointed to by src (including the terminating null character) to character array pointed to by dest. </p>
<p>If count is reached before the entire string src was copied, the resulting character array is not null-terminated. If, after copying the terminating null character from src, count is not reached, additional null characters are written to dest until the total of count characters have been written. If the strings overlap, the behavior is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="af7504aaa95975de1bb831366bbd2c4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7504aaa95975de1bb831366bbd2c4c7">&#9670;&nbsp;</a></span>strpbrk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strpbrk </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>breakset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strpbrk">https://en.cppreference.com/w/cpp/string/byte/strpbrk</a> </p>

</div>
</div>
<a id="aa2e3a1713cb32006d461f6cacaa45938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e3a1713cb32006d461f6cacaa45938">&#9670;&nbsp;</a></span>strpbrk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strpbrk </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>breakset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strpbrk">https://en.cppreference.com/w/cpp/string/byte/strpbrk</a> </p>

</div>
</div>
<a id="aa1aa1bb3b20e18932c57369e8dd367ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1aa1bb3b20e18932c57369e8dd367ce">&#9670;&nbsp;</a></span>strrchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strrchr </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strrchr">https://en.cppreference.com/w/cpp/string/byte/strrchr</a> </p>

</div>
</div>
<a id="a5f722dadf4562da90ec04a75000dca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f722dadf4562da90ec04a75000dca60">&#9670;&nbsp;</a></span>strrchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strrchr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strrchr">https://en.cppreference.com/w/cpp/string/byte/strrchr</a> </p>

</div>
</div>
<a id="aef81a9b0d796d2bbac780bd021b75d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef81a9b0d796d2bbac780bd021b75d5a">&#9670;&nbsp;</a></span>strspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strspn </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment (span) of the byte string pointed to by dest, that consists of only the characters found in byte string pointed to by src. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strspn">https://en.cppreference.com/w/cpp/string/byte/strspn</a> </p>

</div>
</div>
<a id="abda82eb09b8ee508deb730a58e8e1ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda82eb09b8ee508deb730a58e8e1ad0">&#9670;&nbsp;</a></span>strstr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strstr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared. </p>

</div>
</div>
<a id="a0dedeb847abd763b3016a290b6efd87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dedeb847abd763b3016a290b6efd87e">&#9670;&nbsp;</a></span>strstr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strstr </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared. </p>

</div>
</div>
<a id="afb64ccab832f8ed29a305df495394bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb64ccab832f8ed29a305df495394bd8">&#9670;&nbsp;</a></span>wcscat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcscat </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of the wide string pointed to by src to the end of the wide string pointed to by dest. The wide character src[0] replaces the null terminator at the end of dest. The resulting wide string is null-terminated. </p>
<p>The behavior is undefined if the destination array is not large enough for the contents of both src and dest and the terminating null character. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="ab4f3717d1befc65ded1e73b0dc19405b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f3717d1befc65ded1e73b0dc19405b">&#9670;&nbsp;</a></span>wcschr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcschr </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcschr">https://en.cppreference.com/w/cpp/string/wide/wcschr</a> </p>

</div>
</div>
<a id="afcc2ac1163d4f8e69b06785a16903b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc2ac1163d4f8e69b06785a16903b92">&#9670;&nbsp;</a></span>wcschr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcschr </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcschr">https://en.cppreference.com/w/cpp/string/wide/wcschr</a> </p>

</div>
</div>
<a id="a8dacca606e09097af1b0d48826fbbaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dacca606e09097af1b0d48826fbbaf8">&#9670;&nbsp;</a></span>wcscmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcscmp </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two null-terminated wide strings lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</p>
<p>The behavior is undefined if lhs or rhs are not pointers to null-terminated wide strings. </p>

</div>
</div>
<a id="a777b53d3246198c5cbf458e59cbd05bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777b53d3246198c5cbf458e59cbd05bf">&#9670;&nbsp;</a></span>wcscpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcscpy </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest. </p>
<p>The behavior is undefined if the dest array is not large enough. The behavior is undefined if the strings overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="af4a295816ea0a099202fb0dca32be52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a295816ea0a099202fb0dca32be52c">&#9670;&nbsp;</a></span>wcscspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcscspn </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters not found in wide string pointed to by src. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcscspn">https://en.cppreference.com/w/cpp/string/wide/wcscspn</a> </p>

</div>
</div>
<a id="a52365d01da2db57b4fd8ab457fde90d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52365d01da2db57b4fd8ab457fde90d4">&#9670;&nbsp;</a></span>wcslen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcslen </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character. </p>

</div>
</div>
<a id="a31d334b345c8ec3b4df9ed3017e1a0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d334b345c8ec3b4df9ed3017e1a0e9">&#9670;&nbsp;</a></span>wcsncat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcsncat </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> const&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends at most count wide characters from the wide string pointed to by src to the end of the character string pointed to by dest, stopping if the null terminator is copied. The wide character src[0] replaces the null terminator at the end of dest. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is count+1). </p>
<p>The destination byte string must have enough space for the contents of both dest and src plus the terminating null character, except that the size of src is limited to count. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="ad6cb809db1b2078c2f3a183d9cf15fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cb809db1b2078c2f3a183d9cf15fe6">&#9670;&nbsp;</a></span>wcsncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcsncmp </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares at most count wide characters of two null-terminated wide strings. The comparison is done lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</p>
<p>The behavior is undefined if lhs or rhs are not pointers to null-terminated strings. </p>

</div>
</div>
<a id="a3df6765439e9363b7bd6b29c16e9ad1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df6765439e9363b7bd6b29c16e9ad1e">&#9670;&nbsp;</a></span>wcsncpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcsncpy </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> const&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies at most count characters of the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest. </p>
<p>If count is reached before the entire string src was copied, the resulting character array is not null-terminated. If, after copying the terminating null character from src, count is not reached, additional null characters are written to dest until the total of count characters have been written. If the strings overlap, the behavior is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="a543232e434a1cf41ac373bb986dd6761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543232e434a1cf41ac373bb986dd6761">&#9670;&nbsp;</a></span>wcspbrk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcspbrk </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>breakset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="a8b719c7d907c831543f6a36d7c03c358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b719c7d907c831543f6a36d7c03c358">&#9670;&nbsp;</a></span>wcspbrk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcspbrk </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>breakset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="a5cde920ef4c8b78dad83887cf67520dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cde920ef4c8b78dad83887cf67520dd">&#9670;&nbsp;</a></span>wcsrchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcsrchr </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsrchr">https://en.cppreference.com/w/cpp/string/wide/wcsrchr</a> </p>

</div>
</div>
<a id="a1b66e9eebb616eadbab0b3001b1e9660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b66e9eebb616eadbab0b3001b1e9660">&#9670;&nbsp;</a></span>wcsrchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcsrchr </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsrchr">https://en.cppreference.com/w/cpp/string/wide/wcsrchr</a> </p>

</div>
</div>
<a id="a51c979220a7a1ae7a993a34cce85292a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c979220a7a1ae7a993a34cce85292a">&#9670;&nbsp;</a></span>wcsspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcsspn </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters found in wide string pointed to by src. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsspn">https://en.cppreference.com/w/cpp/string/wide/wcsspn</a> </p>

</div>
</div>
<a id="a32485447cbd1674e0686656279ec028c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32485447cbd1674e0686656279ec028c">&#9670;&nbsp;</a></span>wcsstr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcsstr </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="a074c0611a936348d0a6ca7ddc93df74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074c0611a936348d0a6ca7ddc93df74a">&#9670;&nbsp;</a></span>wcsstr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wcsstr </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="a2e196f654f32975356c8fba3537a39de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e196f654f32975356c8fba3537a39de">&#9670;&nbsp;</a></span>wmemchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wmemchr </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr. </p>
<p>If count is zero, the function returns a null pointer.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemchr">https://en.cppreference.com/w/cpp/string/wide/wmemchr</a> </p>

</div>
</div>
<a id="ae467dc0a0abf29b78d47c3b475ecb5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae467dc0a0abf29b78d47c3b475ecb5ba">&#9670;&nbsp;</a></span>wmemchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wmemchr </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr. </p>
<p>If count is zero, the function returns a null pointer.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemchr">https://en.cppreference.com/w/cpp/string/wide/wmemchr</a> </p>

</div>
</div>
<a id="a379cf75ba2d4c066193884e36556cf04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379cf75ba2d4c066193884e36556cf04">&#9670;&nbsp;</a></span>wmemcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wmemcmp </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first count wide characters of the wide character arrays pointed to by lhs and rhs. The comparison is done lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared. If count is zero, the function does nothing.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemcmp">https://en.cppreference.com/w/cpp/string/wide/wmemcmp</a> </p>

</div>
</div>
<a id="a1d687ebc1e3e94aa01302127c3eb8400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d687ebc1e3e94aa01302127c3eb8400">&#9670;&nbsp;</a></span>wmemcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wmemcpy </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. If the objects overlap, the behavior is undefined. If count is zero, the function does nothing. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemcpy">https://en.cppreference.com/w/cpp/string/wide/wmemcpy</a> </p>

</div>
</div>
<a id="a87cdeb9c67af4a7dfe7cc7ab4c88e390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87cdeb9c67af4a7dfe7cc7ab4c88e390">&#9670;&nbsp;</a></span>wmemmove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wmemmove </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. </p>
<p>If count is zero, the function does nothing. The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to dest. This function is not locale-sensitive and pays no attention to the values of the wchar_t objects it copies: nulls as well as invalid characters are copied too.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemmove">https://en.cppreference.com/w/cpp/string/wide/wmemmove</a> </p>

</div>
</div>
<a id="a24a108d16f8cd8006676972370a2b2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a108d16f8cd8006676972370a2b2ed">&#9670;&nbsp;</a></span>wmemset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::wmemset </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; wchar_t*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the wide character ch into each of the first count wide characters of the wide character array pointed to by dest. </p>
<p>If overflow occurs, the behavior is undefined. If count is zero, the function does nothing.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemset">https://en.cppreference.com/w/cpp/string/wide/wmemset</a> </p>

</div>
</div>
<a id="adf33590c450c820a71740fa96d4fd8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf33590c450c820a71740fa96d4fd8bf">&#9670;&nbsp;</a></span>iswalnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswalnum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is an alphanumeric character, i.e. either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphanumeric character specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswalnum">https://en.cppreference.com/w/cpp/string/wide/iswalnum</a> </p>

</div>
</div>
<a id="a50bb7228a1ec4507b17c3800ae7edaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50bb7228a1ec4507b17c3800ae7edaad">&#9670;&nbsp;</a></span>iswalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswalpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphabetic character specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswalpha">https://en.cppreference.com/w/cpp/string/wide/iswalpha</a> </p>

</div>
</div>
<a id="ace8266a2249c1038e8be09fc34571aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8266a2249c1038e8be09fc34571aa3">&#9670;&nbsp;</a></span>iswblank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswblank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (0x20) and horizontal tab (0x09) are blank characters. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswblank">https://en.cppreference.com/w/cpp/string/wide/iswblank</a> </p>

</div>
</div>
<a id="aa16fb2c6452c7d592f75fad4c301f65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16fb2c6452c7d592f75fad4c301f65f">&#9670;&nbsp;</a></span>iswcntrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswcntrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a control character, i.e. codes 0x00-0x1F and 0x7F and any control characters specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/iscntrl">https://en.cppreference.com/w/cpp/string/byte/iscntrl</a> </p>

</div>
</div>
<a id="a91a984673da6b8253c14ef105d4ecabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a984673da6b8253c14ef105d4ecabe">&#9670;&nbsp;</a></span>iswdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswdigit">https://en.cppreference.com/w/cpp/string/wide/iswdigit</a> </p>

</div>
</div>
<a id="af1f830b2cf289299d90d426cdec407ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f830b2cf289299d90d426cdec407ee">&#9670;&nbsp;</a></span>iswgraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character has a graphical representation, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~) or any graphical character specific to the current C locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswgraph">https://en.cppreference.com/w/cpp/string/wide/iswgraph</a> </p>

</div>
</div>
<a id="a18eb7b15acffae2d169a7eaed66d9ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18eb7b15acffae2d169a7eaed66d9ba8">&#9670;&nbsp;</a></span>iswlower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswlower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a lowercase letter, i.e. one of abcdefghijklmnopqrstuvwxyz or any lowercase letter specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswlower">https://en.cppreference.com/w/cpp/string/wide/iswlower</a> </p>

</div>
</div>
<a id="a92c5da6eb3f6bb1409caaf48fe877d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c5da6eb3f6bb1409caaf48fe877d11">&#9670;&nbsp;</a></span>iswprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswprint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character can be printed, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~), space or any printable character specific to the current C locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswprint">https://en.cppreference.com/w/cpp/string/wide/iswprint</a> </p>

</div>
</div>
<a id="ace0e85b2a576c543e973d860e1c1295f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0e85b2a576c543e973d860e1c1295f">&#9670;&nbsp;</a></span>iswpunct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswpunct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a punctuation character, i.e. it is one of !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~ or any punctuation character specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswpunct">https://en.cppreference.com/w/cpp/string/wide/iswpunct</a> </p>

</div>
</div>
<a id="a38dbfeff185b4dad6a13d3c3e891f366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dbfeff185b4dad6a13d3c3e891f366">&#9670;&nbsp;</a></span>iswspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswspace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following: </p>
<pre class="fragment">- space (0x20, ' ')
- form feed (0x0c, '\f')
- line feed (0x0a, '\n')
- carriage return (0x0d, '\r')
- horizontal tab (0x09, '\t')
- vertical tab (0x0b, '\v')
</pre><p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswspace">https://en.cppreference.com/w/cpp/string/wide/iswspace</a> </p>

</div>
</div>
<a id="ae31f677c72798a1e14ebb84dc2672e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31f677c72798a1e14ebb84dc2672e21">&#9670;&nbsp;</a></span>iswupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is an uppercase letter, i.e. one of ABCDEFGHIJKLMNOPQRSTUVWXYZ or any uppercase letter specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswupper">https://en.cppreference.com/w/cpp/string/wide/iswupper</a> </p>

</div>
</div>
<a id="ac809578dc97747348dcc5795cbfa86ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac809578dc97747348dcc5795cbfa86ff">&#9670;&nbsp;</a></span>iswxdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iswxdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of 0123456789abcdefABCDEF. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswxdigit">https://en.cppreference.com/w/cpp/string/wide/iswxdigit</a> </p>

</div>
</div>
<a id="a84de6738bfdc87aa9da8b107db172a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84de6738bfdc87aa9da8b107db172a43">&#9670;&nbsp;</a></span>towlower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::towlower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given wide character to lowercase, if possible. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/towlower">https://en.cppreference.com/w/cpp/string/wide/towlower</a> </p>

</div>
</div>
<a id="a0a9a0766e4327d94f39e77acc5a88bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9a0766e4327d94f39e77acc5a88bbc">&#9670;&nbsp;</a></span>towupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::towupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a242f9848c8ce5c281284bf133ce1bc94">wint_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given wide character to uppercase, if possible. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/towupper">https://en.cppreference.com/w/cpp/string/wide/towupper</a> </p>

</div>
</div>
<a id="aaf97f58690e1661fa4c536e2a89c9b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf97f58690e1661fa4c536e2a89c9b52">&#9670;&nbsp;</a></span>raise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Exception &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#abb156b0e852ad82749ae42934d3b4dbf">TETL_NO_INLINE</a> <a class="el" href="attributes_8hpp.html#af0eb4be3e44a6a8a9235265e12ad89a7">TETL_COLD</a> auto etl::raise </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af11c4b54fda6c14f1df7ee9acbb8990b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11c4b54fda6c14f1df7ee9acbb8990b">&#9670;&nbsp;</a></span>unexpected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1unexpected.html">etl::unexpected</a> </td>
          <td>(</td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1unexpected.html">unexpected</a>&lt; E &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e4a29ac6268a32d655a572bc728d561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4a29ac6268a32d655a572bc728d561">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Container , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbb7776985e823982b6dd579ea9446a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb7776985e823982b6dd579ea9446a5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Container , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f9846352e3d467e86fb4172d2637104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9846352e3d467e86fb4172d2637104">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Container , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0f945b742cbe77cd2922aca6e578b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f945b742cbe77cd2922aca6e578b56">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Container , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a105dc9103728fcd8f416fecb9b356558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105dc9103728fcd8f416fecb9b356558">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Container , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9c01f47f59173080b54d4233235e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c01f47f59173080b54d4233235e144">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Container , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d1cbfaeb551a2e0c9a49d4bb500bc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1cbfaeb551a2e0c9a49d4bb500bc98">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Container , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; Key, Container, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd52266a9a948c41abe1558e71ac0c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd52266a9a948c41abe1558e71ac0c95">&#9670;&nbsp;</a></span>format_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIt , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto etl::format_to </td>
          <td>(</td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args const &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format args according to the format string fmt, and write the result to the output iterator out. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/format_to">https://en.cppreference.com/w/cpp/utility/format/format_to</a> </p>

</div>
</div>
<a id="aca222d51d5032dd1702938d3a603d705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca222d51d5032dd1702938d3a603d705">&#9670;&nbsp;</a></span>format_to_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIter , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto etl::format_to_n </td>
          <td>(</td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a0e4d7671919f2ad18da41013ecd9dde4">diff_t</a>&lt; OutputIter &gt;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args const &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a>&lt;OutputIter&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format args according to the format string fmt, and write the result to the output iterator out. At most n characters are written. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/format_to_n">https://en.cppreference.com/w/cpp/utility/format/format_to_n</a> </p>

</div>
</div>
<a id="aa401a56ff8788d235f9da9eae62db565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa401a56ff8788d235f9da9eae62db565">&#9670;&nbsp;</a></span>make_format_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Context  = etl::format_context, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto etl::make_format_args </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; detail::format_arg_store&lt;Context, Args...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b34548f40179d322193dd18148c65c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b34548f40179d322193dd18148c65c5">&#9670;&nbsp;</a></span>make_wformat_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto etl::make_wformat_args </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; detail::format_arg_store&lt;<a class="el" href="namespaceetl.html#a7d6b3a02733a03dc5fb0cdcd3c1f7928">wformat_context</a>, Args...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacd3b8fb66cfa5b161911b9be0d00726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd3b8fb66cfa5b161911b9be0d00726">&#9670;&nbsp;</a></span>vformat_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto etl::vformat_to </td>
          <td>(</td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">string_view</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ac9fa9df1563f429e510c612727c974ee">format_args</a>&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a817e57a985d0eab0156aa074d1928761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817e57a985d0eab0156aa074d1928761">&#9670;&nbsp;</a></span>bind_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename... BoundArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::bind_front </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>boundArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function template bind_front generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with its first sizeof...(Args) parameters bound to args. In other words, bind_front(f, bound_args...)(call_args...) is equivalent to invoke(f, bound_args..., call_args....). </p>
<p>Copied implementation from paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0356r5.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0356r5.html</a> </p>

</div>
</div>
<a id="afb3b5926a2945bf5dfa04525b2b3a11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3b5926a2945bf5dfa04525b2b3a11b">&#9670;&nbsp;</a></span>function_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1function__ref.html">etl::function_ref</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(Args...)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a2b9f9a58bfd2eb7843bc6d4993f6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2b9f9a58bfd2eb7843bc6d4993f6e4">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the values of lhs and rhs. Equivalent to lhs.swap(rhs). </p>

</div>
</div>
<a id="a47d8f8d75e5381d2407570b4d97eaf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d8f8d75e5381d2407570b4d97eaf0a">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args, size_t Capacity, size_t Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5" title="Specializes the swap algorithm for array. Swaps the contents of lhs and rhs.">etl::swap</a> algorithm for <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs). </p>

</div>
</div>
<a id="aba26643439d5c5c17e5ef7c933528775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba26643439d5c5c17e5ef7c933528775">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args, size_t Capacity, size_t Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">nullptr_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="aac8c2f711706013a2f8a700a95963fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8c2f711706013a2f8a700a95963fd4">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args, size_t Capacity, size_t Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">nullptr_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a785630c163ba404876a31053f863b666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785630c163ba404876a31053f863b666">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args, size_t Capacity, size_t Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">nullptr_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a71ee6cdf5477e76b8281dd0e20976012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ee6cdf5477e76b8281dd0e20976012">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args, size_t Capacity, size_t Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">nullptr_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; R(Args...), Capacity, Alignment &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a0bd726a99d25fb6e96ef3527de8a0164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd726a99d25fb6e96ef3527de8a0164">&#9670;&nbsp;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::invoke </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a93ed3feabd9624cf09aa604f49155cc2">etl::invoke_result_t</a>&lt;F, Args...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Add noexcept(is_nothrow_invocable_v&lt;F, Args...&gt;) </dd></dl>

</div>
</div>
<a id="a098cf0c6342ba8a4438b83a411d96c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098cf0c6342ba8a4438b83a411d96c11">&#9670;&nbsp;</a></span>requires() <span class="overload">[6/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af8a1ef24a3b6eb7a38ad1307015c2c09">etl::is_invocable_r_v</a>&lt; R, F, Args... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Add noexcept(is_nothrow_invocable_r_v&lt;R, F, Args...&gt;) </dd></dl>

</div>
</div>
<a id="a136cfc6ce9aad022f9c169063db9ed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136cfc6ce9aad022f9c169063db9ed4a">&#9670;&nbsp;</a></span>not_fn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::not_fn </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; detail::not_fn_t&lt;<a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">etl::decay_t</a>&lt;F&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cfabb170ba259721f7f4c19febd88c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfabb170ba259721f7f4c19febd88c5">&#9670;&nbsp;</a></span>not_fn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto ConstFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::not_fn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; detail::stateless_not_fn&lt;ConstFn&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeba1ef9fae68ae0f78265ecaa8a3d598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba1ef9fae68ae0f78265ecaa8a3d598">&#9670;&nbsp;</a></span>reference_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1reference__wrapper.html">etl::reference_wrapper</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a481b27ca7cd9de96cb435adc8a761b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481b27ca7cd9de96cb435adc8a761b2a">&#9670;&nbsp;</a></span>ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ref </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="bitset_8cpp-example.html#a2">bitset.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1f67da318f2742930e9485ebba9b075b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f67da318f2742930e9485ebba9b075b">&#9670;&nbsp;</a></span>ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. </p>

</div>
</div>
<a id="a00752f4906d9b6f07d99ee2eb2719a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00752f4906d9b6f07d99ee2eb2719a09">&#9670;&nbsp;</a></span>cref() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cref </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T const&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. module Utility. </p>

</div>
</div>
<a id="abfb738286bec1789f1f3c417e6e5e600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb738286bec1789f1f3c417e6e5e600">&#9670;&nbsp;</a></span>cref() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T const&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82a6667d8776c1662f72e69e5b6a6ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a6667d8776c1662f72e69e5b6a6ae2">&#9670;&nbsp;</a></span>cref() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void etl::cref </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac45065b143a47fb9249bda8d57ccca63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45065b143a47fb9249bda8d57ccca63">&#9670;&nbsp;</a></span>advance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It , typename Distance &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::advance </td>
          <td>(</td>
          <td class="paramtype">It &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Distance&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments given iterator it by n elements. If n is negative, the iterator is decremented. In this case, InputIt must meet the requirements of LegacyBidirectionalIterator, otherwise the behavior is undefined. </p>
<p><a href="https://en.cppreference.com/w/cpp/iterator/advance">https://en.cppreference.com/w/cpp/iterator/advance</a> </p>

</div>
</div>
<a id="ab4ea18354d7bfc7358bf9c13004f0233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ea18354d7bfc7358bf9c13004f0233">&#9670;&nbsp;</a></span>back_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::back_inserter </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;Container&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>back_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">back_insert_iterator</a> for the container c with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="a3031e070c39546444bdd5fda57ead3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3031e070c39546444bdd5fda57ead3d2">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::begin </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.begin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the given container c or array array. These templates rely on <code>C::begin()</code> having a reasonable implementation. Returns exactly c.begin(), which is typically an iterator to the beginning of the sequence represented by c. If C is a standard Container, this returns <code>C::iterator</code> when c is not const-qualified, and <code>C::const_iterator</code> otherwise. Custom overloads of begin may be provided for classes that do not expose a suitable <a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">begin()</a> member function, yet can be iterated. </p>

</div>
</div>
<a id="a62a601a1d87c13d9bcf1d4b0e2cf6c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a601a1d87c13d9bcf1d4b0e2cf6c1c">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::begin </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.begin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0330eb79a39a00af31e79ece021f90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0330eb79a39a00af31e79ece021f90f">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , etl::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::begin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a085b23b10e801da02c5711b10f67141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085b23b10e801da02c5711b10f67141e">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cbegin </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2">begin</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a259846a061a975e4b40bc6f370701ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259846a061a975e4b40bc6f370701ac6">&#9670;&nbsp;</a></span>data() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::data </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.data())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the block of memory containing the elements of the container. </p>

</div>
</div>
<a id="a76360f238bdab5ae903a7b8b987ab5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76360f238bdab5ae903a7b8b987ab5ac">&#9670;&nbsp;</a></span>data() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::data </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.data())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad94411a453e2a44d4e6b6bf3160b4cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94411a453e2a44d4e6b6bf3160b4cf0">&#9670;&nbsp;</a></span>data() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::data </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af296e322933205aa92418d74103df68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af296e322933205aa92418d74103df68c">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::distance </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;It&gt;::difference_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of hops from first to last. </p>
<p><a href="https://en.cppreference.com/w/cpp/iterator/distance">https://en.cppreference.com/w/cpp/iterator/distance</a> </p>

</div>
</div>
<a id="ab0a91f34436b98eaaeaf7e4ae5e19afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a91f34436b98eaaeaf7e4ae5e19afa">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::empty </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.empty())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given container is empty. </p>

</div>
</div>
<a id="a3868c40892e752ac869410ba4b0f0407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3868c40892e752ac869410ba4b0f0407">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::empty </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf9eb859a31968a9179b29b638cd054b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9eb859a31968a9179b29b638cd054b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::end </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.end())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on. </p>

</div>
</div>
<a id="acd63b79cae3d16f47089c029f77e7152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd63b79cae3d16f47089c029f77e7152">&#9670;&nbsp;</a></span>end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::end </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.end())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f5d203d41447f951c386a27ef969327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5d203d41447f951c386a27ef969327">&#9670;&nbsp;</a></span>end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , etl::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::end </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41acb03578faec2a550c4830c1dd2071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41acb03578faec2a550c4830c1dd2071">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cend </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespaceetl.html#abf9eb859a31968a9179b29b638cd054b">end</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ba99d783e3591913ef343af35fa0c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba99d783e3591913ef343af35fa0c7a">&#9670;&nbsp;</a></span>front_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::front_inserter </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a>&lt;Container&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>front_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> for the container c with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="ad833bc2bd06b05dd97d5c1ede8dde609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad833bc2bd06b05dd97d5c1ede8dde609">&#9670;&nbsp;</a></span>full() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::full </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.full())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given container is full. </p>

</div>
</div>
<a id="adfd013eaad14533bf9fba4c179c07fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd013eaad14533bf9fba4c179c07fb1">&#9670;&nbsp;</a></span>full() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::full </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5eceb5be7f1b46a92d50cb5790ef23fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eceb5be7f1b46a92d50cb5790ef23fa">&#9670;&nbsp;</a></span>requires() <span class="overload">[7/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype">not detail::has_difference_type&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7891ee1f2ce336c151274551bef111d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7891ee1f2ce336c151274551bef111d1">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::next </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; InputIt &gt;::difference_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the nth successor of iterator it. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a3">numeric.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3dd767893eec07cc5b92348b4bb72ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd767893eec07cc5b92348b4bb72ee8">&#9670;&nbsp;</a></span>prev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::prev </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; BidirIt &gt;::difference_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; BidirIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the nth predecessor of iterator it. </p>

</div>
</div>
<a id="a31aadf1fc327da2eaac11d7e6e8617a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31aadf1fc327da2eaac11d7e6e8617a8">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rbegin </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.rbegin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse-beginning of the given container. </p>

</div>
</div>
<a id="a12f3dc4db837147a9d8d28d3f18b40f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f3dc4db837147a9d8d28d3f18b40f5">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rbegin </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.rbegin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36cec4638c522ca6b45b99da908aa1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cec4638c522ca6b45b99da908aa1b7">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rbegin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt;T*&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39cf5b617456b93d23184aaa8495c411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cf5b617456b93d23184aaa8495c411">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::crbegin </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespaceetl.html#a31aadf1fc327da2eaac11d7e6e8617a8">rbegin</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3db12aaf2a7b1819d28995d635d91954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db12aaf2a7b1819d28995d635d91954">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rend </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.rend())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse-end of the given container. </p>

</div>
</div>
<a id="a75830ae03ce26ca2ea7289cc7d83a761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75830ae03ce26ca2ea7289cc7d83a761">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rend </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.rend())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94d4f59f901468f3a8d07e91a27e2ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d4f59f901468f3a8d07e91a27e2ae2">&#9670;&nbsp;</a></span>rend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rend </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt;T*&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04738c0a8b5aa6e0211bbd7a4aa586e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04738c0a8b5aa6e0211bbd7a4aa586e7">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::crend </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespaceetl.html#a3db12aaf2a7b1819d28995d635d91954">rend</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse-end of the given container. </p>

</div>
</div>
<a id="a56fd86ba568b1c1665502fcb72ed4327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fd86ba568b1c1665502fcb72ed4327">&#9670;&nbsp;</a></span>make_reverse_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::make_reverse_iterator </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;Iter&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function template that constructs a <a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">etl::reverse_iterator</a> for the given iterator i (which must be a LegacyBidirectionalIterator) with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="a6ed8eb1bf308acc967006e8073f5a132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed8eb1bf308acc967006e8073f5a132">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1 , typename Iter2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="ab35badce959782a6ae934df29db1e063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35badce959782a6ae934df29db1e063">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1 , typename Iter2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a354acf1f357eacd402309c32fd4d5508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354acf1f357eacd402309c32fd4d5508">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1 , typename Iter2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a6c13e3aeec42ad159690a49c03ea7f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c13e3aeec42ad159690a49c03ea7f19">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1 , typename Iter2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="ac1ba00e40d7921ce12fde9c0c231e4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ba00e40d7921ce12fde9c0c231e4c2">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1 , typename Iter2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a9a2457527f749e948ff13abbd95621c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2457527f749e948ff13abbd95621c9">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1 , typename Iter2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; Iter2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a341ce51287200d6d284558bf674303a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341ce51287200d6d284558bf674303a1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator+ </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iter &gt;::difference_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iter &gt; const &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt;Iter&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator it incremented by n. </p>

</div>
</div>
<a id="ae07adb06319a1e865f85ac0caed0820a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07adb06319a1e865f85ac0caed0820a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator1 , typename Iterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; Iterator2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(rhs.base() - lhs.base())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance between two iterator adaptors. </p>

</div>
</div>
<a id="af3008e042f920b06e2a67b1aa31a1803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3008e042f920b06e2a67b1aa31a1803">&#9670;&nbsp;</a></span>size() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::size </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.size())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the given container c or array array. Returns c.size(), converted to the return type if necessary. </p>

</div>
</div>
<a id="ab2e3325c99005cfa2cad0752fe472c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e3325c99005cfa2cad0752fe472c61">&#9670;&nbsp;</a></span>size() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::size </td>
          <td>(</td>
          <td class="paramtype">T const (&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81bf10a91479176562a6e66eda74a85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bf10a91479176562a6e66eda74a85f">&#9670;&nbsp;</a></span>ssize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ssize </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#aa474dd82a788a57735f0603b85954c37">common_type_t</a>&lt;<a class="el" href="namespaceetl.html#a955e0d5a5e84e9e394bf38a95c8ce380">ptrdiff_t</a>, <a class="el" href="namespaceetl.html#abffe34c79351f871acb3e0438b2ad488">make_signed_t</a>&lt;decltype(c.size())&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abdfe3fbc79d8c1cf42b007bed4267257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfe3fbc79d8c1cf42b007bed4267257">&#9670;&nbsp;</a></span>ssize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , ptrdiff_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ssize </td>
          <td>(</td>
          <td class="paramtype">T const (&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[static_cast&lt; size_t &gt;(N)]</td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a955e0d5a5e84e9e394bf38a95c8ce380">ptrdiff_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29f4f3470cc94fc51e21ebfa58e3292a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f4f3470cc94fc51e21ebfa58e3292a">&#9670;&nbsp;</a></span>abs() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::abs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; int </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="a67112d360fce8458db9b33c097b809b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67112d360fce8458db9b33c097b809b5">&#9670;&nbsp;</a></span>abs() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::abs </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28f2cb4cae4a97ae3b4736ff1aa6b176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f2cb4cae4a97ae3b4736ff1aa6b176">&#9670;&nbsp;</a></span>abs() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::abs </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; long long </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a528fb6eadbb2c38e178a60155197d6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528fb6eadbb2c38e178a60155197d6ac">&#9670;&nbsp;</a></span>abs() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::abs </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5868e5a9aa938b596cd0d8d04d3ecb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5868e5a9aa938b596cd0d8d04d3ecb96">&#9670;&nbsp;</a></span>abs() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b1dae41b3151e867f898e88be2e250b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1dae41b3151e867f898e88be2e250b">&#9670;&nbsp;</a></span>abs() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::abs </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3f57c390bca894ba9abb01107b367fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f57c390bca894ba9abb01107b367fb">&#9670;&nbsp;</a></span>fabs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fabs </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a934ff8b65786c53d2df66654258fb9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934ff8b65786c53d2df66654258fb9d4">&#9670;&nbsp;</a></span>fabsf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fabsf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; float </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebc8c16e1d3253b423b905f31cf7267b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc8c16e1d3253b423b905f31cf7267b">&#9670;&nbsp;</a></span>fabs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fabs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab973f9ba5bac126e950c7ff7e1b45dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab973f9ba5bac126e950c7ff7e1b45dcb">&#9670;&nbsp;</a></span>fabs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fabs </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af57fa73cac5bc77be92e61c2cea2fa4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57fa73cac5bc77be92e61c2cea2fa4b">&#9670;&nbsp;</a></span>fabsl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fabsl </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; long double </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68d6a400b03bbbcc87b81f9a8f70a4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d6a400b03bbbcc87b81f9a8f70a4e5">&#9670;&nbsp;</a></span>ilog2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ilog2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cbcb6eba04cb025fe9ca378236adee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbcb6eba04cb025fe9ca378236adee0">&#9670;&nbsp;</a></span>ipow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ipow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80dd0445f4a32857d03ee0b802a2af19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dd0445f4a32857d03ee0b802a2af19">&#9670;&nbsp;</a></span>ipow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Base&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ipow </td>
          <td>(</td>
          <td class="paramtype">decltype(Base)&#160;</td>
          <td class="paramname"><em>exponent</em></td><td>)</td>
          <td> -&gt; decltype(Base)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07f47998ffec36802839b7fed6d45cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f47998ffec36802839b7fed6d45cfa">&#9670;&nbsp;</a></span>requires() <span class="overload">[8/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Integrals&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">etl::is_convertible_v</a>&lt; Integrals, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> &gt;&#160;</td>
          <td class="paramname"><em>and ...</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>((Integrals(), <a class="el" href="namespaceetl.html#ae174223df490e6263d4648a86326c902">etl::dynamic_extent</a>))... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c58fbe86b83c9dcf5d5f8b2782586c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c58fbe86b83c9dcf5d5f8b2782586c5">&#9670;&nbsp;</a></span>requires() <span class="overload">[9/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CArray &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#afaa46050181985a6156a6c800c86a7d8">is_array_v</a>&lt; CArray &gt; &amp;&amp;<a class="el" href="namespaceetl.html#a4229d4171b460abc833736d622ce9745">rank_v</a>&lt; CArray &gt;&#160;</td>
          <td class="paramname"> = <code>=1</code></td><td>)</td>
          <td> &amp; -&gt;  <a class="el" href="structetl_1_1mdspan.html">mdspan</a>&lt; <a class="el" href="namespaceetl.html#a96e53fc126f7c9ebf9901856b9c2db22">remove_all_extents_t</a>&lt; CArray &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>, <a class="el" href="namespaceetl.html#a115f1cea7fc27ee979afae4871d03a03">extent_v</a>&lt; CArray, 0 &gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af302385ee3f32bd28048db514b905a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af302385ee3f32bd28048db514b905a0c">&#9670;&nbsp;</a></span>requires() <span class="overload">[10/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a>&lt; <a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt; Pointer &gt;&gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="structetl_1_1mdspan.html">mdspan</a>&lt; <a class="el" href="namespaceetl.html#a5e186a746241ab4cfcf810655e8f7844">remove_pointer_t</a>&lt; <a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt; Pointer &gt;&gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8efcf240a782c1116a4eb4782739d7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efcf240a782c1116a4eb4782739d7f9">&#9670;&nbsp;</a></span>requires() <span class="overload">[11/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename... Integrals&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">is_convertible_v</a>&lt; Integrals, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> &gt; &amp;&amp;...) &amp;&amp;sizeof...(Integrals)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03dd62784f99a4dc21c558bb26790faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dd62784f99a4dc21c558bb26790faf">&#9670;&nbsp;</a></span>mdspan() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename IndexType , size_t... ExtentsPack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1mdspan.html">etl::mdspan</a> </td>
          <td>(</td>
          <td class="paramtype">ElementType *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1extents.html">extents</a>&lt; IndexType, ExtentsPack... &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structetl_1_1mdspan.html">mdspan</a>&lt; ElementType, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; IndexType, ExtentsPack... &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ca494e42ded1eb56cf815c645ab4bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca494e42ded1eb56cf815c645ab4bfe">&#9670;&nbsp;</a></span>mdspan() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename MappingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1mdspan.html">etl::mdspan</a> </td>
          <td>(</td>
          <td class="paramtype">ElementType *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingType const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structetl_1_1mdspan.html">mdspan</a>&lt; ElementType, typename MappingType::extents_type, typename MappingType::layout_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a536af133718ba537fce35662e803b0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536af133718ba537fce35662e803b0e7">&#9670;&nbsp;</a></span>mdspan() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MappingType , typename AccessorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1mdspan.html">etl::mdspan</a> </td>
          <td>(</td>
          <td class="paramtype">typename AccessorType::data_handle_type const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingType const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorType const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structetl_1_1mdspan.html">mdspan</a>&lt; typename AccessorType::element_type, typename MappingType::extents_type, typename MappingType::layout_type, AccessorType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa94f2f8d645ecda437b8b417399a808a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94f2f8d645ecda437b8b417399a808a">&#9670;&nbsp;</a></span>strided_slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OffsetType , typename ExtentType , typename StrideType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1strided__slice.html">etl::strided_slice</a> </td>
          <td>(</td>
          <td class="paramtype">OffsetType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtentType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrideType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structetl_1_1strided__slice.html">strided_slice</a>&lt; OffsetType, ExtentType, StrideType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c233c3cfa75e4228eaaa7664506dbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c233c3cfa75e4228eaaa7664506dbc7">&#9670;&nbsp;</a></span>requires() <span class="overload">[12/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">is_object_v</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;. </p>

</div>
</div>
<a id="ab3edffa6af6cd6422babaa5014a3edfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3edffa6af6cd6422babaa5014a3edfe">&#9670;&nbsp;</a></span>requires() <span class="overload">[13/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">is_object_v</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13856fe74510e89b04a2310cbc9bde59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13856fe74510e89b04a2310cbc9bde59">&#9670;&nbsp;</a></span>addressof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::addressof </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb3d4ba5bde672b48bdaa4fd9eec249e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3d4ba5bde672b48bdaa4fd9eec249e">&#9670;&nbsp;</a></span>align()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned. </p>
<p>The function modifies the pointer only if it would be possible to fit the wanted number of bytes aligned by the given alignment into the buffer. If the buffer is too small, the function does nothing and returns nullptr.</p>
<p>The behavior is undefined if alignment is not a power of two. </p>

</div>
</div>
<a id="abfe56da868069c04217458df6422d084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe56da868069c04217458df6422d084">&#9670;&nbsp;</a></span>assume_aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::assume_aligned </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Informs the implementation that the object ptr points to is aligned to at least N. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of assume_aligned. </p>
<p>The program is ill-formed if N is not a power of 2. The behavior is undefined if ptr does not point to an object of type T (ignoring cv-qualification at every level), or if the object's alignment is not at least N.</p>
<p><a href="https://en.cppreference.com/w/cpp/memory/assume_aligned">https://en.cppreference.com/w/cpp/memory/assume_aligned</a> </p>

</div>
</div>
<a id="aa85baa0db208bd4de142559c20735f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85baa0db208bd4de142559c20735f41">&#9670;&nbsp;</a></span>construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args, typename  = decltype(::new(etl::declval&lt;void*&gt;()) T(etl::declval&lt;Args&gt;()...))&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::construct_at </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a T object initialized with arguments args... at given address p. </p>

</div>
</div>
<a id="ab44bc4884adc1e9dc20ddf2363f3da66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44bc4884adc1e9dc20ddf2363f3da66">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::destroy </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the objects in the range [first, last). </p>

</div>
</div>
<a id="a1709580f4bcc18d6efb2b7e4d5c1b728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1709580f4bcc18d6efb2b7e4d5c1b728">&#9670;&nbsp;</a></span>destroy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::destroy_at </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If T is not an array type, calls the destructor of the object pointed to by p, as if by p-&gt;~T(). If T is an array type, recursively destroys elements of *p in order, as if by calling destroy(begin(*p), end(*p)). </p>

</div>
</div>
<a id="a440d38af8f9b00df3d5c1369450ba44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440d38af8f9b00df3d5c1369450ba44a">&#9670;&nbsp;</a></span>destroy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Size &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::destroy_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the n objects in the range starting at first. </p>

</div>
</div>
<a id="aa686fb94d6fbf9538a40cf4040a6ac81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa686fb94d6fbf9538a40cf4040a6ac81">&#9670;&nbsp;</a></span>to_address()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ptr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_address </td>
          <td>(</td>
          <td class="paramtype">Ptr const &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the address represented by p without forming a reference to the object pointed to by p. </p>
<p>Fancy pointer overload: If the expression pointer_traits&lt;Ptr&gt;::to_address(p) is well-formed, returns the result of that expression. Otherwise, returns to_address(p.operator-&gt;()). </p>

</div>
</div>
<a id="a5f9c482d4902a3f7e3af12f0e66963ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9c482d4902a3f7e3af12f0e66963ed">&#9670;&nbsp;</a></span>requires() <span class="overload">[14/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceetl.html#aec3b44fa05f956c1efc4f34af98bd1f0">is_function_v</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the address represented by p without forming a reference to the object pointed to by p. </p>
<p>Raw pointer overload: If T is a function type, the program is ill-formed. Otherwise, returns p unmodified. </p>

</div>
</div>
<a id="aac9b77066dce89b6c75251e5179805f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9b77066dce89b6c75251e5179805f6">&#9670;&nbsp;</a></span>uninitialized_fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto etl::uninitialized_fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66b0627d3000daa570306e2c95d25db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b0627d3000daa570306e2c95d25db1">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1unique__lock.html">unique_lock</a>&lt; Mutex &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1unique__lock.html">unique_lock</a>&lt; Mutex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">unique_lock</a>. Exchanges the state of lhs with that of rhs. </p>

</div>
</div>
<a id="a594a7b7fb202c9a1b6d82115e7a172e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594a7b7fb202c9a1b6d82115e7a172e3">&#9670;&nbsp;</a></span>abs() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::abs </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> -&gt; Type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute value. </p>

</div>
</div>
<a id="afe443a26a34b79fc921c4583df576333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe443a26a34b79fc921c4583df576333">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::accumulate </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of the given value init and the elements in the range <code>[first, last)</code>. <a href="https://en.cppreference.com/w/cpp/algorithm/accumulate">https://en.cppreference.com/w/cpp/algorithm/accumulate</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a7">numeric.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9413959b7ee39d393e7c35ad2cd78294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9413959b7ee39d393e7c35ad2cd78294">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Type , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::accumulate </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8090c84a226cdc13d3b2a1420e1d8e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8090c84a226cdc13d3b2a1420e1d8e4f">&#9670;&nbsp;</a></span>add_sat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::standard_integer Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::add_sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cdf06dcb6cdb229ddf2f001f7063d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdf06dcb6cdb229ddf2f001f7063d82">&#9670;&nbsp;</a></span>adjacent_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::adjacent_difference </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the differences between the second and the first of each adjacent pair of elements of the range [first, last) and writes them to the range beginning at destination + 1. An unmodified copy of *first is written to *destination. </p>

</div>
</div>
<a id="a233e4dea3a5bcb4fa4018e9110735184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233e4dea3a5bcb4fa4018e9110735184">&#9670;&nbsp;</a></span>adjacent_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::adjacent_difference </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab65cd6f8748c172eab6ee36130dca3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65cd6f8748c172eab6ee36130dca3c3">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename N &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::gcd </td>
          <td>(</td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#aa474dd82a788a57735f0603b85954c37">etl::common_type_t</a>&lt;M, N&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of the integers m and n. </p>
<dl class="section return"><dt>Returns</dt><dd>If both m and n are zero, returns zero. Otherwise, returns the greatest common divisor of |m| and |n|. </dd></dl>

</div>
</div>
<a id="a42b02b91109bd6987f6dd8c0cfe583d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b02b91109bd6987f6dd8c0cfe583d5">&#9670;&nbsp;</a></span>inner_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::inner_product </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes inner product (i.e. sum of products) or performs ordered map/reduce operation on the range [first1, last1) and the range beginning at first2. </p>

</div>
</div>
<a id="ae0039bdc9a6970a2089121ae3ee285b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0039bdc9a6970a2089121ae3ee285b1">&#9670;&nbsp;</a></span>inner_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename T , typename BinaryOperation1 , typename BinaryOperation2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::inner_product </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation1&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation2&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44562b8c2da2eb5f51eb8e98d09ea697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44562b8c2da2eb5f51eb8e98d09ea697">&#9670;&nbsp;</a></span>iota()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iota </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the range [first, last) with sequentially increasing values, starting with value and repetitively evaluating ++value. </p>

</div>
</div>
<a id="aef7559b6c18305a231bf5af00443a906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7559b6c18305a231bf5af00443a906">&#9670;&nbsp;</a></span>requires() <span class="overload">[15/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; M &gt; and not <a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">is_same_v</a>&lt; M, bool &gt; and <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; N &gt; and not <a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">is_same_v</a>&lt; N, bool &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the least common multiple of the integers m and n. </p>
<dl class="section return"><dt>Returns</dt><dd>If either m or n is zero, returns zero. Otherwise, returns the least common multiple of |m| and |n|. </dd></dl>

</div>
</div>
<a id="ad78c67d300e374415b47132bd5343d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78c67d300e374415b47132bd5343d85">&#9670;&nbsp;</a></span>requires() <span class="overload">[16/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> &gt; and not <a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>, bool &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns half the sum of a + b. If the sum is odd, the result is rounded towards a. </p>
<p>CppCon 2019: Marshall Clow "midpoint? How Hard Could it Be?" Integer version was updated to match implementation from libc++.</p>
<p><a href="https://www.youtube.com/watch?v=sBtAGxBh-XI">https://www.youtube.com/watch?v=sBtAGxBh-XI</a>) <a href="https://en.cppreference.com/w/cpp/numeric/midpoint">https://en.cppreference.com/w/cpp/numeric/midpoint</a> </p>

</div>
</div>
<a id="a41a32ee33ef899f2d5ae610d855574a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a32ee33ef899f2d5ae610d855574a4">&#9670;&nbsp;</a></span>static_cast&lt; Int &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return a etl::static_cast&lt; <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9de23ef1f08847d45765eaaab59f46d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de23ef1f08847d45765eaaab59f46d5">&#9670;&nbsp;</a></span>midpoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::floating_point Float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::midpoint </td>
          <td>(</td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f46f4ff5229e07caab2a4bfbb7562a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f46f4ff5229e07caab2a4bfbb7562a0">&#9670;&nbsp;</a></span>midpoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ptr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr <a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">etl::is_pointer_v</a>&lt;Ptr&gt; auto etl::midpoint </td>
          <td>(</td>
          <td class="paramtype">Ptr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Ptr
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\synopsis_return Ptr </p>

</div>
</div>
<a id="a717726a2fed08cececaa93b504419300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717726a2fed08cececaa93b504419300">&#9670;&nbsp;</a></span>partial_sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::partial_sum </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the partial sums of the elements in the subranges of the range [first, last) and writes them to the range beginning at destination. This version uses the given binary function op, both applying <a class="el" href="namespaceetl.html#a1b8df3814fc65f04932c2f0d09a56107" title="Moves the elements in the range [first, last), to another range beginning at destination,...">etl::move</a> to their operands on the left hand side. </p>
<p>BinaryFunction must not invalidate any iterators, including the end iterators, or modify any elements of the range involved.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">https://en.cppreference.com/w/cpp/algorithm/partial_sum</a></p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element written. </dd></dl>

</div>
</div>
<a id="a8d274a25ea5a88eb47898c8832795e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d274a25ea5a88eb47898c8832795e3e">&#9670;&nbsp;</a></span>partial_sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::partial_sum </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84c6438ff40771d562eba2df365db32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c6438ff40771d562eba2df365db32b">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T , typename BinaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::reduce </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="namespaceetl.html#afe443a26a34b79fc921c4583df576333" title="Computes the sum of the given value init and the elements in the range [first, last)....">etl::accumulate</a>. <a href="https://en.cppreference.com/w/cpp/algorithm/reduce">https://en.cppreference.com/w/cpp/algorithm/reduce</a>. </p>

</div>
</div>
<a id="af19beb246e0b495f1af0e0dda7ba07ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19beb246e0b495f1af0e0dda7ba07ce">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::reduce </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a714efac01ef228fff45d4f6ab456dfb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714efac01ef228fff45d4f6ab456dfb6">&#9670;&nbsp;</a></span>reduce() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::reduce </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt;InputIter&gt;::value_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a25b53df67d4efc55fb568a2445a29931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b53df67d4efc55fb568a2445a29931">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::make_optional </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt;<a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">etl::decay_t</a>&lt;T&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an optional object from value. </p>

</div>
</div>
<a id="a596e87d0c3bd7cc7e9d514639b141b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596e87d0c3bd7cc7e9d514639b141b04">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::make_optional </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an optional object constructed in-place from args... </p>

</div>
</div>
<a id="ae75cac911cf6d9b9b3b37254bc227e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75cac911cf6d9b9b3b37254bc227e53">&#9670;&nbsp;</a></span>optional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1optional.html">etl::optional</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="optional_8cpp-example.html#a1">optional.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a292197c3724e916aa8255a622fac6917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292197c3724e916aa8255a622fac6917">&#9670;&nbsp;</a></span>requires() <span class="overload">[17/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">is_move_constructible_v</a>&lt; T &gt; &amp;&amp;<a class="el" href="namespaceetl.html#a46cb1671f31576cce07cf1bac1e99f7c">is_swappable_v</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5" title="Specializes the swap algorithm for array. Swaps the contents of lhs and rhs.">etl::swap</a> algorithm for <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs). </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/swap2">https://en.cppreference.com/w/cpp/utility/optional/swap2</a> </p>

</div>
</div>
<a id="a25c716c7d4cedeee80b97e63863bb824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c716c7d4cedeee80b97e63863bb824">&#9670;&nbsp;</a></span>noexcept() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1optional.html">optional</a>&lt;T&gt;&amp; rhs etl::noexcept </td>
          <td>(</td>
          <td class="paramtype">noexcept(lhs.swap(rhs))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d1cc2f7a422e0cadab9361b16f7e875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1cc2f7a422e0cadab9361b16f7e875">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="a0199291e596a6580c028a4fbb4c1a439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0199291e596a6580c028a4fbb4c1a439">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="ad2dad36bf3c15c14d239e80047211e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dad36bf3c15c14d239e80047211e27">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="aa8cfb4c68d3b5bf2a12e64973a9ee892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cfb4c68d3b5bf2a12e64973a9ee892">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="abc6d41e110c97a6f118fac996337da06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6d41e110c97a6f118fac996337da06">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[4/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="a4cd1c4702ae19a08b1aa3f03807f1267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd1c4702ae19a08b1aa3f03807f1267">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[4/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="afbb0eb100ae57232d484215f1b4315d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb0eb100ae57232d484215f1b4315d6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a55bdc0584358e44c777f1ff6dd845026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bdc0584358e44c777f1ff6dd845026">&#9670;&nbsp;</a></span>operator==() <span class="overload">[11/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a8e737d88ff2f1d432403026a91a24766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e737d88ff2f1d432403026a91a24766">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="ad6bf68822d73dd9f0d84b6a5aa3f3618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bf68822d73dd9f0d84b6a5aa3f3618">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[11/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a7d07feb0fa4c7f8287a166fbbe4975ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d07feb0fa4c7f8287a166fbbe4975ee">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a0b91acd82b61f0b96647711aa1414b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b91acd82b61f0b96647711aa1414b71">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[6/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a0ffa5aed44c30aae39950e0d82c7a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffa5aed44c30aae39950e0d82c7a256">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[5/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a3003b74d5cf5363cb983a63f0beaa5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3003b74d5cf5363cb983a63f0beaa5b8">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[6/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="aa2ec0f3b39223f0c48dcae6bf744ac8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ec0f3b39223f0c48dcae6bf744ac8f">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[5/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a070d0943c411911df11ac5176fa48016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070d0943c411911df11ac5176fa48016">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[6/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="ad322ae7ca3d230a2cfb6aae8d633356b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad322ae7ca3d230a2cfb6aae8d633356b">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[5/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a8fe18304d67bab939fd57ac52900323a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe18304d67bab939fd57ac52900323a">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[6/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a975270db4255209c6d0a1664d9072560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975270db4255209c6d0a1664d9072560">&#9670;&nbsp;</a></span>operator==() <span class="overload">[12/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a5311a7c4d14b66f603c0fff05bb0670f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5311a7c4d14b66f603c0fff05bb0670f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[13/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="ad955578770fdb3a931ddd25d78ed03de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad955578770fdb3a931ddd25d78ed03de">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[12/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a86505f8f0a3853f5fd106b17b367ebd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86505f8f0a3853f5fd106b17b367ebd0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[13/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a5d356ce4c5ed39ba60230ccb9bcdc76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d356ce4c5ed39ba60230ccb9bcdc76a">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[7/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a683d8509d04f83a6cb7061df789c630c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683d8509d04f83a6cb7061df789c630c">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[8/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a83a59b23e259ef7140b324f681aa07dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a59b23e259ef7140b324f681aa07dd">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[7/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="abf4a6c0e67c15c1663f2cf60e9281833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4a6c0e67c15c1663f2cf60e9281833">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[8/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a270636ff7b3f10c31fea081efff5be7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270636ff7b3f10c31fea081efff5be7e">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[7/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="af60f7a5afa042d61659f05a0810ac1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60f7a5afa042d61659f05a0810ac1cd">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[8/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a315cb53ac332644f510d613388dc9403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315cb53ac332644f510d613388dc9403">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[7/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a1e08e7d4bbce49c0f236c523f6ca908a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e08e7d4bbce49c0f236c523f6ca908a">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[8/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a740c4c4c7e95fbc853b0f8494375b927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740c4c4c7e95fbc853b0f8494375b927">&#9670;&nbsp;</a></span>generate_canonical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real , size_t Bits, typename RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::generate_canonical </td>
          <td>(</td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td> -&gt; Real
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random floating point number in range [0,1). </p>

</div>
</div>
<a id="a2b146153934880dc3e2994a848584226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b146153934880dc3e2994a848584226">&#9670;&nbsp;</a></span>decay_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::decay_copy </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab25b6713e904e47178a1a000a373097a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25b6713e904e47178a1a000a373097a">&#9670;&nbsp;</a></span>scope_exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1scope__exit.html">etl::scope_exit</a> </td>
          <td>(</td>
          <td class="paramtype">FuncT&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1scope__exit.html">scope_exit</a>&lt; <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; FuncT &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16898ab8f9b95de51802d2ac8840c5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16898ab8f9b95de51802d2ac8840c5cb">&#9670;&nbsp;</a></span>operator==() <span class="overload">[14/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="aeb5ef95c5d2a3f3b77b9d48b0ee394c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5ef95c5d2a3f3b77b9d48b0ee394c6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[14/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="aa51f4f81c713960abeab665d097df056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51f4f81c713960abeab665d097df056">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[9/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="ac570ea8aff6b11f4ff8930690e4c5a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac570ea8aff6b11f4ff8930690e4c5a8e">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[9/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="af1767a8d6dec411f212efe9a29c8e0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1767a8d6dec411f212efe9a29c8e0b3">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[9/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="afb1c3dfb9a3684b8b5905335affb701f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1c3dfb9a3684b8b5905335affb701f">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[9/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Comp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="adbdaddf256aba01af62859d1d068472d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdaddf256aba01af62859d1d068472d">&#9670;&nbsp;</a></span>swap() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for set. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs). </p>

</div>
</div>
<a id="aebf18614592b0fb0ac16bcc76f7cba45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf18614592b0fb0ac16bcc76f7cba45">&#9670;&nbsp;</a></span>as_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::as_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1span.html">span</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1span.html">span</a>&lt;<a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e">byte</a> const, detail::span_as_bytes_size&lt;T, N&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a view to the object representation of the elements of the span s. </p>
<p>If N is dynamic_extent, the extent of the returned span S is also dynamic_extent; otherwise it is sizeof(T) * N. </p>

</div>
</div>
<a id="a214ed44ede7f5b18e511d0a699b5af18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214ed44ede7f5b18e511d0a699b5af18">&#9670;&nbsp;</a></span>requires() <span class="overload">[18/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceetl.html#a40862de0c689f5281b8d680741bc7cf9">is_const_v</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a view to the object representation of the elements of the span s. </p>
<p>If N is dynamic_extent, the extent of the returned span S is also dynamic_extent; otherwise it is sizeof(T) * N. Only participates in overload resolution if is_const_v&lt;T&gt; is false. </p>

</div>
</div>
<a id="a0da3a02a79034271cbc560bc94dbe2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da3a02a79034271cbc560bc94dbe2cd">&#9670;&nbsp;</a></span>span() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , etl::size_t Extent&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1span.html">etl::span</a> </td>
          <td>(</td>
          <td class="paramtype">Type(&amp;)&#160;</td>
          <td class="paramname">[Extent]</td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1span.html">span</a>&lt; Type, Extent &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6ab2c6a5bc678d0ca3f5137c4004543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ab2c6a5bc678d0ca3f5137c4004543">&#9670;&nbsp;</a></span>span() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , etl::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1span.html">etl::span</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; Type, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1span.html">span</a>&lt; Type, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5667307c6ae6ae51fa6d1488fbab93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5667307c6ae6ae51fa6d1488fbab93b">&#9670;&nbsp;</a></span>span() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , etl::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1span.html">etl::span</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; Type, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1span.html">span</a>&lt; Type const, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e186959b2d5132ab142843576d30048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e186959b2d5132ab142843576d30048">&#9670;&nbsp;</a></span>span() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Element  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container&amp;&gt;().data())&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1span.html">etl::span</a> </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1span.html">span</a>&lt; Element &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc55cb127ec094c3dbdec3ed03452ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc55cb127ec094c3dbdec3ed03452ebc">&#9670;&nbsp;</a></span>span() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Element  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container const&amp;&gt;().data())&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1span.html">etl::span</a> </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1span.html">span</a>&lt; Element &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab57d951f6a467976762f8f57f9b49cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57d951f6a467976762f8f57f9b49cee">&#9670;&nbsp;</a></span>stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1stack.html">etl::stack</a> </td>
          <td>(</td>
          <td class="paramtype">Container&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1stack.html">stack</a>&lt; typename Container::value_type, Container &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a335349cd6aae9e810496caeba2c8c7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335349cd6aae9e810496caeba2c8c7cd">&#9670;&nbsp;</a></span>requires() <span class="overload">[19/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a46cb1671f31576cce07cf1bac1e99f7c">is_swappable_v</a>&lt; C &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for stack. Swaps the contents of lhs and rhs. This overload only participates in overload resolution if is_swappable&lt;C&gt;::value is true. </p>

</div>
</div>
<a id="a550be74a772ee835b7969103906449d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550be74a772ee835b7969103906449d0">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , size_t Capacity1, size_t Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;CharT, Capacity1, Traits&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a8f68785d405ab507029b4dc21d784f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f68785d405ab507029b4dc21d784f32">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;CharT, Capacity, Traits&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a3730f573680ab7ee2848994263888494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3730f573680ab7ee2848994263888494">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;CharT, Capacity, Traits&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a0402f15f7abdd70ed375cfc0c967739a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0402f15f7abdd70ed375cfc0c967739a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator+ </td>
          <td>(</td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;CharT, Capacity, Traits&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a1e6e97ff485e83eeab3a47dda30b592b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6e97ff485e83eeab3a47dda30b592b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator+ </td>
          <td>(</td>
          <td class="paramtype">CharT&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;CharT, Capacity, Traits&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a1d6b52bf4545c553a814d0bdb36cfc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6b52bf4545c553a814d0bdb36cfc3b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[15/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="afd7dc7e7afd9ab5389cf089585ecb7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7dc7e7afd9ab5389cf089585ecb7ff">&#9670;&nbsp;</a></span>operator==() <span class="overload">[16/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a1f7c985efe97b9de9bcb2fd57ed62f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7c985efe97b9de9bcb2fd57ed62f63">&#9670;&nbsp;</a></span>operator==() <span class="overload">[17/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="af595ea9358f1b118453f23ce14c7c539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af595ea9358f1b118453f23ce14c7c539">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[15/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a9556a73ed76342b9e3acbfde9f9cdac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9556a73ed76342b9e3acbfde9f9cdac8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[16/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a2996ca93f7497f0f26bc52448cbc3a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2996ca93f7497f0f26bc52448cbc3a87">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[17/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="ac484f684a7e23d519733aa7a1dfdd2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac484f684a7e23d519733aa7a1dfdd2cc">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[10/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a25f66fcbe677016753265cda13588a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f66fcbe677016753265cda13588a02">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[11/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a834f76d59c40a1aaa9b9f45222a5815c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834f76d59c40a1aaa9b9f45222a5815c">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[12/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a105ce49011cd77ed4c6e3b72390ed12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105ce49011cd77ed4c6e3b72390ed12b">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[10/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a24dc9a85456db0c3b0085526ad74898c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dc9a85456db0c3b0085526ad74898c">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[11/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="ad3378b9bc8853f3e35709acd2a945d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3378b9bc8853f3e35709acd2a945d2a">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[12/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a07dbbab6f8321779c8eb9b3b173cb34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07dbbab6f8321779c8eb9b3b173cb34e">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[10/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="af8fe899d26d372e2f56cbe8fa4551770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fe899d26d372e2f56cbe8fa4551770">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[11/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="abd663da7cd107379f89f863f44d18d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd663da7cd107379f89f863f44d18d7c">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[12/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a0e94a2069d38ef480a1f723e594c4f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e94a2069d38ef480a1f723e594c4f60">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[10/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity1, etl::size_t Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity1, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity2, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a1fe7782ee247113a01628108deed5640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe7782ee247113a01628108deed5640">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[11/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="ada97bd78bce6e3f4b4181a18403077da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada97bd78bce6e3f4b4181a18403077da">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[12/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">CharT const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="ad9897e71535e601101f19e29b7fb9c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9897e71535e601101f19e29b7fb9c82">&#9670;&nbsp;</a></span>swap() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; CharT, Capacity, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the <a class="el" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5" title="Specializes the swap algorithm for array. Swaps the contents of lhs and rhs.">etl::swap</a> algorithm for <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">etl::basic_static_string</a>. Swaps the contents of lhs and rhs. Equivalent to lhs.swap(rhs). </p>

</div>
</div>
<a id="a21cf7e5dcda9f55d609ec4236a37c3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cf7e5dcda9f55d609ec4236a37c3b0">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity, typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;CharT, Capacity, Traits&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that compare equal to value from the container. </p>

</div>
</div>
<a id="ae5b84ee8ace15469eade7ad329497759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b84ee8ace15469eade7ad329497759">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , etl::size_t Capacity, typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; CharT, Capacity, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;CharT, Capacity, Traits&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate pred from the container. </p>

</div>
</div>
<a id="a7b5346fd1e1c69c9da34adc6ba0d875b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5346fd1e1c69c9da34adc6ba0d875b">&#9670;&nbsp;</a></span>stof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">static_string</a>&lt; Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; float
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to integer to store the number of characters used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string converted to the specified floating point type. </dd></dl>

</div>
</div>
<a id="a03247c5be7114ad3402fea1ac09a5323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03247c5be7114ad3402fea1ac09a5323">&#9670;&nbsp;</a></span>stod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">static_string</a>&lt; Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to integer to store the number of characters used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string converted to the specified floating point type. </dd></dl>

</div>
</div>
<a id="ad2d8c5321a6401ffca589167c2f5200c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d8c5321a6401ffca589167c2f5200c">&#9670;&nbsp;</a></span>stold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">static_string</a>&lt; Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long double
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to integer to store the number of characters used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string converted to the specified floating point type. </dd></dl>

</div>
</div>
<a id="ad67d02a60ed99d7b4f7caa47c456418c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67d02a60ed99d7b4f7caa47c456418c">&#9670;&nbsp;</a></span>stoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stoi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="ac5e713476eeb2d06c599abb03b3c81da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e713476eeb2d06c599abb03b3c81da">&#9670;&nbsp;</a></span>stol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a3e6979ddaeccf0df75fc74642fad0938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6979ddaeccf0df75fc74642fad0938">&#9670;&nbsp;</a></span>stoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; long long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="aab5ca51303826f354fffce9e40115186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5ca51303826f354fffce9e40115186">&#9670;&nbsp;</a></span>stoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stoul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; unsigned long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a5fff36f8d372c069a8335afa15afab5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fff36f8d372c069a8335afa15afab5d">&#9670;&nbsp;</a></span>stoull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stoull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; unsigned long long
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="aefef503dc1f63ba2e9183e92350a35d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefef503dc1f63ba2e9183e92350a35d6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[18/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , CharT... Chars&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; CharT, Chars... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; CharT, Chars... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06688b616d203a7f05d1902d4e9e9ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06688b616d203a7f05d1902d4e9e9ae6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[19/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , CharT... CharsL, CharT... CharsR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; CharT, CharsL... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; CharT, CharsR... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3175965fb95cd90d46d8741581b050a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3175965fb95cd90d46d8741581b050a9">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_string </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt;Capacity&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a0ae1922b9fe325bc073f9157245ea62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae1922b9fe325bc073f9157245ea62f">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_string </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt;Capacity&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a866ea97f8268ee79e420deb4e7d0b5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866ea97f8268ee79e420deb4e7d0b5c8">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_string </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt;Capacity&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a76cec2c910331a0348fbc177f79fb5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cec2c910331a0348fbc177f79fb5d7">&#9670;&nbsp;</a></span>to_string() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_string </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt;Capacity&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a1591359f7f91cee90f3670ee200fd71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1591359f7f91cee90f3670ee200fd71e">&#9670;&nbsp;</a></span>to_string() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_string </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt;Capacity&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a316c748b2a3e782707bf5f99266226ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316c748b2a3e782707bf5f99266226ce">&#9670;&nbsp;</a></span>to_string() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_string </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt;Capacity&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a3de851aa9fa43387b4735c74a2e913ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de851aa9fa43387b4735c74a2e913ac">&#9670;&nbsp;</a></span>to_string() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_string </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt;Capacity&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="ad12fe48f1155730f6d6beed4ac618c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12fe48f1155730f6d6beed4ac618c03">&#9670;&nbsp;</a></span>to_string() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_string </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt;Capacity&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a252c37b56c955507d6f799b10f6d7bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252c37b56c955507d6f799b10f6d7bf8">&#9670;&nbsp;</a></span>to_string() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_string </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27">etl::static_string</a>&lt;Capacity&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="namespaceetl.html#a8dfb181ab4cdace72138dcfb3b7b8e27" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="ab7e970cc5b5992d8eb7ac649c247c62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e970cc5b5992d8eb7ac649c247c62c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[20/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>Two views are equal if both the size of lhs and rhs are equal and each character in lhs has an equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="ad77dee4d1ef01fa1c6c922c1a02b714f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77dee4d1ef01fa1c6c922c1a02b714f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[21/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd71b3ab7f409fd7b42ffc2c484988dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd71b3ab7f409fd7b42ffc2c484988dc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[22/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac75a10e3bbd7b95eda40943d83c2c213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75a10e3bbd7b95eda40943d83c2c213">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[18/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>Two views are equal if both the size of lhs and rhs are equal and each character in lhs has an equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a37c2dfd4d9e60efce84621bd3f0c999e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c2dfd4d9e60efce84621bd3f0c999e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[19/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adef3d7d5a76fc9b4082213e704c87090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef3d7d5a76fc9b4082213e704c87090">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[20/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc5e98d445c114716af566d56c8846de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5e98d445c114716af566d56c8846de">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[13/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a365ed56c7fa37151b60b488d437a542c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365ed56c7fa37151b60b488d437a542c">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[14/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac86fc574bc6418a5aa73bc9b7189d679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86fc574bc6418a5aa73bc9b7189d679">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[15/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeda576b0bc560a8f6d7fe3ab07ee4f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda576b0bc560a8f6d7fe3ab07ee4f80">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[13/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="ad3d0745dca782dc6ccaf69298ab6a977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d0745dca782dc6ccaf69298ab6a977">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[14/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac858c75276a00249c96cc27219347c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac858c75276a00249c96cc27219347c3d">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[15/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5a16921121279f4b613b0c0228f839b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a16921121279f4b613b0c0228f839b">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[13/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="aafacaaf3ec66f2ff780382a0d1b00c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafacaaf3ec66f2ff780382a0d1b00c76">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[14/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bbf42135bafe3381b402f1f8c229ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbf42135bafe3381b402f1f8c229ef3">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[15/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e8245ad8d38c37448fb6f2b289695f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8245ad8d38c37448fb6f2b289695f3">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[13/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a0c1d78ef0edb2cbc80128926a2cf5873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1d78ef0edb2cbc80128926a2cf5873">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[14/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a261e1e937423beeae22afbe45b8e0579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261e1e937423beeae22afbe45b8e0579">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[15/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , int  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt;&gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a974fb6faa222ecb40a59180647ccb79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974fb6faa222ecb40a59180647ccb79d">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(auto)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ed3d4879ef8b1df2012935a3022f720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed3d4879ef8b1df2012935a3022f720">&#9670;&nbsp;</a></span>forward_as_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::forward_as_tuple </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt;Types&amp;&amp;...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function. The tuple has rvalue reference data members when rvalues are used as arguments, and otherwise has lvalue reference data members. </p>

</div>
</div>
<a id="a722cde6b61e815e5a032f34f922c3e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722cde6b61e815e5a032f34f922c3e99">&#9670;&nbsp;</a></span>make_from_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::make_from_tuple </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7e0097403ec5f189d1192cca821a7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e0097403ec5f189d1192cca821a7e4">&#9670;&nbsp;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::make_tuple </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tuple object, deducing the target type from the types of arguments. </p>

</div>
</div>
<a id="ada3ddae955d45b6a63298906227f2f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3ddae955d45b6a63298906227f2f60">&#9670;&nbsp;</a></span>tie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tie </td>
          <td>(</td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt;Args&amp;...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7332293756222129bddd488f2be46c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7332293756222129bddd488f2be46c89">&#9670;&nbsp;</a></span>get() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; auto&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3910901935da4bd1aa0404bb8e4344cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3910901935da4bd1aa0404bb8e4344cd">&#9670;&nbsp;</a></span>get() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; auto const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44d05954af24fa3a51c81a56eac04b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d05954af24fa3a51c81a56eac04b53">&#9670;&nbsp;</a></span>get() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; auto&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca389dd668b413db5163594031d441dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca389dd668b413db5163594031d441dc">&#9670;&nbsp;</a></span>get() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; auto const&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a308b29ca423e2fd99cd291d2f7ac00af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308b29ca423e2fd99cd291d2f7ac00af">&#9670;&nbsp;</a></span>tuple_cat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::tuple_like... Tuples&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tuple_cat </td>
          <td>(</td>
          <td class="paramtype">Tuples &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a1c3baeebc248b3f787a308af595c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1c3baeebc248b3f787a308af595c6a">&#9670;&nbsp;</a></span>swap() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  void</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27a1a97135d4a41771948063bd8c3a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a1a97135d4a41771948063bd8c3a90">&#9670;&nbsp;</a></span>declval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::declval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="namespaceetl.html#a1498f004a367863b7b1b4f0f8ca3f75d">etl::add_rvalue_reference_t</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57b9b4f72a823403539ecfc03192012e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b9b4f72a823403539ecfc03192012e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rhs , Rhs R, typename Lhs , Lhs L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Rhs, R &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Lhs, L &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;decltype(L + R), L + R&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b41a63ce6030e00a502be9c802192dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b41a63ce6030e00a502be9c802192dc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[23/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rhs , Rhs R, typename Lhs , Lhs L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Rhs, R &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Lhs, L &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;bool, L == R&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a043a792e889d30e7160364a8a4670297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043a792e889d30e7160364a8a4670297">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[21/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rhs , Rhs R, typename Lhs , Lhs L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Rhs, R &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; Lhs, L &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;bool, L != R&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ec5c14f53ef79e0b6debfffb6ce947f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec5c14f53ef79e0b6debfffb6ce947f">&#9670;&nbsp;</a></span>is_constant_evaluated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_constant_evaluated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/is_constant_evaluated">https://en.cppreference.com/w/cpp/types/is_constant_evaluated</a> </p>

</div>
</div>
<a id="a5d2a8839b0088ceabc861e39e5a15daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2a8839b0088ceabc861e39e5a15daa">&#9670;&nbsp;</a></span>test_implicit_default_constructible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void etl::test_implicit_default_constructible </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a904a2454aba7d55b9ff9918d3ca2bc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904a2454aba7d55b9ff9918d3ca2bc23">&#9670;&nbsp;</a></span>requires() <span class="overload">[20/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v</a>&lt; T &gt; &amp;&amp;<a class="el" href="namespaceetl.html#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa798c4fa78e6eaade4cdaf8e42ae8f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa798c4fa78e6eaade4cdaf8e42ae8f7f">&#9670;&nbsp;</a></span>noexcept() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a> etl::noexcept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; &amp;&amp;<a class="el" href="namespaceetl.html#ab5d18b577003e8d090a82e4c6d497cdd">etl::is_nothrow_move_assignable_v</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  void</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53ba91687b857ba136bf8979ce65352b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ba91687b857ba136bf8979ce65352b">&#9670;&nbsp;</a></span>requires() <span class="overload">[21/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , etl::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1is__swappable.html">etl::is_swappable</a>&lt; T &gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td>)[N] const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa180d468fdf2378d57e100ab2bd37ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa180d468fdf2378d57e100ab2bd37ccc">&#9670;&nbsp;</a></span>as_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::as_const </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a06fe98569e6409cac789c54e1e563996">add_const_t</a>&lt;T&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forms lvalue reference to const type of t. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a0">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a467b2ed1f8f9d51ceb6786d6f6cd2c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467b2ed1f8f9d51ceb6786d6f6cd2c1d">&#9670;&nbsp;</a></span>as_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::as_const </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  void=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ba6712de4c274105b7757d5ff5c256d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba6712de4c274105b7757d5ff5c256d">&#9670;&nbsp;</a></span>cmp_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt;T, U&gt; auto etl::cmp_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a1">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a991d919ce72e4c7cacc0d985e362e851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991d919ce72e4c7cacc0d985e362e851">&#9670;&nbsp;</a></span>cmp_greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt;T, U&gt; auto etl::cmp_greater </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="a8e082a5290e35758ae6b74054087ca05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e082a5290e35758ae6b74054087ca05">&#9670;&nbsp;</a></span>cmp_greater_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt;T, U&gt; auto etl::cmp_greater_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="a8d4f3be26a45d1c5877e4b4bbfafe7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4f3be26a45d1c5877e4b4bbfafe7e1">&#9670;&nbsp;</a></span>cmp_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt;T, U&gt; auto etl::cmp_less </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type).</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="aaaa6045b488bf1c8d79050b3e3179907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa6045b488bf1c8d79050b3e3179907">&#9670;&nbsp;</a></span>cmp_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt;T, U&gt; auto etl::cmp_less_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="ac3c1257280c7c023cf896d46505a27ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c1257280c7c023cf896d46505a27ae">&#9670;&nbsp;</a></span>cmp_not_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::comparable_integers&lt;T, U&gt; auto etl::cmp_not_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a2">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abab9c512cd288c92340c8a957b3742fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab9c512cd288c92340c8a957b3742fe">&#9670;&nbsp;</a></span>exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::exchange </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the value of obj with new_value and returns the old value of obj. </p>
<dl class="section return"><dt>Returns</dt><dd>The old value of obj. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a3">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aed541bafacdd55b5d4bd723e6b9bb91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed541bafacdd55b5d4bd723e6b9bb91f">&#9670;&nbsp;</a></span>forward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards lvalues as either lvalues or as rvalues, depending on T. When t is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/forward">https://en.cppreference.com/w/cpp/utility/forward</a> </p>

</div>
</div>
<a id="a7788668573df04d891d55b5433f6e49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7788668573df04d891d55b5433f6e49b">&#9670;&nbsp;</a></span>forward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">remove_reference_t</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9eb59d3fc5e1767148b6803b4b3a1ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb59d3fc5e1767148b6803b4b3a1ba4">&#9670;&nbsp;</a></span>forward_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::forward_like </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; auto&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f77e77ccc84d294f2108336b590d8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f77e77ccc84d294f2108336b590d8ea">&#9670;&nbsp;</a></span>in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> constexpr etl::detail::integer_and_not_char&lt;T&gt; auto etl::in_range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the value of t is in the range of values that can be represented in R, that is, if t can be converted to R without data loss. </p>
<p>It is a compile-time error if either T or R is not a signed or unsigned integer type (including standard integer type and extended integer type). This function cannot be used with <a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>, char, char8_t, char16_t, char32_t, wchar_t and bool.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/in_range">https://en.cppreference.com/w/cpp/utility/in_range</a> </p>

</div>
</div>
<a id="a4c81fb3d2e0ae2e41e87e2381bd9776a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c81fb3d2e0ae2e41e87e2381bd9776a">&#9670;&nbsp;</a></span>move() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::move </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">etl::remove_reference_t</a>&lt;T&gt;&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type. </p>
<dl class="section return"><dt>Returns</dt><dd><code>static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;(t)</code> </dd></dl>

</div>
</div>
<a id="afdd2f9cfbab270ff115707284d5c73a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd2f9cfbab270ff115707284d5c73a7">&#9670;&nbsp;</a></span>move_if_noexcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::move_if_noexcept </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a27f0be4dd8251443fd1dbf06fa9c2bde">etl::conditional_t</a>&lt;!<a class="el" href="namespaceetl.html#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#a045ef39158833b2ba6592fa8a1d0ebc1">etl::is_copy_constructible_v</a>&lt;T&gt;, T const&amp;, T&amp;&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally convert a value to an rvalue. </p>
<p>Same as <a class="el" href="namespaceetl.html#a1b8df3814fc65f04932c2f0d09a56107" title="Moves the elements in the range [first, last), to another range beginning at destination,...">etl::move</a> unless the type's move constructor could throw and the type is copyable, in which case an lvalue-reference is returned instead. </p>

</div>
</div>
<a id="a53eed856cd0d950a984b3f7b4bed78b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53eed856cd0d950a984b3f7b4bed78b4">&#9670;&nbsp;</a></span>pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1pair.html">etl::pair</a> </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a6">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aaa50aa68713ac9f56128ad9c0406b737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa50aa68713ac9f56128ad9c0406b737">&#9670;&nbsp;</a></span>swap() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of x and y. Equivalent to x.swap(y). </p>

</div>
</div>
<a id="a481d5f0f3c183fc9d7407e1275c3040d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481d5f0f3c183fc9d7407e1275c3040d">&#9670;&nbsp;</a></span>make_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::make_pair </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt;T1&gt;, <a class="el" href="namespaceetl.html#aaceeadc8f7b907c46772511ac5ec654c">decay_t</a>&lt;T2&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> object, deducing the target type from the types of arguments. </p>
<p>The deduced types V1 and V2 are <a class="el" href="structetl_1_1decay.html#a5007d73b8fe38a2d0f598c83d63c15c6">etl::decay&lt;T1&gt;::type</a> and <a class="el" href="structetl_1_1decay.html#a5007d73b8fe38a2d0f598c83d63c15c6">etl::decay&lt;T2&gt;::type</a> (the usual type transformations applied to arguments of functions passed by value).</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/pair/make_pair">https://en.cppreference.com/w/cpp/utility/pair/make_pair</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a5">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aca122149a06ebd4ab08b8ed486df0198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca122149a06ebd4ab08b8ed486df0198">&#9670;&nbsp;</a></span>operator==() <span class="overload">[24/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second. </p>

</div>
</div>
<a id="a30eb6d42bd94db249c6bb61f3b07ca8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30eb6d42bd94db249c6bb61f3b07ca8b">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[16/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="a880fb1e1ee9736f911f931c4f10e4a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880fb1e1ee9736f911f931c4f10e4a1c">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[16/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="a9fc0b3aadb4525efaf31a9e8d62acc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc0b3aadb4525efaf31a9e8d62acc46">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[16/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="a110f9b6f4b39272ee65e708330f7905a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110f9b6f4b39272ee65e708330f7905a">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[16/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="abd61172cf5e65c895a94de9f3c4f079e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd61172cf5e65c895a94de9f3c4f079e">&#9670;&nbsp;</a></span>get() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a700f0f867c8a351c79de3b290004521e">tuple_element_t</a>&lt;I, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T1, T2&gt;&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="af679f67dbe70cc1109b995b1c7527580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af679f67dbe70cc1109b995b1c7527580">&#9670;&nbsp;</a></span>get() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a700f0f867c8a351c79de3b290004521e">tuple_element_t</a>&lt;I, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T1, T2&gt;&gt; const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="a02233890b8c93586b3d951747142ee8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02233890b8c93586b3d951747142ee8a">&#9670;&nbsp;</a></span>get() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a700f0f867c8a351c79de3b290004521e">tuple_element_t</a>&lt;I, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T1, T2&gt;&gt;&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="aabd73ffe592700a8dda59dfeae41e9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd73ffe592700a8dda59dfeae41e9c9">&#9670;&nbsp;</a></span>get() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; T1, T2 &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a700f0f867c8a351c79de3b290004521e">tuple_element_t</a>&lt;I, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T1, T2&gt;&gt; const&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="a039de8a03db5998c4a426dcb8a99768b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039de8a03db5998c4a426dcb8a99768b">&#9670;&nbsp;</a></span>requires() <span class="overload">[22/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v</a>&lt; T &gt; and <a class="el" href="namespaceetl.html#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="namespaceetl.html#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v&lt;T&gt;</a> is true. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap">https://en.cppreference.com/w/cpp/algorithm/swap</a> </p>

</div>
</div>
<a id="a4048788ac43f56fd533a797c2af698e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4048788ac43f56fd533a797c2af698e5">&#9670;&nbsp;</a></span>noexcept() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a> etl::noexcept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; and <a class="el" href="namespaceetl.html#ab5d18b577003e8d090a82e4c6d497cdd">etl::is_nothrow_move_assignable_v</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bb415a657944fa6c433f795fdb3a0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb415a657944fa6c433f795fdb3a0b6">&#9670;&nbsp;</a></span>requires() <span class="overload">[23/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , etl::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a46cb1671f31576cce07cf1bac1e99f7c">etl::is_swappable_v</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td>)[N] const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad81467d3810ee7b1ebc9c41ebd6941a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81467d3810ee7b1ebc9c41ebd6941a1">&#9670;&nbsp;</a></span>to_underlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_underlying </td>
          <td>(</td>
          <td class="paramtype">Enum&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a49061e75c4b48962719493fb046259e2">underlying_type_t</a>&lt;Enum&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an enumeration to its underlying type. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/to_underlying">https://en.cppreference.com/w/cpp/utility/to_underlying</a> </p>

</div>
</div>
<a id="addaf10daac93eed1add86c6ca8317c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaf10daac93eed1add86c6ca8317c29">&#9670;&nbsp;</a></span>unreachable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::unreachable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4805fd3b0cdc0a1a3db6475f16708849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4805fd3b0cdc0a1a3db6475f16708849">&#9670;&nbsp;</a></span>operator==() <span class="overload">[25/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="abde631d12e3fa3eadef0726f8a1218ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde631d12e3fa3eadef0726f8a1218ec">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[22/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="ad3d6295f5e016b5d4473335bb3bdc056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d6295f5e016b5d4473335bb3bdc056">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[17/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="ae7e919d889b1cffc2fe30748064be47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e919d889b1cffc2fe30748064be47d">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[17/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="a15e6f06421ee1d47e10ac411d5266606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e6f06421ee1d47e10ac411d5266606">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[17/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="a3c9427318b650a4b9bc68d9c363e7b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9427318b650a4b9bc68d9c363e7b6a">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[17/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="abd3b824f87ab3ce98ad82b777b551b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3b824f87ab3ce98ad82b777b551b2d">&#9670;&nbsp;</a></span>overload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Functor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1overload.html">etl::overload</a> </td>
          <td>(</td>
          <td class="paramtype">Functor...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1overload.html">overload</a>&lt; Functor... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a127a9420152769a476a9e4820580c807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127a9420152769a476a9e4820580c807">&#9670;&nbsp;</a></span>requires() <span class="overload">[24/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::requires </td>
          <td>(</td>
          <td class="paramtype">detail::enable_variant_swap&lt; Ts... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the swap algorithm for variant. Effectively calls lhs.swap(rhs). </p>
<p>This overload participates in overload resolution only if is_move_constructible_v&lt;T_i&gt; and is_swappable_v&lt;T_i&gt; are both true for all T_i in Ts... </p>

</div>
</div>
<a id="a863041a1cb8498c8853e859e29367241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863041a1cb8498c8853e859e29367241">&#9670;&nbsp;</a></span>operator==() <span class="overload">[26/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for variants: </p>
<ul>
<li>If lhs.index() != rhs.index(), returns false;</li>
<li>If lhs.valueless_by_exception(), returns true;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(lhs) == get&lt;lhs.index()&gt;(rhs) </li>
</ul>

</div>
</div>
<a id="add5ac4ee748bb8b9017c1a38e275a288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5ac4ee748bb8b9017c1a38e275a288">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[23/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for variants: </p>
<ul>
<li>If lhs.index() != rhs.index(), returns true;</li>
<li>If lhs.valueless_by_exception(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(lhs) != get&lt;lhs.index()&gt;(rhs) </li>
</ul>

</div>
</div>
<a id="a254c3da6eb0085b05cecc9c4c7586758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254c3da6eb0085b05cecc9c4c7586758">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[18/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than operator for variants: </p>
<ul>
<li>If rhs.valueless_by_exception(), returns false;</li>
<li>If lhs.valueless_by_exception(), returns true;</li>
<li>If lhs.index() &lt; rhs.index(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &lt; get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="a97a1ddfed1011b3663a305e72aca1fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a1ddfed1011b3663a305e72aca1fe0">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[18/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-equal operator for variants: </p>
<ul>
<li>If lhs.valueless_by_exception(), returns true;</li>
<li>If rhs.valueless_by_exception(), returns false;</li>
<li>If lhs.index() &lt; rhs.index(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &lt;= get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="afe841983c5c96ec128c540e07d8ae590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe841983c5c96ec128c540e07d8ae590">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[18/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than operator for variants: </p>
<ul>
<li>If lhs.valueless_by_exception(), returns false;</li>
<li>If rhs.valueless_by_exception(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns true;</li>
<li>If lhs.index() &lt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &gt; get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="ae46d330593ce07ddecb63c78618e1f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46d330593ce07ddecb63c78618e1f73">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[18/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-equal operator for variants: </p>
<ul>
<li>If lhs.valueless_by_exception(), returns false;</li>
<li>If rhs.valueless_by_exception(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns true;</li>
<li>If lhs.index() &lt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &gt;= get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="aaf81f6c62201f50e40031c362915e191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf81f6c62201f50e40031c362915e191">&#9670;&nbsp;</a></span>holds_alternative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::holds_alternative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the variant v holds the alternative T. The call is ill-formed if T does not appear exactly once in Ts... </p>

</div>
</div>
<a id="a7f35bc3fbdafc55d32dfd35bf1f7d446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f35bc3fbdafc55d32dfd35bf1f7d446">&#9670;&nbsp;</a></span>unchecked_get() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt;  auto &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="a3c84339b3f6aa69a3df586dc2a5b1f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c84339b3f6aa69a3df586dc2a5b1f69">&#9670;&nbsp;</a></span>unchecked_get() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt;  auto const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="ab54d98119a0f0e56078324af917a37e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54d98119a0f0e56078324af917a37e7">&#9670;&nbsp;</a></span>unchecked_get() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt;  auto &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="abf7502c4e6253168a35b9f80528d9264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7502c4e6253168a35b9f80528d9264">&#9670;&nbsp;</a></span>unchecked_get() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt;  auto const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="a5756e54810f927e033e5cce195c7501e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5756e54810f927e033e5cce195c7501e">&#9670;&nbsp;</a></span>get_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; *&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2ab42b86be16dbdbaa744a2caaca7e80">add_pointer_t</a>&lt;<a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt;I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant. </p>
<p>Type-based non-throwing accessor: The call is ill-formed if T is not a unique element of Ts.... </p>

</div>
</div>
<a id="a72842431b135e51894f5c6a7752cf12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72842431b135e51894f5c6a7752cf12a">&#9670;&nbsp;</a></span>get_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const *&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2ab42b86be16dbdbaa744a2caaca7e80">add_pointer_t</a>&lt;<a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt;I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt; const&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant. </p>
<p>Type-based non-throwing accessor: The call is ill-formed if T is not a unique element of Ts.... </p>

</div>
</div>
<a id="a77a6d812774670ddf34c1d44f62e14ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a6d812774670ddf34c1d44f62e14ea">&#9670;&nbsp;</a></span>get() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt;I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="a666956f74e899e9b7e1dbc505dbabfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666956f74e899e9b7e1dbc505dbabfa1">&#9670;&nbsp;</a></span>get() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt;I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt;&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="a31721b496f003097daaae13eed0e05a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31721b496f003097daaae13eed0e05a9">&#9670;&nbsp;</a></span>get() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt;I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt; const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="afe303a47b99addb10aa27283e98e34e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe303a47b99addb10aa27283e98e34e5">&#9670;&nbsp;</a></span>get() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a>&lt;I, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt; const&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="a6f4d75c3208d681357d77774b729444d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4d75c3208d681357d77774b729444d">&#9670;&nbsp;</a></span>unchecked_get() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt;  auto &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaa90ac4a6cf3911ab23789c9af4d089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa90ac4a6cf3911ab23789c9af4d089">&#9670;&nbsp;</a></span>unchecked_get() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt;  auto const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c39898b60620723d80247080de0439d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c39898b60620723d80247080de0439d">&#9670;&nbsp;</a></span>unchecked_get() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt;  auto &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ec2c2a52094776da58ed54719f0bcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec2c2a52094776da58ed54719f0bcbd">&#9670;&nbsp;</a></span>unchecked_get() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt;  auto const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeffc9f0ae12737a221731fd43249e944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffc9f0ae12737a221731fd43249e944">&#9670;&nbsp;</a></span>get_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; *&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="namespaceetl.html#a2ab42b86be16dbdbaa744a2caaca7e80">add_pointer_t</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32dbeed267147923b02448b493be930d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dbeed267147923b02448b493be930d">&#9670;&nbsp;</a></span>get_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; const *&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="namespaceetl.html#a2ab42b86be16dbdbaa744a2caaca7e80">add_pointer_t</a>&lt; T const &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa43fcb4942d4cec1824f6e38edce9981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43fcb4942d4cec1824f6e38edce9981">&#9670;&nbsp;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Vs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::visit </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the visitor vis (Callable that can be called with any combination of types from variants) to the variants vars. </p>
<p>Every type in <a class="el" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">etl::remove_reference_t&lt;Variants&gt;</a>... may be a (possibly const-qualified) specialization of <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>. It is unspecified whether other argument types, e.g. a class derived from a <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>, are supported.</p>
<p>Copied from <a href="https://github.com/rollbear/visit">https://github.com/rollbear/visit</a> <a href="https://github.com/rollbear/visit/blob/master/LICENSE.txt">https://github.com/rollbear/visit/blob/master/LICENSE.txt</a> </p>

</div>
</div>
<a id="ac1c5f129858d55474d1d7ae92c374456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c5f129858d55474d1d7ae92c374456">&#9670;&nbsp;</a></span>swap() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">static_vector</a>. Swaps the contents of lhs and rhs. </p>

</div>
</div>
<a id="a9d3aa3446aca179d812252faf83360c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3aa3446aca179d812252faf83360c6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[27/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="a3d2867e9d12d25137a50a1b3aee3c5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2867e9d12d25137a50a1b3aee3c5a7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[24/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0dfb93223a9c8e4413fe9368cd36046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dfb93223a9c8e4413fe9368cd36046">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[19/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a715395c53fa693969e269ef5af1972e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715395c53fa693969e269ef5af1972e6">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[19/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4fd2ea0cf33ad9339a54469a92f5121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fd2ea0cf33ad9339a54469a92f5121">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[19/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebf47ed021fd1e8bfbc389525967e551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf47ed021fd1e8bfbc389525967e551">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[19/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6028d08459dc299edcae40876481fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6028d08459dc299edcae40876481fca">&#9670;&nbsp;</a></span>erase_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity, typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt;T, Capacity&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate pred from the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of erased elements.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/container/vector/erase2">https://en.cppreference.com/w/cpp/container/vector/erase2</a> </p>

</div>
</div>
<a id="a7eea328e45af7e2f0cba2ecf9bfae03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eea328e45af7e2f0cba2ecf9bfae03e">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity, typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt;T, Capacity&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47b8bc94405a580d276749fde24834f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b8bc94405a580d276749fde24834f7">&#9670;&nbsp;</a></span>is_hosted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">consteval auto etl::is_hosted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0643ba313eeb2da0a37a713fa74cb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0643ba313eeb2da0a37a713fa74cb5f">&#9670;&nbsp;</a></span>is_freestanding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">consteval auto etl::is_freestanding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b353c6f122b14a8e9b78c453d8fa381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b353c6f122b14a8e9b78c453d8fa381">&#9670;&nbsp;</a></span>operator==() <span class="overload">[28/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares language_standards. </p>

</div>
</div>
<a id="a0be806bd6b96b20e9313a7e398cc5783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be806bd6b96b20e9313a7e398cc5783">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[25/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb2e2b8ee1daac1fdf220e6aad21fbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2e2b8ee1daac1fdf220e6aad21fbea">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[20/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ff7b111685f53a1a28d184323c9a7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff7b111685f53a1a28d184323c9a7c3">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[20/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5748614e8daf5563998666a4584ee575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5748614e8daf5563998666a4584ee575">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[20/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00deb6a88953ac9fe457f6f79b347152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00deb6a88953ac9fe457f6f79b347152">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[20/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acce870bde6a96dc0634f235573439dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce870bde6a96dc0634f235573439dd1">&#9670;&nbsp;</a></span>ignore_unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::ignore_unused </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly ignore arguments or variables. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) -&gt; <span class="keywordtype">int</span></div>
<div class="line">{</div>
<div class="line">  <a class="code" href="namespaceetl.html#acce870bde6a96dc0634f235573439dd1">etl::ignore_unused</a>(argc, argv);</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceetl_html_acce870bde6a96dc0634f235573439dd1"><div class="ttname"><a href="namespaceetl.html#acce870bde6a96dc0634f235573439dd1">etl::ignore_unused</a></div><div class="ttdeci">constexpr auto ignore_unused(Types &amp;&amp;...) -&gt; void</div><div class="ttdoc">Explicitly ignore arguments or variables.</div><div class="ttdef"><b>Definition:</b> ignore_unused.hpp:16</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af9b15653958e67cfe944d92826719780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b15653958e67cfe944d92826719780">&#9670;&nbsp;</a></span>Size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">etl::Size</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keyword">using</span> value_type = T</div>
</div><!-- fragment -->
</div>
</div>
<a id="aedb63d88f3219c350ab03af8bd0adb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb63d88f3219c350ab03af8bd0adb5a">&#9670;&nbsp;</a></span>is_bitmask_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_bitmask_type_v = <a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef47ac360905d8fac28fb87847a855ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef47ac360905d8fac28fb87847a855ec">&#9670;&nbsp;</a></span>bitmask_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::bitmask_type = <a class="el" href="namespaceetl.html#aedb63d88f3219c350ab03af8bd0adb5a">is_bitmask_type_v</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8cc35f4fca27a07908f67b7ef595cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cc35f4fca27a07908f67b7ef595cd3">&#9670;&nbsp;</a></span>binary</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::binary = <a class="el" href="structetl_1_1binary__t.html">binary_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d5911bdc109e2c7265b7486da04e8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5911bdc109e2c7265b7486da04e8b8">&#9670;&nbsp;</a></span>last</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * etl::last</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51c15a5d5f4ab487941035d024cad9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c15a5d5f4ab487941035d024cad9d7">&#9670;&nbsp;</a></span>value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const <a class="el" href="namespaceetl.html#af4f837bf0258547b23e4f04e4d03e6d1">Int</a>&amp; etl::value</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="optional_8cpp-example.html#a3">optional.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa2a7c3cbcd306c97b268134f54e90d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a7c3cbcd306c97b268134f54e90d2d">&#9670;&nbsp;</a></span>val</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char T etl::val</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="type_traits_8cpp-example.html#a0">type_traits.cpp</a>, and <a class="el" href="utility_8cpp-example.html#a9">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a299d1930276b590319d37b6b2afa6724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299d1930276b590319d37b6b2afa6724">&#9670;&nbsp;</a></span>base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char T int etl::base</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= 10) -&gt; to_chars_result</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> len = <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a><span class="keyword">&gt;</span>(<a class="code" href="namespaceetl.html#af296e322933205aa92418d74103df68c">etl::distance</a>(first, <a class="code" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>));</div>
<div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> res = detail::integer_to_string&lt;T&gt;(<a class="code" href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">val</a>, first, <a class="code" href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">base</a>, len);</div>
<div class="line">    <span class="keywordflow">if</span> (res.error == detail::integer_to_string_error::none) {</div>
<div class="line">        <span class="keywordflow">return</span> to_chars_result{res.end, {}};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> to_chars_result{<a class="code" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, errc::value_too_large};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> constexpr <span class="keyword">auto</span> to_chars(<span class="keywordtype">char</span>*, <span class="keywordtype">char</span>*, <span class="keywordtype">bool</span>, <span class="keywordtype">int</span> = 10) -&gt; to_chars_result = <span class="keyword">delete</span></div>
<div class="ttc" id="anamespaceetl_html_a299d1930276b590319d37b6b2afa6724"><div class="ttname"><a href="namespaceetl.html#a299d1930276b590319d37b6b2afa6724">etl::base</a></div><div class="ttdeci">char T int base</div><div class="ttdef"><b>Definition:</b> to_chars.hpp:36</div></div>
<div class="ttc" id="anamespaceetl_html_a5d5911bdc109e2c7265b7486da04e8b8"><div class="ttname"><a href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">etl::last</a></div><div class="ttdeci">char const  * last</div><div class="ttdef"><b>Definition:</b> from_chars.hpp:34</div></div>
<div class="ttc" id="anamespaceetl_html_a9671046b2e5aea5a45a7f12fecc9f911"><div class="ttname"><a href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a></div><div class="ttdeci">TETL_BUILTIN_SIZET size_t</div><div class="ttdoc">etl::size_t is the unsigned integer type of the result of the sizeof operator.</div><div class="ttdef"><b>Definition:</b> size_t.hpp:14</div></div>
<div class="ttc" id="anamespaceetl_html_aa2a7c3cbcd306c97b268134f54e90d2d"><div class="ttname"><a href="namespaceetl.html#aa2a7c3cbcd306c97b268134f54e90d2d">etl::val</a></div><div class="ttdeci">char T val</div><div class="ttdef"><b>Definition:</b> to_chars.hpp:36</div></div>
<div class="ttc" id="anamespaceetl_html_af296e322933205aa92418d74103df68c"><div class="ttname"><a href="namespaceetl.html#af296e322933205aa92418d74103df68c">etl::distance</a></div><div class="ttdeci">constexpr auto distance(It first, It last) -&gt; typename iterator_traits&lt; It &gt;::difference_type</div><div class="ttdoc">Returns the number of hops from first to last.</div><div class="ttdef"><b>Definition:</b> distance.hpp:16</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bb8468ab3c13301477017cfc35f00ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb8468ab3c13301477017cfc35f00ef">&#9670;&nbsp;</a></span>requires</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires etl::requires { typename <a class="el" href="namespaceetl.html#a076e8c592e28166b1126264966624b4b">compare_three_way_result_t</a>&lt;T, U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada667f9d8a054c2bcf73335fd257dbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada667f9d8a054c2bcf73335fd257dbb8">&#9670;&nbsp;</a></span>three_way_comparable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Cat  = partial_ordering&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::three_way_comparable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    weakly_equality_comparable_with&lt;T, T&gt; &amp;&amp;</div>
<div class="line">    detail::partially_ordered_with&lt;T, T&gt; &amp;&amp;</div>
<div class="line">    <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(remove_reference_t&lt;T&gt; <span class="keyword">const</span>&amp; a, remove_reference_t&lt;T&gt; <span class="keyword">const</span>&amp; <a class="code" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) {</div>
<div class="line">        { a &lt;=&gt; <a class="code" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a> } -&gt; detail::compares_as&lt;Cat&gt;;</div>
<div class="line">    }</div>
<div class="ttc" id="anamespaceetl_html_a18b6c2ea4f13089ede1a42514f87e6c6"><div class="ttname"><a href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">etl::b</a></div><div class="ttdeci">T const  &amp; b</div><div class="ttdef"><b>Definition:</b> incrementable_traits.hpp:39</div></div>
<div class="ttc" id="anamespaceetl_html_a1bb8468ab3c13301477017cfc35f00ef"><div class="ttname"><a href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">etl::requires</a></div><div class="ttdeci">requires requires</div><div class="ttdef"><b>Definition:</b> compare_three_way_result.hpp:25</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7816eb16d1037719f611bb94eb5d0807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7816eb16d1037719f611bb94eb5d0807">&#9670;&nbsp;</a></span>assignable_from</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::assignable_from</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  etl::is_lvalue_reference_v&lt;LHS&gt; &amp;&amp;</div>
<div class="line">  <a class="code" href="namespaceetl.html#a07e107a90f5ce06cb6af9b383b8012da">etl::common_reference_with</a>&lt;</div>
<div class="line">    <a class="code" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">etl::remove_reference_t&lt;LHS&gt;</a> <span class="keyword">const</span>&amp;,</div>
<div class="line">    <a class="code" href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">etl::remove_reference_t&lt;RHS&gt;</a> <span class="keyword">const</span>&amp;&gt; &amp;&amp;</div>
<div class="line">  <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(LHS <a class="code" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, RHS&amp;&amp; rhs) {</div>
<div class="line">    { <a class="code" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a> = <a class="code" href="forward_8hpp.html#a2d576f2c39bf49da4909a2a497671e6e">TETL_FORWARD</a>(rhs) } -&gt; etl::same_as&lt;LHS&gt;;</div>
<div class="line">  }</div>
<div class="ttc" id="aforward_8hpp_html_a2d576f2c39bf49da4909a2a497671e6e"><div class="ttname"><a href="forward_8hpp.html#a2d576f2c39bf49da4909a2a497671e6e">TETL_FORWARD</a></div><div class="ttdeci">#define TETL_FORWARD(...)</div><div class="ttdef"><b>Definition:</b> forward.hpp:32</div></div>
<div class="ttc" id="anamespaceetl_html_a07e107a90f5ce06cb6af9b383b8012da"><div class="ttname"><a href="namespaceetl.html#a07e107a90f5ce06cb6af9b383b8012da">etl::common_reference_with</a></div><div class="ttdeci">concept common_reference_with</div><div class="ttdef"><b>Definition:</b> common_reference_with.hpp:14</div></div>
<div class="ttc" id="anamespaceetl_html_a90533d8a4222a3a68dfc34fcd9b9e3a1"><div class="ttname"><a href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">etl::lhs</a></div><div class="ttdeci">C &amp; lhs</div><div class="ttdef"><b>Definition:</b> stack.hpp:178</div></div>
<div class="ttc" id="anamespaceetl_html_ab812e9b378e738c7b7b7fc34f4dab9f3"><div class="ttname"><a href="namespaceetl.html#ab812e9b378e738c7b7b7fc34f4dab9f3">etl::remove_reference_t</a></div><div class="ttdeci">typename etl::remove_reference&lt; T &gt;::type remove_reference_t</div><div class="ttdef"><b>Definition:</b> remove_reference.hpp:24</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a00d34c7f7f72c76ccd274e394e0db56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d34c7f7f72c76ccd274e394e0db56e">&#9670;&nbsp;</a></span>boolean_testable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::boolean_testable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    detail::boolean_testable_impl&lt;T&gt; &amp;&amp;</div>
<div class="line">    <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(T&amp;&amp; t) {</div>
<div class="line">        { not <a class="code" href="forward_8hpp.html#a2d576f2c39bf49da4909a2a497671e6e">TETL_FORWARD</a>(t) } -&gt; detail::boolean_testable_impl;</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a07e107a90f5ce06cb6af9b383b8012da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e107a90f5ce06cb6af9b383b8012da">&#9670;&nbsp;</a></span>common_reference_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::common_reference_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        same_as&lt;common_reference_t&lt;T, U&gt;, common_reference_t&lt;U, T&gt;&gt;</div>
<div class="line">    and convertible_to&lt;T, common_reference_t&lt;T, U&gt;&gt;</div>
<div class="line">    and convertible_to&lt;U, common_reference_t&lt;T, U&gt;&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a53091ecead3b4c698545fce2f1e73625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53091ecead3b4c698545fce2f1e73625">&#9670;&nbsp;</a></span>common_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::common_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  same_as&lt;common_type_t&lt;T, U&gt;, common_type_t&lt;U, T&gt;&gt; &amp;&amp;</div>
<div class="line">  <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> {</div>
<div class="line">    <span class="keyword">static_cast&lt;</span>common_type_t&lt;T, U&gt;<span class="keyword">&gt;</span>(declval&lt;T&gt;());</div>
<div class="line">    <span class="keyword">static_cast&lt;</span>common_type_t&lt;T, U&gt;<span class="keyword">&gt;</span>(declval&lt;U&gt;());</div>
<div class="line">  } &amp;&amp;</div>
<div class="line">  <a class="code" href="namespaceetl.html#a07e107a90f5ce06cb6af9b383b8012da">common_reference_with</a>&lt;</div>
<div class="line">    add_lvalue_reference_t&lt;T const&gt;,</div>
<div class="line">    add_lvalue_reference_t&lt;U const&gt;&gt; &amp;&amp;</div>
<div class="line">  <a class="code" href="namespaceetl.html#a07e107a90f5ce06cb6af9b383b8012da">common_reference_with</a>&lt;</div>
<div class="line">    add_lvalue_reference_t&lt;common_type_t&lt;T, U&gt;&gt;,</div>
<div class="line">    <a class="code" href="namespaceetl.html#aadad4ea85004a040c0e6e70341e2d221">common_reference_t</a>&lt;</div>
<div class="line">      add_lvalue_reference_t&lt;T const&gt;,</div>
<div class="line">      add_lvalue_reference_t&lt;U const&gt;&gt;&gt;</div>
<div class="ttc" id="anamespaceetl_html_aadad4ea85004a040c0e6e70341e2d221"><div class="ttname"><a href="namespaceetl.html#aadad4ea85004a040c0e6e70341e2d221">etl::common_reference_t</a></div><div class="ttdeci">typename common_reference&lt; T... &gt;::type common_reference_t</div><div class="ttdef"><b>Definition:</b> common_reference.hpp:43</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aecaacd8370f16b3d1697b918cd279e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecaacd8370f16b3d1697b918cd279e0a">&#9670;&nbsp;</a></span>constructible_from</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::constructible_from = <a class="el" href="namespaceetl.html#aa7807b04c3fd1dcd899cbfbac85435cc">destructible</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#a1ab616d6855ca5fc60968a153587b2b4">is_constructible_v</a>&lt;T, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructible_from concept specifies that a variable of type T can be initialized with the given set of argument types Args.... </p>

</div>
</div>
<a id="ac93b0ea62659b41252c66e6152b0b4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93b0ea62659b41252c66e6152b0b4b2">&#9670;&nbsp;</a></span>convertible_to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From , typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::convertible_to = <a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">etl::is_convertible_v</a>&lt;From, To&gt; and <a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(<a class="el" href="namespaceetl.html#a1498f004a367863b7b1b4f0f8ca3f75d">etl::add_rvalue_reference_t</a>&lt;From&gt; (&amp;f)()) { static_cast&lt;To&gt;(f()); }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concept convertible_to&lt;From, To&gt; specifies that an expression of the same type and value category as those of <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval&lt;From&gt;()</a> can be implicitly and explicitly converted to the type To, and the two forms of conversion are equivalent. </p>

</div>
</div>
<a id="a5ae025789c49d242b8b45203bfbbf8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae025789c49d242b8b45203bfbbf8f4">&#9670;&nbsp;</a></span>copy_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::copy_constructible</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  move_constructible&lt;T&gt; and</div>
<div class="line">  constructible_from&lt;T, T&amp;&gt; and convertible_to&lt;T&amp;, T&gt; and</div>
<div class="line">  constructible_from&lt;T, const T&amp;&gt; and convertible_to&lt;const T&amp;, T&gt; and</div>
<div class="line">  constructible_from&lt;T, const T&gt; and convertible_to&lt;const T, T&gt;</div>
</div><!-- fragment -->
<p>The concept copy_constructible is satisfied if T is an lvalue reference type, or if it is a move_constructible object type where an object of that type can constructed from a (possibly const) lvalue or const rvalue of that type in both direct- and copy-initialization contexts with the usual semantics (a copy is constructed with the source unchanged). </p>

</div>
</div>
<a id="a6cf9593cd813280528b9bbb0c68f4f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf9593cd813280528b9bbb0c68f4f45">&#9670;&nbsp;</a></span>copyable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::copyable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=                    </div>
<div class="line">    copy_constructible&lt;T&gt; and         </div>
<div class="line">    movable&lt;T&gt; and                    </div>
<div class="line">    assignable_from&lt;T&amp;, T&amp;&gt; and       </div>
<div class="line">    assignable_from&lt;T&amp;, T const&amp;&gt; and </div>
<div class="line">    assignable_from&lt;T&amp;, T const&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="adaca15276a2469cb69859e7917e42a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaca15276a2469cb69859e7917e42a22">&#9670;&nbsp;</a></span>default_initializable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::default_initializable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  constructible_from&lt;T&gt; &amp;&amp;</div>
<div class="line">  <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> { T {}; } &amp;&amp;</div>
<div class="line">  <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> { ::new (<span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<span class="keyword">nullptr</span>)) T; }</div>
</div><!-- fragment -->
<p>The default_initializable concept checks whether variables of type T can be value-initialized (T() is well-formed); direct-list-initialized from an empty initializer list (T{} is well-formed); and default-initialized (T t; is well-formed). Access checking is performed as if in a context unrelated to T. Only the validity of the immediate context of the variable initialization is considered. </p>

</div>
</div>
<a id="a70cb104089116b2bcb2d946c5cdf0f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cb104089116b2bcb2d946c5cdf0f7d">&#9670;&nbsp;</a></span>derived_from</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::derived_from = <a class="el" href="namespaceetl.html#af00bab8d0b02bcb2974969b9d69639bb">is_base_of_v</a>&lt;Base, Derived&gt; &amp;&amp; <a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">is_convertible_v</a>&lt;Derived const volatile*, Base const volatile*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concept derived_from&lt;Derived, Base&gt; is satisfied if and only if Base is a class type that is either Derived or a public and unambiguous base of Derived, ignoring cv-qualifiers. Note that this behaviour is different to <a class="el" href="structetl_1_1is__base__of.html" title="If Derived is derived from Base or if both are the same non-union class (in both cases ignoring cv-qu...">is_base_of</a> when Base is a private or protected base of Derived. </p>

</div>
</div>
<a id="aa7807b04c3fd1dcd899cbfbac85435cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7807b04c3fd1dcd899cbfbac85435cc">&#9670;&nbsp;</a></span>destructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::destructible = <a class="el" href="namespaceetl.html#a92bb068a979f4237eb8c218d4f0112f2">etl::is_nothrow_destructible_v</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concept destructible specifies the concept of all types whose instances can safely be destroyed at the end of their lifetime (including reference types). </p>

</div>
</div>
<a id="a1afdd392b306391331437406550d4ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afdd392b306391331437406550d4ef5">&#9670;&nbsp;</a></span>equality_comparable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::equality_comparable = <a class="el" href="namespaceetl.html#ada002bf896bcbba39f049225a8d45aef">weakly_equality_comparable_with</a>&lt;T, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add53beec16093e42cbbdf40a0b38cabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add53beec16093e42cbbdf40a0b38cabf">&#9670;&nbsp;</a></span>equivalence_relation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::equivalence_relation = <a class="el" href="namespaceetl.html#a2dc9fe932ba829e5e6f72998c2afb631">relation</a>&lt;R, T, U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7db737b5a4dfad876c197c1aca7c5139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db737b5a4dfad876c197c1aca7c5139">&#9670;&nbsp;</a></span>floating_point</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::floating_point = <a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concept floating_point&lt;T&gt; is satisfied if and only if T is a floating-point type. </p>

</div>
</div>
<a id="ac4daf60f1f070c94586efbcf55d6e84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4daf60f1f070c94586efbcf55d6e84f">&#9670;&nbsp;</a></span>integral</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::integral = <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concept integral&lt;T&gt; is satisfied if and only if T is an integral type. </p>

</div>
</div>
<a id="a988da8950eef9f43c6613375c4153129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988da8950eef9f43c6613375c4153129">&#9670;&nbsp;</a></span>invocable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::invocable = <a class="el" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(F&amp;&amp; f, Args&amp;&amp;... args) { <a class="el" href="namespaceetl.html#a0bd726a99d25fb6e96ef3527de8a0164">etl::invoke</a>(<a class="el" href="forward_8hpp.html#a2d576f2c39bf49da4909a2a497671e6e">TETL_FORWARD</a>(f), <a class="el" href="forward_8hpp.html#a2d576f2c39bf49da4909a2a497671e6e">TETL_FORWARD</a>(args)...); }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f6b96f07b8ee5033e7e669fd72e5494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6b96f07b8ee5033e7e669fd72e5494">&#9670;&nbsp;</a></span>movable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::movable = <a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">is_object_v</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#a08dbf06561db5c1d6165c94862e9a232">move_constructible</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#a7816eb16d1037719f611bb94eb5d0807">assignable_from</a>&lt;T&amp;, T&gt; and <a class="el" href="namespaceetl.html#abc3d55874cfd650688465099bef5a51c">swappable</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08dbf06561db5c1d6165c94862e9a232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dbf06561db5c1d6165c94862e9a232">&#9670;&nbsp;</a></span>move_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::move_constructible = <a class="el" href="namespaceetl.html#aecaacd8370f16b3d1697b918cd279e0a">constructible_from</a>&lt;T, T&gt; &amp;&amp; <a class="el" href="namespaceetl.html#ac93b0ea62659b41252c66e6152b0b4b2">convertible_to</a>&lt;T, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concept move_constructible is satisfied if T is a reference type, or if it is an object type where an object of that type can be constructed from an rvalue of that type in both direct- and copy-initialization contexts, with the usual semantics. </p>
<p><a href="https://en.cppreference.com/w/cpp/concepts/move_constructible">https://en.cppreference.com/w/cpp/concepts/move_constructible</a> </p>

</div>
</div>
<a id="a3cf1991d2ce684016a8e3a756021fa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf1991d2ce684016a8e3a756021fa38">&#9670;&nbsp;</a></span>predicate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::predicate = <a class="el" href="namespaceetl.html#a4870b0eff355f370c20bccb8a28cebe8">regular_invocable</a>&lt;F, Args...&gt; and <a class="el" href="namespaceetl.html#a00d34c7f7f72c76ccd274e394e0db56e">boolean_testable</a>&lt;<a class="el" href="namespaceetl.html#a93ed3feabd9624cf09aa604f49155cc2">invoke_result_t</a>&lt;F, Args...&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2abefe210f09c67ad5c66f7492b1a98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abefe210f09c67ad5c66f7492b1a98e">&#9670;&nbsp;</a></span>regular</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::regular = <a class="el" href="namespaceetl.html#a2fd176827c6247549c03a4dd19731a01">etl::semiregular</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#a1afdd392b306391331437406550d4ef5">etl::equality_comparable</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4870b0eff355f370c20bccb8a28cebe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4870b0eff355f370c20bccb8a28cebe8">&#9670;&nbsp;</a></span>regular_invocable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::regular_invocable = <a class="el" href="namespaceetl.html#a988da8950eef9f43c6613375c4153129">etl::invocable</a>&lt;F, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dc9fe932ba829e5e6f72998c2afb631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc9fe932ba829e5e6f72998c2afb631">&#9670;&nbsp;</a></span>relation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::relation = <a class="el" href="namespaceetl.html#a3cf1991d2ce684016a8e3a756021fa38">predicate</a>&lt;R, T, T&gt; and <a class="el" href="namespaceetl.html#a3cf1991d2ce684016a8e3a756021fa38">predicate</a>&lt;R, U, U&gt; and <a class="el" href="namespaceetl.html#a3cf1991d2ce684016a8e3a756021fa38">predicate</a>&lt;R, T, U&gt; and <a class="el" href="namespaceetl.html#a3cf1991d2ce684016a8e3a756021fa38">predicate</a>&lt;R, U, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa602e717add57122f28f5186a8399a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa602e717add57122f28f5186a8399a87">&#9670;&nbsp;</a></span>same_as</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::same_as = detail::same_helper&lt;T, U&gt; and detail::same_helper&lt;U, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concept same_as&lt;T, U&gt; is satisfied if and only if T and U denote the same type. same_as&lt;T, U&gt; subsumes same_as&lt;U, T&gt; and vice versa. </p>

</div>
</div>
<a id="a2fd176827c6247549c03a4dd19731a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd176827c6247549c03a4dd19731a01">&#9670;&nbsp;</a></span>semiregular</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::semiregular = <a class="el" href="namespaceetl.html#a6cf9593cd813280528b9bbb0c68f4f45">etl::copyable</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#adaca15276a2469cb69859e7917e42a22">etl::default_initializable</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4eadc31af2a7472602cfc3929a0914f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eadc31af2a7472602cfc3929a0914f0">&#9670;&nbsp;</a></span>signed_integral</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::signed_integral = <a class="el" href="namespaceetl.html#ac4daf60f1f070c94586efbcf55d6e84f">etl::integral</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#aff3fadd2a1e349c45f524ab5444220ff">etl::is_signed_v</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concept signed_integral&lt;T&gt; is satisfied if and only if T is an integral type and is_signed_v&lt;T&gt; is true. </p>

</div>
</div>
<a id="ac6f3b6a3010a0611d77648f91f3ccdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f3b6a3010a0611d77648f91f3ccdf7">&#9670;&nbsp;</a></span>standard_integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::standard_integer = <a class="el" href="namespaceetl.html#ad52ae3e71a7e5954830504af2048ed7d">is_standard_integer_v</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadad383df2f67b95302958dd5c9322c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadad383df2f67b95302958dd5c9322c7">&#9670;&nbsp;</a></span>standard_signed_integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::standard_signed_integer = <a class="el" href="namespaceetl.html#ab19a5f05a129870f874303571c11da48">is_standard_signed_integer_v</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdf98855f87500a0c8e475a82dc1cabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf98855f87500a0c8e475a82dc1cabe">&#9670;&nbsp;</a></span>standard_unsigned_integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::standard_unsigned_integer = <a class="el" href="namespaceetl.html#a4881471dda8be900e4d183c9a413f66c">is_standard_unsigned_integer_v</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af29d579cd21c6e393409132a0019316b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29d579cd21c6e393409132a0019316b">&#9670;&nbsp;</a></span>strict_weak_order</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::strict_weak_order = <a class="el" href="namespaceetl.html#a2dc9fe932ba829e5e6f72998c2afb631">relation</a>&lt;R, T, U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc3d55874cfd650688465099bef5a51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3d55874cfd650688465099bef5a51c">&#9670;&nbsp;</a></span>swappable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::swappable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(T&amp; a, T&amp; <a class="code" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) {</div>
<div class="line">    <a class="code" href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5">swap</a>(a, <a class="code" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>);</div>
<div class="line">    </div>
<div class="line">}</div>
<div class="ttc" id="anamespaceetl_html_ad707bbff2e759a5d868a7bfb7d6bc4c5"><div class="ttname"><a href="namespaceetl.html#ad707bbff2e759a5d868a7bfb7d6bc4c5">etl::swap</a></div><div class="ttdeci">constexpr auto swap(array&lt; T, N &gt; &amp;lhs, array&lt; T, N &gt; &amp;rhs) noexcept(noexcept(lhs.swap(rhs))) -&gt; void</div><div class="ttdoc">Specializes the swap algorithm for array. Swaps the contents of lhs and rhs.</div><div class="ttdef"><b>Definition:</b> array.hpp:206</div></div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Convert to ranges::swap once available </dd></dl>

</div>
</div>
<a id="a41dae8aa2c733dd84d9b8f15d79528bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dae8aa2c733dd84d9b8f15d79528bb">&#9670;&nbsp;</a></span>unsigned_integral</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::unsigned_integral = <a class="el" href="namespaceetl.html#ac4daf60f1f070c94586efbcf55d6e84f">etl::integral</a>&lt;T&gt; &amp;&amp; <a class="el" href="namespaceetl.html#a3bbd05dc09b68b19c63d7b4fbf6f1108">etl::is_unsigned_v</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concept unsigned_integral&lt;T&gt; is satisfied if and only if T is an integral type and is_unsigned_v&lt;T&gt; is true. </p>

</div>
</div>
<a id="ada002bf896bcbba39f049225a8d45aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada002bf896bcbba39f049225a8d45aef">&#9670;&nbsp;</a></span>weakly_equality_comparable_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::weakly_equality_comparable_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(remove_reference_t&lt;T&gt; <span class="keyword">const</span>&amp; t, remove_reference_t&lt;U&gt; <span class="keyword">const</span>&amp; u) {</div>
<div class="line">    { t == u } -&gt; <a class="code" href="namespaceetl.html#a00d34c7f7f72c76ccd274e394e0db56e">boolean_testable</a>;</div>
<div class="line">    { t != u } -&gt; <a class="code" href="namespaceetl.html#a00d34c7f7f72c76ccd274e394e0db56e">boolean_testable</a>;</div>
<div class="line">    { u == t } -&gt; <a class="code" href="namespaceetl.html#a00d34c7f7f72c76ccd274e394e0db56e">boolean_testable</a>;</div>
<div class="line">    { u != t } -&gt; <a class="code" href="namespaceetl.html#a00d34c7f7f72c76ccd274e394e0db56e">boolean_testable</a>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceetl_html_a00d34c7f7f72c76ccd274e394e0db56e"><div class="ttname"><a href="namespaceetl.html#a00d34c7f7f72c76ccd274e394e0db56e">etl::boolean_testable</a></div><div class="ttdeci">concept boolean_testable</div><div class="ttdef"><b>Definition:</b> boolean_testable.hpp:18</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d957fa8529e9617c445e42519518e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d957fa8529e9617c445e42519518e5e">&#9670;&nbsp;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="attributes_8hpp.html#a6cf990edeb7f9f6f1b5928471cef5e56">TETL_MAY_ALIAS</a> etl::byte</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a> is a distinct type that implements the concept of byte as specified in the C++ language definition. </p>
<p>Like char and unsigned char, it can be used to access raw memory occupied by other objects, but unlike those types, it is not a character type and is not an arithmetic type. A byte is only a collection of bits, and the only operators defined for it are the bitwise ones.</p>
<p><a href="https://en.cppreference.com/w/cpp/types/byte">https://en.cppreference.com/w/cpp/types/byte</a> </p>

</div>
</div>
<a id="a2932a67109d86a3d3414866785f19613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2932a67109d86a3d3414866785f19613">&#9670;&nbsp;</a></span>unexpect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unexpect = <a class="el" href="structetl_1_1unexpect__t.html">unexpect_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3206db2ddd4b49017ef0d257ca69a515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3206db2ddd4b49017ef0d257ca69a515">&#9670;&nbsp;</a></span>sorted_unique</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sorted_unique = <a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5ecf4e1b001cdba463b17849f4b55e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ecf4e1b001cdba463b17849f4b55e4">&#9670;&nbsp;</a></span>is_placeholder_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int etl::is_placeholder_v = <a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a212bf7be37c4b9bdf1328f042486b384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212bf7be37c4b9bdf1328f042486b384">&#9670;&nbsp;</a></span>incrementable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::incrementable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= etl::regular&lt;T&gt; and etl::weakly_incrementable&lt;T&gt; and <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(T i) {</div>
<div class="line">    { i++ } -&gt; etl::same_as&lt;T&gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a18b6c2ea4f13089ede1a42514f87e6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b6c2ea4f13089ede1a42514f87e6c6">&#9670;&nbsp;</a></span>b</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T(&amp; etl::b</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        { <a class="code" href="namespaceetl_1_1experimental_1_1hardware_1_1mcp23017.html#ae2dfdafbcff106ed4635ae08dbb1ffaba0cc175b9c0f1b6a831c399e269772661">a</a> - <a class="code" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a> } -&gt; <a class="code" href="namespaceetl.html#ac4daf60f1f070c94586efbcf55d6e84f">etl::integral</a></div>
<div class="ttc" id="anamespaceetl_1_1experimental_1_1hardware_1_1mcp23017_html_ae2dfdafbcff106ed4635ae08dbb1ffaba0cc175b9c0f1b6a831c399e269772661"><div class="ttname"><a href="namespaceetl_1_1experimental_1_1hardware_1_1mcp23017.html#ae2dfdafbcff106ed4635ae08dbb1ffaba0cc175b9c0f1b6a831c399e269772661">etl::experimental::hardware::mcp23017::port::a</a></div><div class="ttdeci">@ a</div></div>
<div class="ttc" id="anamespaceetl_html_ac4daf60f1f070c94586efbcf55d6e84f"><div class="ttname"><a href="namespaceetl.html#ac4daf60f1f070c94586efbcf55d6e84f">etl::integral</a></div><div class="ttdeci">concept integral</div><div class="ttdoc">The concept integral&lt;T&gt; is satisfied if and only if T is an integral type.</div><div class="ttdef"><b>Definition:</b> integral.hpp:13</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c276f2e1f0ad19e9311b62769978acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c276f2e1f0ad19e9311b62769978acc">&#9670;&nbsp;</a></span>input_or_output_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::input_or_output_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= weakly_incrementable&lt;Iter&gt; and <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(Iter it) {</div>
<div class="line">    { *it } -&gt; detail::can_reference;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9960486cb35efd439dc700529983a6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9960486cb35efd439dc700529983a6d3">&#9670;&nbsp;</a></span>sentinel_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::sentinel_for = <a class="el" href="namespaceetl.html#a2fd176827c6247549c03a4dd19731a01">semiregular</a>&lt;S&gt; and <a class="el" href="namespaceetl.html#a9c276f2e1f0ad19e9311b62769978acc">input_or_output_iterator</a>&lt;Iter&gt; and <a class="el" href="namespaceetl.html#ada002bf896bcbba39f049225a8d45aef">weakly_equality_comparable_with</a>&lt;S, Iter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acadd2b30864294d4537931e8d9835b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acadd2b30864294d4537931e8d9835b94">&#9670;&nbsp;</a></span>weakly_incrementable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::weakly_incrementable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= etl::movable&lt;Iter&gt; and <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a>(Iter i) {</div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="namespaceetl.html#a91a7197a7953a7c1e620701f90bec2cc">etl::iter_difference_t&lt;Iter&gt;</a>;</div>
<div class="line">    <a class="code" href="namespaceetl.html#a1bb8468ab3c13301477017cfc35f00ef">requires</a> etl::signed_integral&lt;etl::iter_difference_t&lt;Iter&gt;&gt;;</div>
<div class="line">    { ++i } -&gt; etl::same_as&lt;Iter&amp;&gt;;</div>
<div class="line">    i++;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceetl_html_a91a7197a7953a7c1e620701f90bec2cc"><div class="ttname"><a href="namespaceetl.html#a91a7197a7953a7c1e620701f90bec2cc">etl::iter_difference_t</a></div><div class="ttdeci">typename detail::iter_difference&lt; T &gt;::type iter_difference_t</div><div class="ttdef"><b>Definition:</b> iter_difference_t.hpp:29</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a751416861268d9328aa2a7263fd85e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751416861268d9328aa2a7263fd85e1b">&#9670;&nbsp;</a></span>full_extent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::full_extent = <a class="el" href="structetl_1_1full__extent__t.html">full_extent_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ceb01bf8ef98fb9e5817d452798b6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ceb01bf8ef98fb9e5817d452798b6c1">&#9670;&nbsp;</a></span>mdspan&lt; ElementType, dextents&lt; size_t, sizeof...(Integrals)&gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Integrals <a class="el" href="structetl_1_1mdspan.html">etl::mdspan</a>&lt; ElementType, <a class="el" href="namespaceetl.html#a314896b8468bbdbea59f862f4c5e8aef">dextents</a>&lt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>, sizeof...(Integrals)&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74fea0e76b0257b8f9ffbca0b6de6aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fea0e76b0257b8f9ffbca0b6de6aaa">&#9670;&nbsp;</a></span>allocator_arg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a> etl::allocator_arg {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocator_arg is a constant of type <a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects. </p>

</div>
</div>
<a id="a16cf19d8af06969d839fa909ad6e184f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cf19d8af06969d839fa909ad6e184f">&#9670;&nbsp;</a></span>uses_allocator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::uses_allocator_v = <a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a>&lt;Type, Alloc&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false. </p>

</div>
</div>
<a id="a3e9e177fde5dc55ea58bb3771c37051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9e177fde5dc55ea58bb3771c37051a">&#9670;&nbsp;</a></span>defer_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1defer__lock__t.html">defer_lock_t</a> etl::defer_lock {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instances of empty struct tag types. See <a class="el" href="structetl_1_1defer__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">defer_lock_t</a>. </p>

</div>
</div>
<a id="a086e79db17e8b72ae86d834fad514b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086e79db17e8b72ae86d834fad514b2e">&#9670;&nbsp;</a></span>try_to_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1try__to__lock__t.html">try_to_lock_t</a> etl::try_to_lock {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instances of empty struct tag types. See <a class="el" href="structetl_1_1try__to__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">try_to_lock_t</a>. </p>

</div>
</div>
<a id="a03ee00292ff760cd8ecf8b41bb4de696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ee00292ff760cd8ecf8b41bb4de696">&#9670;&nbsp;</a></span>adopt_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1adopt__lock__t.html">adopt_lock_t</a> etl::adopt_lock {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instances of empty struct tag types. See <a class="el" href="structetl_1_1adopt__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">adopt_lock_t</a>. </p>

</div>
</div>
<a id="ac7234bd8fd6d2e05055093f7a4bb53d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7234bd8fd6d2e05055093f7a4bb53d7">&#9670;&nbsp;</a></span>destroying_delete</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::destroying_delete = <a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag type used to identify the destroying delete form of operator delete. </p>

</div>
</div>
<a id="a20ecb067c83bfce58af4f03457f15c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ecb067c83bfce58af4f03457f15c8c">&#9670;&nbsp;</a></span>hardware_constructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::hardware_constructive_interference_size = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum offset between two objects to avoid false sharing. Guaranteed to be at least alignof(max_align_t). </p>

</div>
</div>
<a id="abc217ae19afd481b0993696cbb1729bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc217ae19afd481b0993696cbb1729bf">&#9670;&nbsp;</a></span>hardware_destructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::hardware_destructive_interference_size = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size of contiguous memory to promote true sharing. Guaranteed to be at least alignof(max_align_t). </p>

</div>
</div>
<a id="a8a1ead4c5ac981fe88bcd71d1aba1d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1ead4c5ac981fe88bcd71d1aba1d61">&#9670;&nbsp;</a></span>nothrow</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nothrow = <a class="el" href="structetl_1_1nothrow__t.html">etl::nothrow_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#a8a1ead4c5ac981fe88bcd71d1aba1d61" title="etl::nothrow is a constant of type etl::nothrow_t used to disambiguate the overloads of throwing and ...">etl::nothrow</a> is a constant of type <a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> used to disambiguate the overloads of throwing and non-throwing allocation functions. </p>

</div>
</div>
<a id="a7ab7a2b5df589ee0db680c5833896d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab7a2b5df589ee0db680c5833896d8e">&#9670;&nbsp;</a></span>common_type_t&lt; M, N &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">N n <a class="el" href="namespaceetl.html#aa474dd82a788a57735f0603b85954c37">etl::common_type_t</a>&lt; M, N &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (m * n) / <a class="code" href="__3rd__party_2gcem_2gcem__incl_2gcd_8hpp.html#a1f38f3f4d07b75ad3402b02eabaf0306">gcd</a>(m, n)</div>
<div class="ttc" id="a__3rd__party_2gcem_2gcem__incl_2gcd_8hpp_html_a1f38f3f4d07b75ad3402b02eabaf0306"><div class="ttname"><a href="__3rd__party_2gcem_2gcem__incl_2gcd_8hpp.html#a1f38f3f4d07b75ad3402b02eabaf0306">gcd</a></div><div class="ttdeci">constexpr auto gcd(const T1 a, const T2 b) noexcept -&gt; common_t&lt; T1, T2 &gt;</div><div class="ttdef"><b>Definition:</b> gcd.hpp:62</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af4f837bf0258547b23e4f04e4d03e6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f837bf0258547b23e4f04e4d03e6d1">&#9670;&nbsp;</a></span>Int</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a> <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> etl::Int</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keyword">using</span> UInt = <a class="code" href="namespaceetl.html#acb2df53f4e399975501cf8300d451814">etl::make_unsigned_t&lt;Int&gt;</a></div>
<div class="ttc" id="anamespaceetl_html_acb2df53f4e399975501cf8300d451814"><div class="ttname"><a href="namespaceetl.html#acb2df53f4e399975501cf8300d451814">etl::make_unsigned_t</a></div><div class="ttdeci">typename make_unsigned&lt; T &gt;::type make_unsigned_t</div><div class="ttdef"><b>Definition:</b> make_unsigned.hpp:75</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3acb4483c815a6504bcca76ca33d7d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acb4483c815a6504bcca76ca33d7d0f">&#9670;&nbsp;</a></span>shift</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto const etl::shift = static_cast&lt;UInt&gt;(<a class="el" href="structetl_1_1numeric__limits.html">etl::numeric_limits</a>&lt;UInt&gt;::digits - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5310f602316cea39c9b7d3b6101a47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5310f602316cea39c9b7d3b6101a47d">&#9670;&nbsp;</a></span>diff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto const etl::diff = static_cast&lt;UInt&gt;(UInt(<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) - UInt(a))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e2e8cf3fb3b9b4fe2e13ae866510ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2e8cf3fb3b9b4fe2e13ae866510ced">&#9670;&nbsp;</a></span>sign</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto const etl::sign = static_cast&lt;UInt&gt;(<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a> &lt; a)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5a2fbfa8f64e7bebc363cd78c4d6660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a2fbfa8f64e7bebc363cd78c4d6660">&#9670;&nbsp;</a></span>half</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto const <a class="el" href="structetl_1_1half.html">etl::half</a> = static_cast&lt;UInt&gt;((<a class="el" href="namespaceetl.html#ab5310f602316cea39c9b7d3b6101a47d">diff</a> / 2) + (<a class="el" href="namespaceetl.html#a2e2e8cf3fb3b9b4fe2e13ae866510ced">sign</a> &lt;&lt; <a class="el" href="namespaceetl.html#a3acb4483c815a6504bcca76ca33d7d0f">shift</a>) + (<a class="el" href="namespaceetl.html#a2e2e8cf3fb3b9b4fe2e13ae866510ced">sign</a> &amp; <a class="el" href="namespaceetl.html#ab5310f602316cea39c9b7d3b6101a47d">diff</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93d7a7601aedf2ce125a34a9d83b80a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d7a7601aedf2ce125a34a9d83b80a7">&#9670;&nbsp;</a></span>nullopt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nullopt = <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>{{}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#a93d7a7601aedf2ce125a34a9d83b80a7" title="etl::nullopt is a constant of type etl::nullopt_t that is used to indicate optional type with uniniti...">etl::nullopt</a> is a constant of type <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">etl::nullopt_t</a> that is used to indicate optional type with uninitialized state. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="optional_8cpp-example.html#a0">optional.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a717a065b4d593697dc186ca84f51ffb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717a065b4d593697dc186ca84f51ffb8">&#9670;&nbsp;</a></span>ratio_equal_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_equal_v = <a class="el" href="structetl_1_1ratio__equal.html">ratio_equal</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abce653ddb9ec91f96bda7e292725dc0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce653ddb9ec91f96bda7e292725dc0e">&#9670;&nbsp;</a></span>ratio_greater_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_greater_v = <a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ed208c9b18aabc1288d0721225be488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed208c9b18aabc1288d0721225be488">&#9670;&nbsp;</a></span>ratio_greater_equal_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_greater_equal_v = <a class="el" href="structetl_1_1ratio__greater__equal.html">ratio_greater_equal</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8d7dd3cfa6494a27aaf40f11ec60b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d7dd3cfa6494a27aaf40f11ec60b62">&#9670;&nbsp;</a></span>ratio_less_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_less_v = <a class="el" href="structetl_1_1ratio__less.html">ratio_less</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31e01f9b1a6c95f6f7b793bdfb54755d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e01f9b1a6c95f6f7b793bdfb54755d">&#9670;&nbsp;</a></span>ratio_less_equal_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_less_equal_v = <a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf88cdc68bd2c8d7aa353d030c3c1e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf88cdc68bd2c8d7aa353d030c3c1e6c">&#9670;&nbsp;</a></span>ratio_not_equal_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_not_equal_v = <a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a>&lt;R1, R2&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92b2aa1aec32660fd5004c4847957f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b2aa1aec32660fd5004c4847957f20">&#9670;&nbsp;</a></span>element_aligned</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1element__aligned__tag.html">element_aligned_tag</a> etl::element_aligned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae57e9c30285b23943d7021abf09160e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57e9c30285b23943d7021abf09160e1">&#9670;&nbsp;</a></span>vector_aligned</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1vector__aligned__tag.html">vector_aligned_tag</a> etl::vector_aligned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9312dc46a8d75ebd1d2ac9315c09bf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9312dc46a8d75ebd1d2ac9315c09bf57">&#9670;&nbsp;</a></span>overaligned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1overaligned__tag.html">overaligned_tag</a>&lt;N&gt; etl::overaligned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae174223df490e6263d4648a86326c902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae174223df490e6263d4648a86326c902">&#9670;&nbsp;</a></span>dynamic_extent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::dynamic_extent = <a class="el" href="structetl_1_1numeric__limits.html">numeric_limits</a>&lt;<a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&gt;::<a class="el" href="namespaceetl.html#a7fdd0cf88f36f44f8fe8ec8327cfac74">max</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#ae174223df490e6263d4648a86326c902" title="etl::dynamic_extent is a constant of type etl::size_t that is used to differentiate etl::span of stat...">etl::dynamic_extent</a> is a constant of type <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> that is used to differentiate <a class="el" href="structetl_1_1span.html" title="A non-owning view over a contiguous sequence of objects.">etl::span</a> of static and dynamic extent. </p>

</div>
</div>
<a id="a90533d8a4222a3a68dfc34fcd9b9e3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90533d8a4222a3a68dfc34fcd9b9e3a1">&#9670;&nbsp;</a></span>lhs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">C&amp; etl::lhs</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="vector_8cpp-example.html#a2">vector.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad8a0374b0fe975ab01bcc129d60f5d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a0374b0fe975ab01bcc129d60f5d03">&#9670;&nbsp;</a></span>ignore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr struct <a class="el" href="structetl_1_1ignore.html">etl::ignore</a> <a class="el" href="structetl_1_1ignore.html">etl::ignore</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3e2b2e600cad8b86cd15cb73d7f0a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e2b2e600cad8b86cd15cb73d7f0a4c">&#9670;&nbsp;</a></span>is_tuple_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_tuple_like&lt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt; Ts... &gt; &gt; = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a020b53dca62b51c6ff63f22a1c81fabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020b53dca62b51c6ff63f22a1c81fabd">&#9670;&nbsp;</a></span>pair_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::pair_like = <a class="el" href="namespaceetl.html#af600cc0169aa4ca5e5d09668d34feecd">etl::tuple_like</a>&lt;T&gt; and <a class="el" href="namespaceetl.html#a93d0a5fb70cb82c336299812b04498f8">etl::tuple_size_v</a>&lt;<a class="el" href="namespaceetl.html#ac0c34af472196537fb719bde6ab1c4ad">etl::remove_cvref_t</a>&lt;T&gt;&gt; == 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af600cc0169aa4ca5e5d09668d34feecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af600cc0169aa4ca5e5d09668d34feecd">&#9670;&nbsp;</a></span>tuple_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept etl::tuple_like = <a class="el" href="namespaceetl.html#ac3e2b2e600cad8b86cd15cb73d7f0a4c">etl::is_tuple_like</a>&lt;<a class="el" href="namespaceetl.html#ac0c34af472196537fb719bde6ab1c4ad">etl::remove_cvref_t</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93d0a5fb70cb82c336299812b04498f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d0a5fb70cb82c336299812b04498f8">&#9670;&nbsp;</a></span>tuple_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::tuple_size_v = <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a76e66c3ede7a3c2d993850cd16d1b4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e66c3ede7a3c2d993850cd16d1b4e3">&#9670;&nbsp;</a></span>alignment_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a> etl::alignment_of_v = <a class="el" href="structetl_1_1alignment__of.html">etl::alignment_of</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a815380448fc90ab014b40a47938372f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815380448fc90ab014b40a47938372f9">&#9670;&nbsp;</a></span>always_false</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::always_false = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0d9f32a20bf813fd8ce025d0aebbff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d9f32a20bf813fd8ce025d0aebbff5">&#9670;&nbsp;</a></span>conjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::conjunction_v = (B::value &amp;&amp; ...)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29f460d9cd9dc39f08fc926828d8b442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f460d9cd9dc39f08fc926828d8b442">&#9670;&nbsp;</a></span>disjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::disjunction_v = (B::value || ...)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a115f1cea7fc27ee979afae4871d03a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115f1cea7fc27ee979afae4871d03a03">&#9670;&nbsp;</a></span>extent_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::extent_v = static_cast&lt;<a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>&gt;(<a class="el" href="structetl_1_1extent.html">extent</a>&lt;T, N&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66a60e01980cd945b387ffc47f44eccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a60e01980cd945b387ffc47f44eccf">&#9670;&nbsp;</a></span>has_unique_object_representations_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::has_unique_object_representations_v = <a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46f3f4c2468d1d1f33a449bf167efbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f3f4c2468d1d1f33a449bf167efbbc">&#9670;&nbsp;</a></span>has_virtual_destructor_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::has_virtual_destructor_v = __has_virtual_destructor(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a> </p>

</div>
</div>
<a id="af27862efe6b9f1ba007a712b5e2a6e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27862efe6b9f1ba007a712b5e2a6e8a">&#9670;&nbsp;</a></span>index_c</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::index_c = <a class="el" href="namespaceetl.html#adee9f2213a709e3392d4d998d2a406f2">etl::index_constant</a>&lt;I&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad586ed3dee38cd4cc1b409e607230ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad586ed3dee38cd4cc1b409e607230ffb">&#9670;&nbsp;</a></span>is_abstract_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_abstract_v = __is_abstract(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afacace2162b09f525f4baff15548ecda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacace2162b09f525f4baff15548ecda">&#9670;&nbsp;</a></span>is_aggregate_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_aggregate_v = __is_aggregate(<a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">remove_cv_t</a>&lt;T&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0de9ab0c91e46602a77993e77ec8a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0de9ab0c91e46602a77993e77ec8a6d">&#9670;&nbsp;</a></span>is_any_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_any_of_v = <a class="el" href="namespaceetl.html#a29f460d9cd9dc39f08fc926828d8b442">disjunction_v</a>&lt;<a class="el" href="structetl_1_1is__same.html">is_same</a>&lt;T, Types&gt;...&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a105e2a5ac8fc634dcc71675e27e3f95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105e2a5ac8fc634dcc71675e27e3f95e">&#9670;&nbsp;</a></span>is_arithmetic_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_arithmetic_v = <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;T&gt; or <a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">etl::is_floating_point_v</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afaa46050181985a6156a6c800c86a7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa46050181985a6156a6c800c86a7d8">&#9670;&nbsp;</a></span>is_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_array_v = <a class="el" href="structetl_1_1is__array.html">etl::is_array</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae630f4cbcf30c3c7912d50547711e86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae630f4cbcf30c3c7912d50547711e86d">&#9670;&nbsp;</a></span>is_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_assignable_v = __is_assignable(T, U)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af00bab8d0b02bcb2974969b9d69639bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00bab8d0b02bcb2974969b9d69639bb">&#9670;&nbsp;</a></span>is_base_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base , typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_base_of_v = <a class="el" href="structetl_1_1is__base__of.html">is_base_of</a>&lt;Base, Derived&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6d2eef20a4d7f2fcfb333c7e5c23444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d2eef20a4d7f2fcfb333c7e5c23444">&#9670;&nbsp;</a></span>is_bounded_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_bounded_array_v = <a class="el" href="structetl_1_1is__bounded__array.html">etl::is_bounded_array</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8d441fab48eb459b77f6f5829f7fc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d441fab48eb459b77f6f5829f7fc75">&#9670;&nbsp;</a></span>is_class_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_class_v = __is_class(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab45e49677aea4d7ed533e7c73ea7f2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45e49677aea4d7ed533e7c73ea7f2b6">&#9670;&nbsp;</a></span>is_compound_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_compound_v = !<a class="el" href="namespaceetl.html#af6b1115f04c131e47ab31a50aa2194b2">etl::is_fundamental_v</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40862de0c689f5281b8d680741bc7cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40862de0c689f5281b8d680741bc7cf9">&#9670;&nbsp;</a></span>is_const_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_const_v = <a class="el" href="structetl_1_1is__const.html">etl::is_const</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a4">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1ab616d6855ca5fc60968a153587b2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab616d6855ca5fc60968a153587b2b4">&#9670;&nbsp;</a></span>is_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_constructible_v = <a class="el" href="namespaceetl.html#a9c3c8b104138758267e7fc29e7aa2828">is_constructible</a>&lt;T, Args...&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa15279e84c7ec40ef8a2d460b81b7fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15279e84c7ec40ef8a2d460b81b7fb7">&#9670;&nbsp;</a></span>is_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From , typename To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_convertible_v = <a class="el" href="structetl_1_1is__convertible.html">is_convertible</a>&lt;From, To&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17e13a2d8cce95954bee3d62ec059851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e13a2d8cce95954bee3d62ec059851">&#9670;&nbsp;</a></span>is_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_copy_assignable_v = <a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a045ef39158833b2ba6592fa8a1d0ebc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045ef39158833b2ba6592fa8a1d0ebc1">&#9670;&nbsp;</a></span>is_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_copy_constructible_v = <a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0093a625b8acbeac1878b9a9668a2563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0093a625b8acbeac1878b9a9668a2563">&#9670;&nbsp;</a></span>is_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_default_constructible_v = <a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34ff2b6f5e9a98730031297120e28af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ff2b6f5e9a98730031297120e28af4">&#9670;&nbsp;</a></span>is_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_destructible_v = <a class="el" href="structetl_1_1is__destructible.html">is_destructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a258143fbbaaef57434ff042f35db08a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258143fbbaaef57434ff042f35db08a6">&#9670;&nbsp;</a></span>is_empty_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_empty_v = <a class="el" href="structetl_1_1is__empty.html">is_empty</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4784b73e6d758a37358b62211a308ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4784b73e6d758a37358b62211a308ef">&#9670;&nbsp;</a></span>is_enum_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_enum_v = __is_enum(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b8c484a0ff37fdfc1fc2c47b092ade2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8c484a0ff37fdfc1fc2c47b092ade2">&#9670;&nbsp;</a></span>is_final_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_final_v = __is_final(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cf273d19443134cffcd66310d027ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf273d19443134cffcd66310d027ae4">&#9670;&nbsp;</a></span>is_floating_point_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_floating_point_v = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec3b44fa05f956c1efc4f34af98bd1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3b44fa05f956c1efc4f34af98bd1f0">&#9670;&nbsp;</a></span>is_function_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_function_v = <a class="el" href="structetl_1_1is__function.html">is_function</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether T is a function type. Types like etl::function, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false. </p>
<p>The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__function.html">is_function</a> or is_function_v is undefined. </p>

</div>
</div>
<a id="af6b1115f04c131e47ab31a50aa2194b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b1115f04c131e47ab31a50aa2194b2">&#9670;&nbsp;</a></span>is_fundamental_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_fundamental_v = <a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a750d61c5b9f6964af8d9465794b92953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750d61c5b9f6964af8d9465794b92953">&#9670;&nbsp;</a></span>is_implicit_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_implicit_default_constructible_v = <a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ef2a50a29c8803d461abedd7437effd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef2a50a29c8803d461abedd7437effd">&#9670;&nbsp;</a></span>is_integral_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_integral_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= is_any_of_v&lt;remove_cv_t&lt;T&gt;,</div>
<div class="line">        bool,</div>
<div class="line">        char,</div>
<div class="line">        <span class="keywordtype">signed</span> char,</div>
<div class="line">        <span class="keywordtype">unsigned</span> char,</div>
<div class="line">        wchar_t,</div>
<div class="line">        char8_t,</div>
<div class="line">        char16_t,</div>
<div class="line">        char32_t,</div>
<div class="line">        short,</div>
<div class="line">        <span class="keywordtype">unsigned</span> short,</div>
<div class="line">        int,</div>
<div class="line">        <span class="keywordtype">unsigned</span> int,</div>
<div class="line">        long,</div>
<div class="line">        <span class="keywordtype">unsigned</span> long,</div>
<div class="line">        <span class="keywordtype">long</span> long,</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span></div>
<div class="line">    &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="abcda8292d5b910aed63532a701d39e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcda8292d5b910aed63532a701d39e87">&#9670;&nbsp;</a></span>is_invocable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename... ArgTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_invocable_v = <a class="el" href="structetl_1_1is__invocable.html">is_invocable</a>&lt;Fn, ArgTypes...&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8a1ef24a3b6eb7a38ad1307015c2c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a1ef24a3b6eb7a38ad1307015c2c09">&#9670;&nbsp;</a></span>is_invocable_r_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename Fn , typename... ArgTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_invocable_r_v = <a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a>&lt;R, Fn, ArgTypes...&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abdf67506d7e83cba3f386c212a824e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf67506d7e83cba3f386c212a824e9c">&#9670;&nbsp;</a></span>is_lvalue_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_lvalue_reference_v = <a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a690a598d20472c340a3e6969d5fe58af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690a598d20472c340a3e6969d5fe58af">&#9670;&nbsp;</a></span>is_member_function_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_member_function_pointer_v = <a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05fe5ff6b0b6727ff7c98a53e5eb1c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fe5ff6b0b6727ff7c98a53e5eb1c80">&#9670;&nbsp;</a></span>is_member_object_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_member_object_pointer_v = <a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbaaa5057d498812ee848f491a20649a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbaaa5057d498812ee848f491a20649a">&#9670;&nbsp;</a></span>is_member_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_member_pointer_v = <a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad208b3b6c99d59cdc5d698310e59143e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad208b3b6c99d59cdc5d698310e59143e">&#9670;&nbsp;</a></span>is_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_move_assignable_v = <a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82b776d5da5e25514489bfd330d7940d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b776d5da5e25514489bfd330d7940d">&#9670;&nbsp;</a></span>is_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_move_constructible_v = <a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a865b2c54ee24d227ee6f222e49fd076c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865b2c54ee24d227ee6f222e49fd076c">&#9670;&nbsp;</a></span>is_nothrow_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_assignable_v = <a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a>&lt;T, U&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ff5fc00d3b16aa2421ea49dae4e864e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff5fc00d3b16aa2421ea49dae4e864e">&#9670;&nbsp;</a></span>is_nothrow_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_constructible_v = <a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a>&lt;T, Args...&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2efb1cd1aad111e64a98e89322815a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efb1cd1aad111e64a98e89322815a8f">&#9670;&nbsp;</a></span>is_nothrow_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From , typename To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_convertible_v = <a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a>&lt;From, To&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5684c28598fd5bde573fccdf36cccda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5684c28598fd5bde573fccdf36cccda9">&#9670;&nbsp;</a></span>is_nothrow_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_copy_assignable_v = <a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab05ca75073ae3731fef7c09200d9f693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05ca75073ae3731fef7c09200d9f693">&#9670;&nbsp;</a></span>is_nothrow_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_copy_constructible_v = <a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12e312d7578609fe1f21277a6d7a1606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e312d7578609fe1f21277a6d7a1606">&#9670;&nbsp;</a></span>is_nothrow_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_default_constructible_v = <a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92bb068a979f4237eb8c218d4f0112f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bb068a979f4237eb8c218d4f0112f2">&#9670;&nbsp;</a></span>is_nothrow_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_destructible_v = <a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5d18b577003e8d090a82e4c6d497cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d18b577003e8d090a82e4c6d497cdd">&#9670;&nbsp;</a></span>is_nothrow_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_move_assignable_v = <a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00f5b3ced7a1f4ebd3e7b1119a4c12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">&#9670;&nbsp;</a></span>is_nothrow_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_move_constructible_v = <a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fe0a7655d7b161139e48f8eb34838ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe0a7655d7b161139e48f8eb34838ac">&#9670;&nbsp;</a></span>is_nothrow_swappable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_swappable_v = <a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d458068230554e22227d91a28708809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d458068230554e22227d91a28708809">&#9670;&nbsp;</a></span>is_nothrow_swappable_with_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_swappable_with_v = <a class="el" href="structetl_1_1is__nothrow__swappable__with.html">is_nothrow_swappable_with</a>&lt;T, U&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a016c8419365e8e3697a56040d335bca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016c8419365e8e3697a56040d335bca4">&#9670;&nbsp;</a></span>is_null_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_null_pointer_v = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63efd09c0ee7195824be65423adadedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63efd09c0ee7195824be65423adadedc">&#9670;&nbsp;</a></span>is_object_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_object_v = <a class="el" href="structetl_1_1is__object.html">is_object</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00eca7d51c4d2c1021402ee9a70f03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00eca7d51c4d2c1021402ee9a70f03c">&#9670;&nbsp;</a></span>is_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_pointer_v = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca8f73739262829ccbc6f7400f3b2601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8f73739262829ccbc6f7400f3b2601">&#9670;&nbsp;</a></span>is_polymorphic_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_polymorphic_v = __is_polymorphic(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22294e9170ea0547c68724eabe0c8c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22294e9170ea0547c68724eabe0c8c5a">&#9670;&nbsp;</a></span>is_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_reference_v = <a class="el" href="structetl_1_1is__reference.html">is_reference</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73c52ea67297deb4aba0a1d7abb142f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c52ea67297deb4aba0a1d7abb142f5">&#9670;&nbsp;</a></span>is_reference_wrapper_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_reference_wrapper_v = <a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2cba0c4e29fbd91ba77cbf6b9744ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cba0c4e29fbd91ba77cbf6b9744ebc">&#9670;&nbsp;</a></span>is_rvalue_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_rvalue_reference_v = <a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f74da2365a9a6f68d472686fd0f1666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f74da2365a9a6f68d472686fd0f1666">&#9670;&nbsp;</a></span>is_same_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_same_v = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a699a4890b6c210a9503c517082e10e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699a4890b6c210a9503c517082e10e6c">&#9670;&nbsp;</a></span>is_same_v&lt; T, T &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt; T, T &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab43d223a689de0810df63d7c223d4228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43d223a689de0810df63d7c223d4228">&#9670;&nbsp;</a></span>is_scalar_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_scalar_v = <a class="el" href="structetl_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3e458f80e6889b85b2e3bf2ee84360b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e458f80e6889b85b2e3bf2ee84360b">&#9670;&nbsp;</a></span>is_scoped_enum_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_scoped_enum_v = <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether T is an scoped enumeration type. Provides the member constant value which is equal to true, if T is an scoped enumeration type. Otherwise, value is equal to false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a> or is_scoped_enum_v is undefined. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/is_scoped_enum">https://en.cppreference.com/w/cpp/types/is_scoped_enum</a> </p>

</div>
</div>
<a id="aff3fadd2a1e349c45f524ab5444220ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3fadd2a1e349c45f524ab5444220ff">&#9670;&nbsp;</a></span>is_signed_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_signed_v = <a class="el" href="structetl_1_1is__signed.html">is_signed</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68efadb1ffae420e853d78309b080bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efadb1ffae420e853d78309b080bb5">&#9670;&nbsp;</a></span>is_specialized_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; typename Template, typename T , typename Tag  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_specialized_v = <a class="el" href="structetl_1_1is__specialized.html">etl::is_specialized</a>&lt;Template, T, Tag&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad52ae3e71a7e5954830504af2048ed7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52ae3e71a7e5954830504af2048ed7d">&#9670;&nbsp;</a></span>is_standard_integer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_standard_integer_v = <a class="el" href="namespaceetl.html#a4881471dda8be900e4d183c9a413f66c">is_standard_unsigned_integer_v</a>&lt;T&gt; or <a class="el" href="namespaceetl.html#ab19a5f05a129870f874303571c11da48">is_standard_signed_integer_v</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0627b73385571d2f5b0bb7b5f23d0c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0627b73385571d2f5b0bb7b5f23d0c4e">&#9670;&nbsp;</a></span>is_standard_layout_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_standard_layout_v = <a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab19a5f05a129870f874303571c11da48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19a5f05a129870f874303571c11da48">&#9670;&nbsp;</a></span>is_standard_signed_integer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_standard_signed_integer_v = <a class="el" href="namespaceetl.html#ad0de9ab0c91e46602a77993e77ec8a6d">etl::is_any_of_v</a>&lt;<a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">etl::remove_cv_t</a>&lt;T&gt;, signed char, short, int, long, long long&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4881471dda8be900e4d183c9a413f66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4881471dda8be900e4d183c9a413f66c">&#9670;&nbsp;</a></span>is_standard_unsigned_integer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_standard_unsigned_integer_v = <a class="el" href="namespaceetl.html#ad0de9ab0c91e46602a77993e77ec8a6d">is_any_of_v</a>&lt;<a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">remove_cv_t</a>&lt;T&gt;, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46cb1671f31576cce07cf1bac1e99f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cb1671f31576cce07cf1bac1e99f7c">&#9670;&nbsp;</a></span>is_swappable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_swappable_v = <a class="el" href="structetl_1_1is__swappable.html">is_swappable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5489a5258551040b63e6eef9f49264d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5489a5258551040b63e6eef9f49264d8">&#9670;&nbsp;</a></span>noexcept</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;rhs etl::noexcept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1is__nothrow__swappable.html">etl::is_nothrow_swappable</a>&lt; T &gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7be84147dabbe2371aec6974e74d0f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be84147dabbe2371aec6974e74d0f77">&#9670;&nbsp;</a></span>is_swappable_with_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_swappable_with_v = <a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a>&lt;T, U&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dc5a4c4924b529a3f8760925c283ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc5a4c4924b529a3f8760925c283ce6">&#9670;&nbsp;</a></span>is_trivial_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivial_v = <a class="el" href="structetl_1_1is__trivial.html">is_trivial</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2cfce5bc9de7ea45285ad503a807a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cfce5bc9de7ea45285ad503a807a9b">&#9670;&nbsp;</a></span>is_trivially_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_assignable_v = <a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a>&lt;T, U&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a74c34b46b65c2b8fa633d1e6211b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a74c34b46b65c2b8fa633d1e6211b25">&#9670;&nbsp;</a></span>is_trivially_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_constructible_v = <a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a>&lt;T, Args...&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4028d9154b8d629e56fd488b33587786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4028d9154b8d629e56fd488b33587786">&#9670;&nbsp;</a></span>is_trivially_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_copy_assignable_v = <a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac56b91d45ec88c108b77f55e9f6bc187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56b91d45ec88c108b77f55e9f6bc187">&#9670;&nbsp;</a></span>is_trivially_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_copy_constructible_v = <a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b3b937c99443cbaf5f1817d061261bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3b937c99443cbaf5f1817d061261bd">&#9670;&nbsp;</a></span>is_trivially_copyable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_copyable_v = __is_trivially_copyable(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f37ab88cda78781a7aca13f18adac97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f37ab88cda78781a7aca13f18adac97">&#9670;&nbsp;</a></span>is_trivially_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_default_constructible_v = <a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11b9d2d77f59d05a317cc9715ac7aa8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b9d2d77f59d05a317cc9715ac7aa8c">&#9670;&nbsp;</a></span>is_trivially_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_destructible_v = __has_trivial_destructor(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3673480825caede3c2d5095f8a39fe0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3673480825caede3c2d5095f8a39fe0d">&#9670;&nbsp;</a></span>is_trivially_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_move_assignable_v = <a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef6928ba542ac2317ce2796c3a71a9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6928ba542ac2317ce2796c3a71a9b7">&#9670;&nbsp;</a></span>is_trivially_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_trivially_move_constructible_v = <a class="el" href="structetl_1_1is__trivially__move__constructible.html">etl::is_trivially_move_constructible</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00c65af89fc55014250b54559626d075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c65af89fc55014250b54559626d075">&#9670;&nbsp;</a></span>is_unbounded_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_unbounded_array_v = <a class="el" href="structetl_1_1is__unbounded__array.html">etl::is_unbounded_array</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51d4c31d288adf2cb4c5d7fd14c32f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d4c31d288adf2cb4c5d7fd14c32f00">&#9670;&nbsp;</a></span>is_union_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_union_v = __is_union(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bbd05dc09b68b19c63d7b4fbf6f1108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbd05dc09b68b19c63d7b4fbf6f1108">&#9670;&nbsp;</a></span>is_unsigned_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_unsigned_v = <a class="el" href="structetl_1_1is__unsigned.html">etl::is_unsigned</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a149f8ba4063995f2c8ed7248d93a4d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149f8ba4063995f2c8ed7248d93a4d9e">&#9670;&nbsp;</a></span>is_void_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_void_v = <a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt;void, <a class="el" href="namespaceetl.html#abd0aad8fae1237db2f92705fe80729cf">etl::remove_cv_t</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa76b943cef158f554f60c8d61b6835bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76b943cef158f554f60c8d61b6835bc">&#9670;&nbsp;</a></span>is_volatile_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_volatile_v = <a class="el" href="structetl_1_1is__volatile.html">etl::is_volatile</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e0422e10e238c05956150aa5f4ed77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0422e10e238c05956150aa5f4ed77e">&#9670;&nbsp;</a></span>negation_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::negation_v = !bool(B::value)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4229d4171b460abc833736d622ce9745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4229d4171b460abc833736d622ce9745">&#9670;&nbsp;</a></span>rank_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> etl::rank_v = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;Type&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53057a1d7b9d22a69eb3e40fdc44eb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53057a1d7b9d22a69eb3e40fdc44eb3d">&#9670;&nbsp;</a></span>nontype</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nontype = <a class="el" href="structetl_1_1nontype__t.html">etl::nontype_t</a>&lt;V&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29815251de01b00c45a0bb62678930c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29815251de01b00c45a0bb62678930c5">&#9670;&nbsp;</a></span>piecewise_construct</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::piecewise_construct = <a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constant <a class="el" href="namespaceetl.html#a29815251de01b00c45a0bb62678930c5" title="The constant etl::piecewise_construct is an instance of an empty struct tag type etl::piecewise_const...">etl::piecewise_construct</a> is an instance of an empty struct tag type <a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a>. </p>

</div>
</div>
<a id="a28d369052fc23b452882a9fd514abb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d369052fc23b452882a9fd514abb87">&#9670;&nbsp;</a></span>variant_npos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::variant_npos = <a class="el" href="structetl_1_1numeric__limits.html">etl::numeric_limits</a>&lt;<a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">etl::size_t</a>&gt;::<a class="el" href="namespaceetl.html#a7fdd0cf88f36f44f8fe8ec8327cfac74">max</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a special value equal to the largest value representable by the type size_t, used as the return value of index() when valueless_by_exception() is true. </p>

</div>
</div>
<a id="a9289432c6100af2ec8b2563959f2c261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9289432c6100af2ec8b2563959f2c261">&#9670;&nbsp;</a></span>variant_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::variant_size_v = <a class="el" href="structetl_1_1variant__size.html">variant_size</a>&lt;T&gt;::<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8047ec1fd97af797afb4226eba8bd80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8047ec1fd97af797afb4226eba8bd80f">&#9670;&nbsp;</a></span>current_implementation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::current_implementation = <a class="el" href="namespaceetl.html#a035e7d2ea0f6aebad724e7fab40495d5aed920a9dd5bae2e1c4f11aab8f5784e1">implementation::freestanding</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb1c600f9a9722bf7bef4af93af1d5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1c600f9a9722bf7bef4af93af1d5ca">&#9670;&nbsp;</a></span>current_standard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::current_standard = <a class="el" href="namespaceetl.html#a2f63a594bf7e2b29cb07e1868483ee53af94629088b2e56f93753526b629a62ff">language_standard::cpp_26</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The currently configured C++ standard. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
