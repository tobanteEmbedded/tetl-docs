<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: bit</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tetl<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__bit.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">bit<div class="ingroups"><a class="el" href="group__numerics-library.html">Numerics Library</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Bit manipulation functions  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaceb52d5e58265d474290d1e17bcf1716" id="r_gaceb52d5e58265d474290d1e17bcf1716"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaceb52d5e58265d474290d1e17bcf1716">endian</a> { <a class="el" href="#ggaceb52d5e58265d474290d1e17bcf1716aaae6635e044ac56046b2893a529b5114">little</a> = __ORDER_LITTLE_ENDIAN__
, <a class="el" href="#ggaceb52d5e58265d474290d1e17bcf1716ad861877da56b8b4ceb35c8cbfdf65bb4">big</a> = __ORDER_BIG_ENDIAN__
, <a class="el" href="#ggaceb52d5e58265d474290d1e17bcf1716a8e5f3adee38c8fccc13c1f3be0143796">native</a> = __BYTE_ORDER__
 }</td></tr>
<tr class="memdesc:gaceb52d5e58265d474290d1e17bcf1716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the endianness of all scalar types. If all scalar types are little-endian, <code>endian::native</code> equals <code>endian::little</code>. If all scalar types are big-endian, <code>endian::native</code> equals <code>endian::big</code>.  <a href="#gaceb52d5e58265d474290d1e17bcf1716">More...</a><br /></td></tr>
<tr class="separator:gaceb52d5e58265d474290d1e17bcf1716"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8345e9aa2cae9bfb32b62f761780c254" id="r_ga8345e9aa2cae9bfb32b62f761780c254"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; <br />
requires detail::bitcastable&lt;To, From&gt;</td></tr>
<tr class="memitem:ga8345e9aa2cae9bfb32b62f761780c254"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8345e9aa2cae9bfb32b62f761780c254">bit_cast</a> (From const &amp;src) noexcept -&gt; To</td></tr>
<tr class="memdesc:ga8345e9aa2cae9bfb32b62f761780c254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a value of type To by reinterpreting the object representation of from. Every bit in the value representation of the returned To object is equal to the corresponding bit in the object representation of from.  <br /></td></tr>
<tr class="separator:ga8345e9aa2cae9bfb32b62f761780c254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5006351c988afecab30821e1ee41f2ed" id="r_ga5006351c988afecab30821e1ee41f2ed"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga5006351c988afecab30821e1ee41f2ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5006351c988afecab30821e1ee41f2ed">bit_ceil</a> (UInt x) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga5006351c988afecab30821e1ee41f2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the smallest integral power of two that is not smaller than x. If that value is not representable in UInt, the behavior is undefined. Call to this function is permitted in constant evaluation only if the undefined behavior does not occur.  <br /></td></tr>
<tr class="separator:ga5006351c988afecab30821e1ee41f2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa305e9d1d725f6dfaebce56120c9f45d" id="r_gaa305e9d1d725f6dfaebce56120c9f45d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaa305e9d1d725f6dfaebce56120c9f45d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa305e9d1d725f6dfaebce56120c9f45d">bit_floor</a> (UInt x) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:gaa305e9d1d725f6dfaebce56120c9f45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x is not zero, calculates the largest integral power of two that is not greater than x. If x is zero, returns zero.  <br /></td></tr>
<tr class="separator:gaa305e9d1d725f6dfaebce56120c9f45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae31295beb3cd3da128d5df9392b56816" id="r_gae31295beb3cd3da128d5df9392b56816"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gae31295beb3cd3da128d5df9392b56816"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae31295beb3cd3da128d5df9392b56816">bit_width</a> (UInt x) noexcept -&gt; int</td></tr>
<tr class="memdesc:gae31295beb3cd3da128d5df9392b56816"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x is not zero, calculates the number of bits needed to store the value x, that is, 1+⌊log2(x)⌋. If x is zero, returns zero.  <br /></td></tr>
<tr class="separator:gae31295beb3cd3da128d5df9392b56816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56cd46acc36e47b8dd8e0db497b856cb" id="r_ga56cd46acc36e47b8dd8e0db497b856cb"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:ga56cd46acc36e47b8dd8e0db497b856cb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga56cd46acc36e47b8dd8e0db497b856cb">byteswap</a> (Int val) noexcept -&gt; Int</td></tr>
<tr class="memdesc:ga56cd46acc36e47b8dd8e0db497b856cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the bytes in the given integer value n.  <br /></td></tr>
<tr class="separator:ga56cd46acc36e47b8dd8e0db497b856cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ff4047b7f7215764870239e29f7647" id="r_gaa8ff4047b7f7215764870239e29f7647"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaa8ff4047b7f7215764870239e29f7647"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa8ff4047b7f7215764870239e29f7647">countl_one</a> (UInt x) noexcept -&gt; int</td></tr>
<tr class="memdesc:gaa8ff4047b7f7215764870239e29f7647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 1 ("one") bits in the value of x, starting from the most significant bit ("left").  <br /></td></tr>
<tr class="separator:gaa8ff4047b7f7215764870239e29f7647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga120e955a7d833bee8e6c68c6a5639ca3" id="r_ga120e955a7d833bee8e6c68c6a5639ca3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga120e955a7d833bee8e6c68c6a5639ca3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga120e955a7d833bee8e6c68c6a5639ca3">countl_zero</a> (UInt x) noexcept -&gt; int</td></tr>
<tr class="memdesc:ga120e955a7d833bee8e6c68c6a5639ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 0 bits in the value of x, starting from the most significant bit ("left").  <br /></td></tr>
<tr class="separator:ga120e955a7d833bee8e6c68c6a5639ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e62f92367cf6ac4c456e52924e0814" id="r_gac7e62f92367cf6ac4c456e52924e0814"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gac7e62f92367cf6ac4c456e52924e0814"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac7e62f92367cf6ac4c456e52924e0814">countr_one</a> (UInt x) noexcept -&gt; int</td></tr>
<tr class="memdesc:gac7e62f92367cf6ac4c456e52924e0814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 1 bits in the value of x, starting from the least significant bit ("right").  <br /></td></tr>
<tr class="separator:gac7e62f92367cf6ac4c456e52924e0814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a2e4bffa2cb54b6a5b018cbe2724690" id="r_ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8a2e4bffa2cb54b6a5b018cbe2724690">countr_zero</a> (UInt x) noexcept -&gt; int</td></tr>
<tr class="memdesc:ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 0 bits in the value of x, starting from the least significant bit ("right").  <br /></td></tr>
<tr class="separator:ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e24662e346fc90c79dc7023e66ebd6d" id="r_ga7e24662e346fc90c79dc7023e66ebd6d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga7e24662e346fc90c79dc7023e66ebd6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7e24662e346fc90c79dc7023e66ebd6d">flip_bit</a> (UInt word) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga7e24662e346fc90c79dc7023e66ebd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip bit at position Pos.  <br /></td></tr>
<tr class="separator:ga7e24662e346fc90c79dc7023e66ebd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83522e02ec5bafd96be4cbdd71c207ae" id="r_ga83522e02ec5bafd96be4cbdd71c207ae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga83522e02ec5bafd96be4cbdd71c207ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga83522e02ec5bafd96be4cbdd71c207ae">flip_bit</a> (UInt word, UInt pos) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga83522e02ec5bafd96be4cbdd71c207ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:ga83522e02ec5bafd96be4cbdd71c207ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4732ae6a536891ce2d355378e0ac571c" id="r_ga4732ae6a536891ce2d355378e0ac571c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga4732ae6a536891ce2d355378e0ac571c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4732ae6a536891ce2d355378e0ac571c">has_single_bit</a> (UInt x) noexcept -&gt; bool</td></tr>
<tr class="memdesc:ga4732ae6a536891ce2d355378e0ac571c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if x is an integral power of two.  <br /></td></tr>
<tr class="separator:ga4732ae6a536891ce2d355378e0ac571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484a219aea6406f7398208397bb244eb" id="r_ga484a219aea6406f7398208397bb244eb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga484a219aea6406f7398208397bb244eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga484a219aea6406f7398208397bb244eb">popcount</a> (UInt val) noexcept -&gt; int</td></tr>
<tr class="memdesc:ga484a219aea6406f7398208397bb244eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 1 bits in the value of x.  <br /></td></tr>
<tr class="separator:ga484a219aea6406f7398208397bb244eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga475638bd9306d99c55d5543eb3979b8f" id="r_ga475638bd9306d99c55d5543eb3979b8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga475638bd9306d99c55d5543eb3979b8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga475638bd9306d99c55d5543eb3979b8f">reset_bit</a> (UInt word) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga475638bd9306d99c55d5543eb3979b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset bit at position Pos.  <br /></td></tr>
<tr class="separator:ga475638bd9306d99c55d5543eb3979b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d7eab610ba1068c0cd27c9cc00a45a" id="r_ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga76d7eab610ba1068c0cd27c9cc00a45a">reset_bit</a> (UInt word, UInt pos) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3111087bb441d3683d06cb5af2e68c3c" id="r_ga3111087bb441d3683d06cb5af2e68c3c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga3111087bb441d3683d06cb5af2e68c3c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3111087bb441d3683d06cb5af2e68c3c">rotl</a> (UInt t, int s) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga3111087bb441d3683d06cb5af2e68c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the result of bitwise left-rotating the value of x by s positions. This operation is also known as a left circular shift.  <br /></td></tr>
<tr class="separator:ga3111087bb441d3683d06cb5af2e68c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aeaa8cb213500ab9a8cf6ee98314d2a" id="r_ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2aeaa8cb213500ab9a8cf6ee98314d2a">rotr</a> (UInt t, int s) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the result of bitwise right-rotating the value of x by s positions. This operation is also known as a right circular shift.  <br /></td></tr>
<tr class="separator:ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef0ecd7ca83244453f2e3ca077cf4d4" id="r_gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaeef0ecd7ca83244453f2e3ca077cf4d4">set_bit</a> (UInt word) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>Pos</code>  <br /></td></tr>
<tr class="separator:gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa73517548e29dd7eff01b08cd2619a2" id="r_gafa73517548e29dd7eff01b08cd2619a2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gafa73517548e29dd7eff01b08cd2619a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gafa73517548e29dd7eff01b08cd2619a2">set_bit</a> (UInt word, bool value) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:gafa73517548e29dd7eff01b08cd2619a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>Pos</code> to <code>value</code>.  <br /></td></tr>
<tr class="separator:gafa73517548e29dd7eff01b08cd2619a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029b15dc4de2e5837b791049d6d16ed0" id="r_ga029b15dc4de2e5837b791049d6d16ed0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga029b15dc4de2e5837b791049d6d16ed0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga029b15dc4de2e5837b791049d6d16ed0">set_bit</a> (UInt word, UInt pos) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga029b15dc4de2e5837b791049d6d16ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:ga029b15dc4de2e5837b791049d6d16ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa12374769ae1db920c570b5b5b0cec13" id="r_gaa12374769ae1db920c570b5b5b0cec13"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaa12374769ae1db920c570b5b5b0cec13"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa12374769ae1db920c570b5b5b0cec13">set_bit</a> (UInt word, UInt pos, bool value) -&gt; UInt</td></tr>
<tr class="memdesc:gaa12374769ae1db920c570b5b5b0cec13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>pos</code> to <code>value</code>.  <br /></td></tr>
<tr class="separator:gaa12374769ae1db920c570b5b5b0cec13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga726b254bcee55a0855832cfd3bafd000" id="r_ga726b254bcee55a0855832cfd3bafd000"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga726b254bcee55a0855832cfd3bafd000"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga726b254bcee55a0855832cfd3bafd000">test_bit</a> (UInt word) noexcept -&gt; bool</td></tr>
<tr class="memdesc:ga726b254bcee55a0855832cfd3bafd000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test bit at position <code>Pos</code>  <br /></td></tr>
<tr class="separator:ga726b254bcee55a0855832cfd3bafd000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4773cf495c99535fcec3c02995c7427" id="r_gab4773cf495c99535fcec3c02995c7427"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gab4773cf495c99535fcec3c02995c7427"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab4773cf495c99535fcec3c02995c7427">test_bit</a> (UInt word, UInt pos) noexcept -&gt; bool</td></tr>
<tr class="memdesc:gab4773cf495c99535fcec3c02995c7427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:gab4773cf495c99535fcec3c02995c7427"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Bit manipulation functions </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bit_8hpp.html">etl/bit.hpp</a>&gt;</span></div>
<div class="ttc" id="abit_8hpp_html"><div class="ttname"><a href="bit_8hpp.html">bit.hpp</a></div></div>
</div><!-- fragment --> <h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaceb52d5e58265d474290d1e17bcf1716" name="gaceb52d5e58265d474290d1e17bcf1716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceb52d5e58265d474290d1e17bcf1716">&#9670;&#160;</a></span>endian</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum struct <a class="el" href="#gaceb52d5e58265d474290d1e17bcf1716">endian</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the endianness of all scalar types. If all scalar types are little-endian, <code><a class="el" href="#ggaceb52d5e58265d474290d1e17bcf1716a8e5f3adee38c8fccc13c1f3be0143796">endian::native</a></code> equals <code><a class="el" href="#ggaceb52d5e58265d474290d1e17bcf1716aaae6635e044ac56046b2893a529b5114">endian::little</a></code>. If all scalar types are big-endian, <code><a class="el" href="#ggaceb52d5e58265d474290d1e17bcf1716a8e5f3adee38c8fccc13c1f3be0143796">endian::native</a></code> equals <code><a class="el" href="#ggaceb52d5e58265d474290d1e17bcf1716ad861877da56b8b4ceb35c8cbfdf65bb4">endian::big</a></code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/endian">https://en.cppreference.com/w/cpp/types/endian</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaceb52d5e58265d474290d1e17bcf1716aaae6635e044ac56046b2893a529b5114" name="ggaceb52d5e58265d474290d1e17bcf1716aaae6635e044ac56046b2893a529b5114"></a>little&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaceb52d5e58265d474290d1e17bcf1716ad861877da56b8b4ceb35c8cbfdf65bb4" name="ggaceb52d5e58265d474290d1e17bcf1716ad861877da56b8b4ceb35c8cbfdf65bb4"></a>big&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaceb52d5e58265d474290d1e17bcf1716a8e5f3adee38c8fccc13c1f3be0143796" name="ggaceb52d5e58265d474290d1e17bcf1716a8e5f3adee38c8fccc13c1f3be0143796"></a>native&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8345e9aa2cae9bfb32b62f761780c254" name="ga8345e9aa2cae9bfb32b62f761780c254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8345e9aa2cae9bfb32b62f761780c254">&#9670;&#160;</a></span>bit_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; <br />
requires detail::bitcastable&lt;To, From&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bit_cast </td>
          <td>(</td>
          <td class="paramtype">From const &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td> -&gt; To
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a value of type To by reinterpreting the object representation of from. Every bit in the value representation of the returned To object is equal to the corresponding bit in the object representation of from. </p>
<p>The values of padding bits in the returned To object are unspecified. If there is no value of type To corresponding to the value representation produced, the behavior is undefined. If there are multiple such values, which value is produced is unspecified. This overload only participates in overload resolution if sizeof(To) == sizeof(From) and both To and From are TriviallyCopyable types.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/bit_cast">https://en.cppreference.com/w/cpp/numeric/bit_cast</a> </p>

</div>
</div>
<a id="ga5006351c988afecab30821e1ee41f2ed" name="ga5006351c988afecab30821e1ee41f2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5006351c988afecab30821e1ee41f2ed">&#9670;&#160;</a></span>bit_ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bit_ceil </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the smallest integral power of two that is not smaller than x. If that value is not representable in UInt, the behavior is undefined. Call to this function is permitted in constant evaluation only if the undefined behavior does not occur. </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The smallest integral power of two that is not smaller than x. </dd></dl>

</div>
</div>
<a id="gaa305e9d1d725f6dfaebce56120c9f45d" name="gaa305e9d1d725f6dfaebce56120c9f45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa305e9d1d725f6dfaebce56120c9f45d">&#9670;&#160;</a></span>bit_floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bit_floor </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If x is not zero, calculates the largest integral power of two that is not greater than x. If x is zero, returns zero. </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>Zero if x is zero; otherwise, the largest integral power of two that is not greater than x. </dd></dl>

</div>
</div>
<a id="gae31295beb3cd3da128d5df9392b56816" name="gae31295beb3cd3da128d5df9392b56816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae31295beb3cd3da128d5df9392b56816">&#9670;&#160;</a></span>bit_width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bit_width </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If x is not zero, calculates the number of bits needed to store the value x, that is, 1+⌊log2(x)⌋. If x is zero, returns zero. </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type). </p>

</div>
</div>
<a id="ga56cd46acc36e47b8dd8e0db497b856cb" name="ga56cd46acc36e47b8dd8e0db497b856cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56cd46acc36e47b8dd8e0db497b856cb">&#9670;&#160;</a></span>byteswap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto byteswap </td>
          <td>(</td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> -&gt; Int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the bytes in the given integer value n. </p>
<p><a class="el" href="#ga56cd46acc36e47b8dd8e0db497b856cb" title="Reverses the bytes in the given integer value n.">etl::byteswap</a> participates in overload resolution only if Int satisfies integral, i.e., Int is an integer type. The program is ill-formed if Int has padding bits.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/byteswap">https://en.cppreference.com/w/cpp/numeric/byteswap</a> </p>

</div>
</div>
<a id="gaa8ff4047b7f7215764870239e29f7647" name="gaa8ff4047b7f7215764870239e29f7647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8ff4047b7f7215764870239e29f7647">&#9670;&#160;</a></span>countl_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto countl_one </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of consecutive 1 ("one") bits in the value of x, starting from the most significant bit ("left"). </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of consecutive 1 bits in the value of x, starting from the most significant bit. </dd></dl>

</div>
</div>
<a id="ga120e955a7d833bee8e6c68c6a5639ca3" name="ga120e955a7d833bee8e6c68c6a5639ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga120e955a7d833bee8e6c68c6a5639ca3">&#9670;&#160;</a></span>countl_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto countl_zero </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of consecutive 0 bits in the value of x, starting from the most significant bit ("left"). </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of consecutive 0 bits in the value of x, starting from the most significant bit. </dd></dl>

</div>
</div>
<a id="gac7e62f92367cf6ac4c456e52924e0814" name="gac7e62f92367cf6ac4c456e52924e0814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7e62f92367cf6ac4c456e52924e0814">&#9670;&#160;</a></span>countr_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto countr_one </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of consecutive 1 bits in the value of x, starting from the least significant bit ("right"). </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of consecutive 1 bits in the value of x, starting from the least significant bit. </dd></dl>

</div>
</div>
<a id="ga8a2e4bffa2cb54b6a5b018cbe2724690" name="ga8a2e4bffa2cb54b6a5b018cbe2724690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a2e4bffa2cb54b6a5b018cbe2724690">&#9670;&#160;</a></span>countr_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto countr_zero </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of consecutive 0 bits in the value of x, starting from the least significant bit ("right"). </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of consecutive 0 bits in the value of x, starting from the least significant bit. </dd></dl>

</div>
</div>
<a id="ga7e24662e346fc90c79dc7023e66ebd6d" name="ga7e24662e346fc90c79dc7023e66ebd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e24662e346fc90c79dc7023e66ebd6d">&#9670;&#160;</a></span>flip_bit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flip_bit </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flip bit at position Pos. </p>
<p><a href="https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit">https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit</a> </p><dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga83522e02ec5bafd96be4cbdd71c207ae" name="ga83522e02ec5bafd96be4cbdd71c207ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83522e02ec5bafd96be4cbdd71c207ae">&#9670;&#160;</a></span>flip_bit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto flip_bit </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flip bit at position <code>pos</code>. </p>
<p><a href="https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit">https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit</a> </p><dl class="section pre"><dt>Precondition</dt><dd>Position <code>pos</code> must be a valid bit-index for UInt </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga4732ae6a536891ce2d355378e0ac571c" name="ga4732ae6a536891ce2d355378e0ac571c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4732ae6a536891ce2d355378e0ac571c">&#9670;&#160;</a></span>has_single_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto has_single_bit </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if x is an integral power of two. </p>
<p>This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>true if x is an integral power of two; otherwise false. </dd></dl>

</div>
</div>
<a id="ga484a219aea6406f7398208397bb244eb" name="ga484a219aea6406f7398208397bb244eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga484a219aea6406f7398208397bb244eb">&#9670;&#160;</a></span>popcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto popcount </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of 1 bits in the value of x. </p>
<p>This overload only participates in overload resolution if UInt is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type). </p>

</div>
</div>
<a id="ga475638bd9306d99c55d5543eb3979b8f" name="ga475638bd9306d99c55d5543eb3979b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga475638bd9306d99c55d5543eb3979b8f">&#9670;&#160;</a></span>reset_bit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto reset_bit </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset bit at position Pos. </p>
<p><a href="https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit">https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit</a> </p><dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga76d7eab610ba1068c0cd27c9cc00a45a" name="ga76d7eab610ba1068c0cd27c9cc00a45a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76d7eab610ba1068c0cd27c9cc00a45a">&#9670;&#160;</a></span>reset_bit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto reset_bit </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset bit at position <code>pos</code>. </p>
<p><a href="https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit">https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit</a> </p><dl class="section pre"><dt>Precondition</dt><dd>Position <code>pos</code> must be a valid bit-index for UInt </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga3111087bb441d3683d06cb5af2e68c3c" name="ga3111087bb441d3683d06cb5af2e68c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3111087bb441d3683d06cb5af2e68c3c">&#9670;&#160;</a></span>rotl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rotl </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;) -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the result of bitwise left-rotating the value of x by s positions. This operation is also known as a left circular shift. </p>

</div>
</div>
<a id="ga2aeaa8cb213500ab9a8cf6ee98314d2a" name="ga2aeaa8cb213500ab9a8cf6ee98314d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aeaa8cb213500ab9a8cf6ee98314d2a">&#9670;&#160;</a></span>rotr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rotr </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;) -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the result of bitwise right-rotating the value of x by s positions. This operation is also known as a right circular shift. </p>

</div>
</div>
<a id="gaeef0ecd7ca83244453f2e3ca077cf4d4" name="gaeef0ecd7ca83244453f2e3ca077cf4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeef0ecd7ca83244453f2e3ca077cf4d4">&#9670;&#160;</a></span>set_bit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_bit </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td> -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set bit at position <code>Pos</code> </p>
<p><a href="https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit">https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit</a> </p><dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="gafa73517548e29dd7eff01b08cd2619a2" name="gafa73517548e29dd7eff01b08cd2619a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa73517548e29dd7eff01b08cd2619a2">&#9670;&#160;</a></span>set_bit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_bit </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set bit at position <code>Pos</code> to <code>value</code>. </p>
<p><a href="https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit">https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit</a> </p><dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga029b15dc4de2e5837b791049d6d16ed0" name="ga029b15dc4de2e5837b791049d6d16ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga029b15dc4de2e5837b791049d6d16ed0">&#9670;&#160;</a></span>set_bit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_bit </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set bit at position <code>pos</code>. </p>
<p><a href="https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit">https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit</a> </p><dl class="section pre"><dt>Precondition</dt><dd>Position <code>pos</code> must be a valid bit-index for UInt </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="gaa12374769ae1db920c570b5b5b0cec13" name="gaa12374769ae1db920c570b5b5b0cec13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa12374769ae1db920c570b5b5b0cec13">&#9670;&#160;</a></span>set_bit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_bit </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; UInt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set bit at position <code>pos</code> to <code>value</code>. </p>
<p><a href="https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit">https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit</a> </p><dl class="section pre"><dt>Precondition</dt><dd>Position <code>pos</code> must be a valid bit-index for UInt </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga726b254bcee55a0855832cfd3bafd000" name="ga726b254bcee55a0855832cfd3bafd000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga726b254bcee55a0855832cfd3bafd000">&#9670;&#160;</a></span>test_bit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto test_bit </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test bit at position <code>Pos</code> </p>
<p><a href="https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit">https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit</a> </p><dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="gab4773cf495c99535fcec3c02995c7427" name="gab4773cf495c99535fcec3c02995c7427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4773cf495c99535fcec3c02995c7427">&#9670;&#160;</a></span>test_bit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto test_bit </td>
          <td>(</td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test bit at position <code>pos</code>. </p>
<p><a href="https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit">https://stackoverflow.com/questions/47981/how-to-set-clear-and-toggle-a-single-bit</a> </p><dl class="section pre"><dt>Precondition</dt><dd>Position <code>pos</code> must be a valid bit-index for UInt </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Apr 23 2024 10:21:56 for tetl by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
