<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: algorithm.hpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tetl<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__algorithm-hpp.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">algorithm.hpp<div class="ingroups"><a class="el" href="group__algorithms-lib.html">Algorithms Library</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Algorithms that operate on ranges  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="memitem:ga09c5b412c05c58fb89e569a2d72ed17e" id="r_ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga09c5b412c05c58fb89e569a2d72ed17e">etl::adjacent_find</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p.  <br /></td></tr>
<tr class="separator:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe91c66e3042bde20710111a8d622e4" id="r_ga4fe91c66e3042bde20710111a8d622e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ga4fe91c66e3042bde20710111a8d622e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4fe91c66e3042bde20710111a8d622e4">etl::adjacent_find</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="separator:ga4fe91c66e3042bde20710111a8d622e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76b028bf28233ada520a5bc0d52f6b9" id="r_gac76b028bf28233ada520a5bc0d52f6b9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gac76b028bf28233ada520a5bc0d52f6b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac76b028bf28233ada520a5bc0d52f6b9">etl::all_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:gac76b028bf28233ada520a5bc0d52f6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for all elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gac76b028bf28233ada520a5bc0d52f6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d4122ca9a611ac90a64ff447c212a42" id="r_ga1d4122ca9a611ac90a64ff447c212a42"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga1d4122ca9a611ac90a64ff447c212a42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1d4122ca9a611ac90a64ff447c212a42">etl::any_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga1d4122ca9a611ac90a64ff447c212a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for at least one element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga1d4122ca9a611ac90a64ff447c212a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8844708a6931fb2b21419d7a605328dd" id="r_ga8844708a6931fb2b21419d7a605328dd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga8844708a6931fb2b21419d7a605328dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8844708a6931fb2b21419d7a605328dd">etl::binary_search</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga8844708a6931fb2b21419d7a605328dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an element equivalent to value appears within the range <code>[first, last)</code>. For binary_search to succeed, the range <code>[first, last)</code> must be at least partially ordered with respect to <code>value</code>.  <br /></td></tr>
<tr class="separator:ga8844708a6931fb2b21419d7a605328dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb446f356892ac1d540180018a20faba" id="r_gadb446f356892ac1d540180018a20faba"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gadb446f356892ac1d540180018a20faba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadb446f356892ac1d540180018a20faba">etl::binary_search</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:gadb446f356892ac1d540180018a20faba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46270726b5073fd6eeefb5ccd9ed1f72" id="r_ga46270726b5073fd6eeefb5ccd9ed1f72"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga46270726b5073fd6eeefb5ccd9ed1f72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga46270726b5073fd6eeefb5ccd9ed1f72">etl::bubble_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ga46270726b5073fd6eeefb5ccd9ed1f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:ga46270726b5073fd6eeefb5ccd9ed1f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc149eb7abea4405c02e767e7860dae" id="r_ga1cc149eb7abea4405c02e767e7860dae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:ga1cc149eb7abea4405c02e767e7860dae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1cc149eb7abea4405c02e767e7860dae">etl::bubble_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:ga1cc149eb7abea4405c02e767e7860dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfa416a307b0bb33666d34845c42ba2b" id="r_gabfa416a307b0bb33666d34845c42ba2b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gabfa416a307b0bb33666d34845c42ba2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabfa416a307b0bb33666d34845c42ba2b">etl::clamp</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lo</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">hi</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:gabfa416a307b0bb33666d34845c42ba2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <br /></td></tr>
<tr class="separator:gabfa416a307b0bb33666d34845c42ba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90379160c94dc0396b5f32204c790bf" id="r_gaf90379160c94dc0396b5f32204c790bf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:gaf90379160c94dc0396b5f32204c790bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf90379160c94dc0396b5f32204c790bf">etl::clamp</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lo</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">hi</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:gaf90379160c94dc0396b5f32204c790bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3271ee1abafc543f4bf69cc20b01ded" id="r_gad3271ee1abafc543f4bf69cc20b01ded"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:gad3271ee1abafc543f4bf69cc20b01ded"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad3271ee1abafc543f4bf69cc20b01ded">etl::copy</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:gad3271ee1abafc543f4bf69cc20b01ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <br /></td></tr>
<tr class="separator:gad3271ee1abafc543f4bf69cc20b01ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5caeb0f954aff0eb31c350558f7e827" id="r_gaf5caeb0f954aff0eb31c350558f7e827"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> &gt; </td></tr>
<tr class="memitem:gaf5caeb0f954aff0eb31c350558f7e827"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf5caeb0f954aff0eb31c350558f7e827">etl::copy_backward</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> <a class="el" href="structetl_1_1static__vector.html">dLast</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a></td></tr>
<tr class="memdesc:gaf5caeb0f954aff0eb31c350558f7e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range, defined by <code>[first, last)</code>, to another range ending at <code>dLast</code>. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved.  <br /></td></tr>
<tr class="separator:gaf5caeb0f954aff0eb31c350558f7e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31799054ecdf344760efe76af7987776" id="r_ga31799054ecdf344760efe76af7987776"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Pred</a> &gt; </td></tr>
<tr class="memitem:ga31799054ecdf344760efe76af7987776"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga31799054ecdf344760efe76af7987776">etl::copy_if</a> (<a class="el" href="structetl_1_1static__vector.html">InIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutIt</a> <a class="el" href="structetl_1_1static__vector.html">dFirst</a>, <a class="el" href="structetl_1_1static__vector.html">Pred</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutIt</a></td></tr>
<tr class="memdesc:ga31799054ecdf344760efe76af7987776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <br /></td></tr>
<tr class="separator:ga31799054ecdf344760efe76af7987776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa65063d9f87cd088156f3d49bb32f2e5" id="r_gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa65063d9f87cd088156f3d49bb32f2e5">etl::copy_n</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">result</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer <code>0 &lt;= i &lt; count</code>, performs <code>*(result + i) = *(first + i)</code>. Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results.  <br /></td></tr>
<tr class="separator:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aff5cc5281436a205079dc71ee4c317" id="r_ga7aff5cc5281436a205079dc71ee4c317"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga7aff5cc5281436a205079dc71ee4c317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7aff5cc5281436a205079dc71ee4c317">etl::count_if</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt;::difference_type</td></tr>
<tr class="memdesc:ga7aff5cc5281436a205079dc71ee4c317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:ga7aff5cc5281436a205079dc71ee4c317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Algorithms that operate on ranges </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="algorithm_8hpp.html">etl/algorithm.hpp</a>&gt;</span></div>
<div class="ttc" id="aalgorithm_8hpp_html"><div class="ttname"><a href="algorithm_8hpp.html">algorithm.hpp</a></div></div>
</div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a id="ga09c5b412c05c58fb89e569a2d72ed17e" name="ga09c5b412c05c58fb89e569a2d72ed17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09c5b412c05c58fb89e569a2d72ed17e">&#9670;&#160;</a></span>adjacent_find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::adjacent_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns ​true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_find">https://en.cppreference.com/w/cpp/algorithm/adjacent_find</a> </p>

</div>
</div>
<a id="gac76b028bf28233ada520a5bc0d52f6b9" name="gac76b028bf28233ada520a5bc0d52f6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac76b028bf28233ada520a5bc0d52f6b9">&#9670;&#160;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::all_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for all elements in the range <code>[first, last)</code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="array_8cpp-example.html#a0">array.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga1d4122ca9a611ac90a64ff447c212a42" name="ga1d4122ca9a611ac90a64ff447c212a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d4122ca9a611ac90a64ff447c212a42">&#9670;&#160;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::any_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for at least one element in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ga8844708a6931fb2b21419d7a605328dd" name="ga8844708a6931fb2b21419d7a605328dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8844708a6931fb2b21419d7a605328dd">&#9670;&#160;</a></span>binary_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::binary_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an element equivalent to value appears within the range <code>[first, last)</code>. For binary_search to succeed, the range <code>[first, last)</code> must be at least partially ordered with respect to <code>value</code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a> </p>

</div>
</div>
<a id="ga46270726b5073fd6eeefb5ccd9ed1f72" name="ga46270726b5073fd6eeefb5ccd9ed1f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46270726b5073fd6eeefb5ccd9ed1f72">&#9670;&#160;</a></span>bubble_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::bubble_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. </p>
<p><a href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a> </p>

</div>
</div>
<a id="gabfa416a307b0bb33666d34845c42ba2b" name="gabfa416a307b0bb33666d34845c42ba2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfa416a307b0bb33666d34845c42ba2b">&#9670;&#160;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values. </p>

</div>
</div>
<a id="gad3271ee1abafc543f4bf69cc20b01ded" name="gad3271ee1abafc543f4bf69cc20b01ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3271ee1abafc543f4bf69cc20b01ded">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination. </p>
<p>Copies all elements in the range <code>[first, last)</code> starting from first and proceeding to <code>last - 1</code>. The behavior is undefined if destination is within the range <code>[first, last)</code>. In this case, copy_backward may be used instead. </p><dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element copied. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="array_8cpp-example.html#a2">array.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaf5caeb0f954aff0eb31c350558f7e827" name="gaf5caeb0f954aff0eb31c350558f7e827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5caeb0f954aff0eb31c350558f7e827">&#9670;&#160;</a></span>copy_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::copy_backward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt2</a></td>          <td class="paramname"><span class="paramname"><em>dLast</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range, defined by <code>[first, last)</code>, to another range ending at <code>dLast</code>. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved. </p>
<p>The behavior is undefined if <code>dLast</code> is within <code>(first, last]</code>. copy must be used instead of copy_backward in that case.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the last element copied. </dd></dl>

</div>
</div>
<a id="ga31799054ecdf344760efe76af7987776" name="ga31799054ecdf344760efe76af7987776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31799054ecdf344760efe76af7987776">&#9670;&#160;</a></span>copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Pred</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::copy_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutIt</a></td>          <td class="paramname"><span class="paramname"><em>dFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Pred</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination. </p>
<p>Only copies the elements for which the predicate pred returns true. The relative order of the elements that are copied is preserved. The behavior is undefined if the source and the destination ranges overlap. </p><dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element copied. </dd></dl>

</div>
</div>
<a id="gaa65063d9f87cd088156f3d49bb32f2e5" name="gaa65063d9f87cd088156f3d49bb32f2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa65063d9f87cd088156f3d49bb32f2e5">&#9670;&#160;</a></span>copy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::copy_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer <code>0 &lt;= i &lt; count</code>, performs <code>*(result + i) = *(first + i)</code>. Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator in the destination range, pointing past the last element copied if count&gt;0 or result otherwise. </dd></dl>

</div>
</div>
<a id="ga7aff5cc5281436a205079dc71ee4c317" name="ga7aff5cc5281436a205079dc71ee4c317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aff5cc5281436a205079dc71ee4c317">&#9670;&#160;</a></span>count_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::count_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt</a>&gt;::difference_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts elements for which predicate p returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">p</td><td>Unary predicate which returns ​true for the required elements.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a> </p>

</div>
</div>
<a id="ga4fe91c66e3042bde20710111a8d622e4" name="ga4fe91c66e3042bde20710111a8d622e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fe91c66e3042bde20710111a8d622e4">&#9670;&#160;</a></span>adjacent_find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::adjacent_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gadb446f356892ac1d540180018a20faba" name="gadb446f356892ac1d540180018a20faba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb446f356892ac1d540180018a20faba">&#9670;&#160;</a></span>binary_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::binary_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1cc149eb7abea4405c02e767e7860dae" name="ga1cc149eb7abea4405c02e767e7860dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc149eb7abea4405c02e767e7860dae">&#9670;&#160;</a></span>bubble_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::bubble_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf90379160c94dc0396b5f32204c790bf" name="gaf90379160c94dc0396b5f32204c790bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf90379160c94dc0396b5f32204c790bf">&#9670;&#160;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hi</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
