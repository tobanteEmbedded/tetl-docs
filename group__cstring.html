<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: cstring</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tetl<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__cstring.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">cstring <div class="ingroups"><a class="el" href="group__strings-library.html">Strings Library</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Various narrow character string handling functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6501c033d3d1fb4f31edb55e05dfb864" id="r_ga6501c033d3d1fb4f31edb55e05dfb864"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6501c033d3d1fb4f31edb55e05dfb864">memcmp</a> (void const *lhs, void const *rhs, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; int</td></tr>
<tr class="memdesc:ga6501c033d3d1fb4f31edb55e05dfb864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterprets the objects pointed to by lhs and rhs as arrays of unsigned char and compares the first count bytes of these arrays. The comparison is done lexicographically.  <br /></td></tr>
<tr class="memitem:gaafeb4c0affd826ba14f5bf3039c84812" id="r_gaafeb4c0affd826ba14f5bf3039c84812"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaafeb4c0affd826ba14f5bf3039c84812">memcpy</a> (void *dest, void const *src, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:gaafeb4c0affd826ba14f5bf3039c84812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="#gad85a137d45d955fd74c76657306b19c1" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead.  <br /></td></tr>
<tr class="memitem:gad85a137d45d955fd74c76657306b19c1" id="r_gad85a137d45d955fd74c76657306b19c1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad85a137d45d955fd74c76657306b19c1">memmove</a> (void *dest, void const *src, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; void *</td></tr>
<tr class="memdesc:gad85a137d45d955fd74c76657306b19c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap.  <br /></td></tr>
<tr class="memitem:gaf2b88ca84d198104e49ac2bd09977c45" id="r_gaf2b88ca84d198104e49ac2bd09977c45"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf2b88ca84d198104e49ac2bd09977c45">memset</a> (void *s, int c, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:gaf2b88ca84d198104e49ac2bd09977c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the value of c (converted to an unsigned char) into each of the ﬁrst n characters of the object pointed to by s.  <br /></td></tr>
<tr class="memitem:ga7ba9f37919984fde4ba2013e83086f80" id="r_ga7ba9f37919984fde4ba2013e83086f80"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7ba9f37919984fde4ba2013e83086f80">strcat</a> (char *dest, char const *src) noexcept -&gt; char *</td></tr>
<tr class="memdesc:ga7ba9f37919984fde4ba2013e83086f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the character string pointed to by src to the end of the character string pointed to by dest. The character src[0] replaces the null terminator at the end of dest. The resulting byte string is null-terminated.  <br /></td></tr>
<tr class="memitem:gaa03c96c75f1fa5b4153f1dab9148fd34" id="r_gaa03c96c75f1fa5b4153f1dab9148fd34"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa03c96c75f1fa5b4153f1dab9148fd34">strcmp</a> (char const *lhs, char const *rhs) -&gt; int</td></tr>
<tr class="memdesc:gaa03c96c75f1fa5b4153f1dab9148fd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the C string lhs to the C string rhs.  <br /></td></tr>
<tr class="memitem:gac458fbcee97fcd2a801b23b1a05587f8" id="r_gac458fbcee97fcd2a801b23b1a05587f8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac458fbcee97fcd2a801b23b1a05587f8">strcpy</a> (char *dest, char const *src) -&gt; char *</td></tr>
<tr class="memdesc:gac458fbcee97fcd2a801b23b1a05587f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the character string pointed to by src, including the null terminator, to the character array whose first element is pointed to by dest.  <br /></td></tr>
<tr class="memitem:gaf0cb449a1f27e32af89154ce5d4b31dc" id="r_gaf0cb449a1f27e32af89154ce5d4b31dc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf0cb449a1f27e32af89154ce5d4b31dc">strcspn</a> (char const *dest, char const *src) noexcept -&gt; <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:gaf0cb449a1f27e32af89154ce5d4b31dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the byte string pointed to by dest, that consists of only the characters not found in byte string pointed to by src.  <br /></td></tr>
<tr class="memitem:ga847c7fe27bc536cdf5109074b14e81d7" id="r_ga847c7fe27bc536cdf5109074b14e81d7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga847c7fe27bc536cdf5109074b14e81d7">strlen</a> (char const *str) -&gt; <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:ga847c7fe27bc536cdf5109074b14e81d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the C string str.  <br /></td></tr>
<tr class="memitem:ga3f875253fd9982757bdb90f84284322c" id="r_ga3f875253fd9982757bdb90f84284322c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f875253fd9982757bdb90f84284322c">strncat</a> (char *dest, char const *src, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> const <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; char *</td></tr>
<tr class="memdesc:ga3f875253fd9982757bdb90f84284322c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a byte string pointed to by src to a byte string pointed to by dest. At most count characters are copied. The resulting byte string is null-terminated.  <br /></td></tr>
<tr class="memitem:ga715682839cad49dfea265072062c75fe" id="r_ga715682839cad49dfea265072062c75fe"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga715682839cad49dfea265072062c75fe">strncmp</a> (char const *lhs, char const *rhs, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; int</td></tr>
<tr class="memdesc:ga715682839cad49dfea265072062c75fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares at most count characters of two possibly null-terminated arrays. The comparison is done lexicographically. Characters following the null character are not compared.  <br /></td></tr>
<tr class="memitem:ga50d78828452384f88828ac39373bdb7f" id="r_ga50d78828452384f88828ac39373bdb7f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50d78828452384f88828ac39373bdb7f">strncpy</a> (char *dest, char const *src, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> const <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; char *</td></tr>
<tr class="memdesc:ga50d78828452384f88828ac39373bdb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies at most count characters of the byte string pointed to by src (including the terminating null character) to character array pointed to by dest.  <br /></td></tr>
<tr class="memitem:gae4f31dcdd10129882c6856b848a0ca8f" id="r_gae4f31dcdd10129882c6856b848a0ca8f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae4f31dcdd10129882c6856b848a0ca8f">strspn</a> (char const *dest, char const *src) noexcept -&gt; <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:gae4f31dcdd10129882c6856b848a0ca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment (span) of the byte string pointed to by dest, that consists of only the characters found in byte string pointed to by src.  <br /></td></tr>
<tr class="memitem:gabe3560744264a5bf3038cd7744b9968e" id="r_gabe3560744264a5bf3038cd7744b9968e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabe3560744264a5bf3038cd7744b9968e">memchr</a> (void *ptr, int ch, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:gabe3560744264a5bf3038cd7744b9968e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr.  <br /></td></tr>
<tr class="memitem:ga8db7edd253bf76b92a7ebeb8afad8ef3" id="r_ga8db7edd253bf76b92a7ebeb8afad8ef3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8db7edd253bf76b92a7ebeb8afad8ef3">memchr</a> (void const *ptr, int ch, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> n) -&gt; void const *</td></tr>
<tr class="memdesc:ga8db7edd253bf76b92a7ebeb8afad8ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr.  <br /></td></tr>
<tr class="memitem:ga6fca1e170d91ea2b0901d41ccb3f4ef6" id="r_ga6fca1e170d91ea2b0901d41ccb3f4ef6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6fca1e170d91ea2b0901d41ccb3f4ef6">strchr</a> (char const *str, int ch) -&gt; char const *</td></tr>
<tr class="memdesc:ga6fca1e170d91ea2b0901d41ccb3f4ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="memitem:ga1ab0d635f5b2d4f2b9cfceec2c41c373" id="r_ga1ab0d635f5b2d4f2b9cfceec2c41c373"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ab0d635f5b2d4f2b9cfceec2c41c373">strchr</a> (char *str, int ch) -&gt; char *</td></tr>
<tr class="memdesc:ga1ab0d635f5b2d4f2b9cfceec2c41c373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="memitem:ga41a1eddfb9d029d0710fd07afafcf1fb" id="r_ga41a1eddfb9d029d0710fd07afafcf1fb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga41a1eddfb9d029d0710fd07afafcf1fb">strpbrk</a> (char const *dest, char const *breakset) noexcept -&gt; char const *</td></tr>
<tr class="memdesc:ga41a1eddfb9d029d0710fd07afafcf1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character.  <br /></td></tr>
<tr class="memitem:ga042c917008dbbbd4e10d144f2b8153bf" id="r_ga042c917008dbbbd4e10d144f2b8153bf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga042c917008dbbbd4e10d144f2b8153bf">strpbrk</a> (char *dest, char *breakset) noexcept -&gt; char *</td></tr>
<tr class="memdesc:ga042c917008dbbbd4e10d144f2b8153bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character.  <br /></td></tr>
<tr class="memitem:ga70ad1e9ee68483c83ab85fec3c3bc098" id="r_ga70ad1e9ee68483c83ab85fec3c3bc098"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga70ad1e9ee68483c83ab85fec3c3bc098">strrchr</a> (char const *str, int ch) noexcept -&gt; char const *</td></tr>
<tr class="memdesc:ga70ad1e9ee68483c83ab85fec3c3bc098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="memitem:ga9044fb8ace92be15f8af4d7bf6afa524" id="r_ga9044fb8ace92be15f8af4d7bf6afa524"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9044fb8ace92be15f8af4d7bf6afa524">strrchr</a> (char *str, int ch) noexcept -&gt; char *</td></tr>
<tr class="memdesc:ga9044fb8ace92be15f8af4d7bf6afa524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="memitem:gab1553928b9c7f3cb2b4232652f7a8883" id="r_gab1553928b9c7f3cb2b4232652f7a8883"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab1553928b9c7f3cb2b4232652f7a8883">strstr</a> (char *haystack, char *needle) noexcept -&gt; char *</td></tr>
<tr class="memdesc:gab1553928b9c7f3cb2b4232652f7a8883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="memitem:ga3af5da7af9b58ac38ff5d4da3ff5434b" id="r_ga3af5da7af9b58ac38ff5d4da3ff5434b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3af5da7af9b58ac38ff5d4da3ff5434b">strstr</a> (char const *haystack, char const *needle) noexcept -&gt; char const *</td></tr>
<tr class="memdesc:ga3af5da7af9b58ac38ff5d4da3ff5434b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Various narrow character string handling functions. </p>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gabe3560744264a5bf3038cd7744b9968e" name="gabe3560744264a5bf3038cd7744b9968e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe3560744264a5bf3038cd7744b9968e">&#9670;&#160;</a></span>memchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto memchr </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; void*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr. </p>
<p>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by ptr is smaller than count, but the match is found within the array, the behavior is well-defined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/memchr">https://en.cppreference.com/w/cpp/string/byte/memchr</a></p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the location of the character, or a null pointer if no such character is found. </dd></dl>

</div>
</div>
<a id="ga8db7edd253bf76b92a7ebeb8afad8ef3" name="ga8db7edd253bf76b92a7ebeb8afad8ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8db7edd253bf76b92a7ebeb8afad8ef3">&#9670;&#160;</a></span>memchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto memchr </td>
          <td>(</td>
          <td class="paramtype">void const *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; void const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr. </p>
<p>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by ptr is smaller than count, but the match is found within the array, the behavior is well-defined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/memchr">https://en.cppreference.com/w/cpp/string/byte/memchr</a></p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the location of the character, or a null pointer if no such character is found. </dd></dl>

</div>
</div>
<a id="ga6501c033d3d1fb4f31edb55e05dfb864" name="ga6501c033d3d1fb4f31edb55e05dfb864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6501c033d3d1fb4f31edb55e05dfb864">&#9670;&#160;</a></span>memcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto memcmp </td>
          <td>(</td>
          <td class="paramtype">void const *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterprets the objects pointed to by lhs and rhs as arrays of unsigned char and compares the first count bytes of these arrays. The comparison is done lexicographically. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/memcmp">https://en.cppreference.com/w/cpp/string/byte/memcmp</a> </p>

</div>
</div>
<a id="gaafeb4c0affd826ba14f5bf3039c84812" name="gaafeb4c0affd826ba14f5bf3039c84812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafeb4c0affd826ba14f5bf3039c84812">&#9670;&#160;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto memcpy </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; void*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="#gad85a137d45d955fd74c76657306b19c1" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead. </p>

</div>
</div>
<a id="gad85a137d45d955fd74c76657306b19c1" name="gad85a137d45d955fd74c76657306b19c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad85a137d45d955fd74c76657306b19c1">&#9670;&#160;</a></span>memmove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto memmove </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; void*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap. </p>

</div>
</div>
<a id="gaf2b88ca84d198104e49ac2bd09977c45" name="gaf2b88ca84d198104e49ac2bd09977c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2b88ca84d198104e49ac2bd09977c45">&#9670;&#160;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto memset </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; void*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the value of c (converted to an unsigned char) into each of the ﬁrst n characters of the object pointed to by s. </p>

</div>
</div>
<a id="ga7ba9f37919984fde4ba2013e83086f80" name="ga7ba9f37919984fde4ba2013e83086f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ba9f37919984fde4ba2013e83086f80">&#9670;&#160;</a></span>strcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strcat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of the character string pointed to by src to the end of the character string pointed to by dest. The character src[0] replaces the null terminator at the end of dest. The resulting byte string is null-terminated. </p>
<p>The behavior is undefined if the destination array is not large enough for the contents of both src and dest and the terminating null character. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="ga1ab0d635f5b2d4f2b9cfceec2c41c373" name="ga1ab0d635f5b2d4f2b9cfceec2c41c373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ab0d635f5b2d4f2b9cfceec2c41c373">&#9670;&#160;</a></span>strchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strchr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strchr">https://en.cppreference.com/w/cpp/string/byte/strchr</a> </p>

</div>
</div>
<a id="ga6fca1e170d91ea2b0901d41ccb3f4ef6" name="ga6fca1e170d91ea2b0901d41ccb3f4ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fca1e170d91ea2b0901d41ccb3f4ef6">&#9670;&#160;</a></span>strchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strchr </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; char const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strchr">https://en.cppreference.com/w/cpp/string/byte/strchr</a> </p>

</div>
</div>
<a id="gaa03c96c75f1fa5b4153f1dab9148fd34" name="gaa03c96c75f1fa5b4153f1dab9148fd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa03c96c75f1fa5b4153f1dab9148fd34">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strcmp </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the C string lhs to the C string rhs. </p>
<p>This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached. </p>

</div>
</div>
<a id="gac458fbcee97fcd2a801b23b1a05587f8" name="gac458fbcee97fcd2a801b23b1a05587f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac458fbcee97fcd2a801b23b1a05587f8">&#9670;&#160;</a></span>strcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strcpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the character string pointed to by src, including the null terminator, to the character array whose first element is pointed to by dest. </p>
<p>The behavior is undefined if the dest array is not large enough. The behavior is undefined if the strings overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="gaf0cb449a1f27e32af89154ce5d4b31dc" name="gaf0cb449a1f27e32af89154ce5d4b31dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0cb449a1f27e32af89154ce5d4b31dc">&#9670;&#160;</a></span>strcspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strcspn </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment of the byte string pointed to by dest, that consists of only the characters not found in byte string pointed to by src. </p>
<p>The function name stands for "complementary span"</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strcspn">https://en.cppreference.com/w/cpp/string/byte/strcspn</a> </p>

</div>
</div>
<a id="ga847c7fe27bc536cdf5109074b14e81d7" name="ga847c7fe27bc536cdf5109074b14e81d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga847c7fe27bc536cdf5109074b14e81d7">&#9670;&#160;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strlen </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the C string str. </p>

</div>
</div>
<a id="ga3f875253fd9982757bdb90f84284322c" name="ga3f875253fd9982757bdb90f84284322c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f875253fd9982757bdb90f84284322c">&#9670;&#160;</a></span>strncat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strncat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> const</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a byte string pointed to by src to a byte string pointed to by dest. At most count characters are copied. The resulting byte string is null-terminated. </p>
<p>The destination byte string must have enough space for the contents of both dest and src plus the terminating null character, except that the size of src is limited to count. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="ga715682839cad49dfea265072062c75fe" name="ga715682839cad49dfea265072062c75fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga715682839cad49dfea265072062c75fe">&#9670;&#160;</a></span>strncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strncmp </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares at most count characters of two possibly null-terminated arrays. The comparison is done lexicographically. Characters following the null character are not compared. </p>
<p>The behavior is undefined when access occurs past the end of either array lhs or rhs. The behavior is undefined when either lhs or rhs is the null pointer. </p>

</div>
</div>
<a id="ga50d78828452384f88828ac39373bdb7f" name="ga50d78828452384f88828ac39373bdb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50d78828452384f88828ac39373bdb7f">&#9670;&#160;</a></span>strncpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strncpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a> const</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies at most count characters of the byte string pointed to by src (including the terminating null character) to character array pointed to by dest. </p>
<p>If count is reached before the entire string src was copied, the resulting character array is not null-terminated. If, after copying the terminating null character from src, count is not reached, additional null characters are written to dest until the total of count characters have been written. If the strings overlap, the behavior is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="ga042c917008dbbbd4e10d144f2b8153bf" name="ga042c917008dbbbd4e10d144f2b8153bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga042c917008dbbbd4e10d144f2b8153bf">&#9670;&#160;</a></span>strpbrk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strpbrk </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>breakset</em></span>&#160;) -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strpbrk">https://en.cppreference.com/w/cpp/string/byte/strpbrk</a> </p>

</div>
</div>
<a id="ga41a1eddfb9d029d0710fd07afafcf1fb" name="ga41a1eddfb9d029d0710fd07afafcf1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a1eddfb9d029d0710fd07afafcf1fb">&#9670;&#160;</a></span>strpbrk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strpbrk </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>breakset</em></span>&#160;) -&gt; char const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strpbrk">https://en.cppreference.com/w/cpp/string/byte/strpbrk</a> </p>

</div>
</div>
<a id="ga9044fb8ace92be15f8af4d7bf6afa524" name="ga9044fb8ace92be15f8af4d7bf6afa524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9044fb8ace92be15f8af4d7bf6afa524">&#9670;&#160;</a></span>strrchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strrchr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strrchr">https://en.cppreference.com/w/cpp/string/byte/strrchr</a> </p>

</div>
</div>
<a id="ga70ad1e9ee68483c83ab85fec3c3bc098" name="ga70ad1e9ee68483c83ab85fec3c3bc098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70ad1e9ee68483c83ab85fec3c3bc098">&#9670;&#160;</a></span>strrchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strrchr </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; char const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strrchr">https://en.cppreference.com/w/cpp/string/byte/strrchr</a> </p>

</div>
</div>
<a id="gae4f31dcdd10129882c6856b848a0ca8f" name="gae4f31dcdd10129882c6856b848a0ca8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4f31dcdd10129882c6856b848a0ca8f">&#9670;&#160;</a></span>strspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strspn </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment (span) of the byte string pointed to by dest, that consists of only the characters found in byte string pointed to by src. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strspn">https://en.cppreference.com/w/cpp/string/byte/strspn</a> </p>

</div>
</div>
<a id="gab1553928b9c7f3cb2b4232652f7a8883" name="gab1553928b9c7f3cb2b4232652f7a8883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1553928b9c7f3cb2b4232652f7a8883">&#9670;&#160;</a></span>strstr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strstr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;) -&gt; char*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared. </p>

</div>
</div>
<a id="ga3af5da7af9b58ac38ff5d4da3ff5434b" name="ga3af5da7af9b58ac38ff5d4da3ff5434b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3af5da7af9b58ac38ff5d4da3ff5434b">&#9670;&#160;</a></span>strstr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto strstr </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;) -&gt; char const*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on <span class="timestamp"></span> for tetl by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
