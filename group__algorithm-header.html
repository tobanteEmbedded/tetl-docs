<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: algorithm.hpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tetl
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__algorithm-header.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">algorithm.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#ga09c5b412c05c58fb89e569a2d72ed17e">etl::adjacent_find</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate pred) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p.  <a href="group__algorithm-header.html#ga09c5b412c05c58fb89e569a2d72ed17e">More...</a><br /></td></tr>
<tr class="separator:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76b028bf28233ada520a5bc0d52f6b9"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:gac76b028bf28233ada520a5bc0d52f6b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gac76b028bf28233ada520a5bc0d52f6b9">etl::all_of</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:gac76b028bf28233ada520a5bc0d52f6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for all elements in the range <code>[first, last)</code>.  <a href="group__algorithm-header.html#gac76b028bf28233ada520a5bc0d52f6b9">More...</a><br /></td></tr>
<tr class="separator:gac76b028bf28233ada520a5bc0d52f6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d4122ca9a611ac90a64ff447c212a42"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga1d4122ca9a611ac90a64ff447c212a42"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#ga1d4122ca9a611ac90a64ff447c212a42">etl::any_of</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:ga1d4122ca9a611ac90a64ff447c212a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for at least one element in the range <code>[first, last)</code>.  <a href="group__algorithm-header.html#ga1d4122ca9a611ac90a64ff447c212a42">More...</a><br /></td></tr>
<tr class="separator:ga1d4122ca9a611ac90a64ff447c212a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8844708a6931fb2b21419d7a605328dd"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:ga8844708a6931fb2b21419d7a605328dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#ga8844708a6931fb2b21419d7a605328dd">etl::binary_search</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:ga8844708a6931fb2b21419d7a605328dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an element equivalent to value appears within the range <code>[first, last)</code>. For binary_search to succeed, the range <code>[first, last)</code> must be at least partially ordered with respect to <code>value</code>.  <a href="group__algorithm-header.html#ga8844708a6931fb2b21419d7a605328dd">More...</a><br /></td></tr>
<tr class="separator:ga8844708a6931fb2b21419d7a605328dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb446f356892ac1d540180018a20faba"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:gadb446f356892ac1d540180018a20faba"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gadb446f356892ac1d540180018a20faba">etl::binary_search</a> (ForwardIt first, ForwardIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, T const &amp;<a class="el" href="namespaceetl.html#a51c15a5d5f4ab487941035d024cad9d7">value</a>) -&gt; bool</td></tr>
<tr class="separator:gadb446f356892ac1d540180018a20faba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90379160c94dc0396b5f32204c790bf"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gaf90379160c94dc0396b5f32204c790bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gaf90379160c94dc0396b5f32204c790bf">etl::clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; Type const &amp;</td></tr>
<tr class="memdesc:gaf90379160c94dc0396b5f32204c790bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <a href="group__algorithm-header.html#gaf90379160c94dc0396b5f32204c790bf">More...</a><br /></td></tr>
<tr class="separator:gaf90379160c94dc0396b5f32204c790bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfa416a307b0bb33666d34845c42ba2b"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:gabfa416a307b0bb33666d34845c42ba2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gabfa416a307b0bb33666d34845c42ba2b">etl::clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi, Compare comp) -&gt; Type const &amp;</td></tr>
<tr class="separator:gabfa416a307b0bb33666d34845c42ba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3271ee1abafc543f4bf69cc20b01ded"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:gad3271ee1abafc543f4bf69cc20b01ded"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gad3271ee1abafc543f4bf69cc20b01ded">etl::copy</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:gad3271ee1abafc543f4bf69cc20b01ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <a href="group__algorithm-header.html#gad3271ee1abafc543f4bf69cc20b01ded">More...</a><br /></td></tr>
<tr class="separator:gad3271ee1abafc543f4bf69cc20b01ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5caeb0f954aff0eb31c350558f7e827"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt1 , typename BidirIt2 &gt; </td></tr>
<tr class="memitem:gaf5caeb0f954aff0eb31c350558f7e827"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gaf5caeb0f954aff0eb31c350558f7e827">etl::copy_backward</a> (BidirIt1 first, BidirIt1 <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, BidirIt2 dLast) -&gt; BidirIt2</td></tr>
<tr class="memdesc:gaf5caeb0f954aff0eb31c350558f7e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range, defined by <code>[first, last)</code>, to another range ending at <code>dLast</code>. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved.  <a href="group__algorithm-header.html#gaf5caeb0f954aff0eb31c350558f7e827">More...</a><br /></td></tr>
<tr class="separator:gaf5caeb0f954aff0eb31c350558f7e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31799054ecdf344760efe76af7987776"><td class="memTemplParams" colspan="2">template&lt;typename InIt , typename OutIt , typename Pred &gt; </td></tr>
<tr class="memitem:ga31799054ecdf344760efe76af7987776"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#ga31799054ecdf344760efe76af7987776">etl::copy_if</a> (InIt first, InIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, OutIt dFirst, Pred pred) -&gt; OutIt</td></tr>
<tr class="memdesc:ga31799054ecdf344760efe76af7987776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <a href="group__algorithm-header.html#ga31799054ecdf344760efe76af7987776">More...</a><br /></td></tr>
<tr class="separator:ga31799054ecdf344760efe76af7987776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Size , typename OutputIt &gt; </td></tr>
<tr class="memitem:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#gaa65063d9f87cd088156f3d49bb32f2e5">etl::copy_n</a> (InputIt first, <a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>, OutputIt result) -&gt; OutputIt</td></tr>
<tr class="memdesc:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer <code>0 &lt;= i &lt; count</code>, performs <code>*(result + i) = *(first + i)</code>. Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results.  <a href="group__algorithm-header.html#gaa65063d9f87cd088156f3d49bb32f2e5">More...</a><br /></td></tr>
<tr class="separator:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aff5cc5281436a205079dc71ee4c317"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga7aff5cc5281436a205079dc71ee4c317"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm-header.html#ga7aff5cc5281436a205079dc71ee4c317">etl::count_if</a> (InputIt first, InputIt <a class="el" href="namespaceetl.html#a5d5911bdc109e2c7265b7486da04e8b8">last</a>, Predicate p) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; InputIt &gt;::difference_type</td></tr>
<tr class="memdesc:ga7aff5cc5281436a205079dc71ee4c317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts elements for which predicate p returns true.  <a href="group__algorithm-header.html#ga7aff5cc5281436a205079dc71ee4c317">More...</a><br /></td></tr>
<tr class="separator:ga7aff5cc5281436a205079dc71ee4c317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="algorithm_8hpp.html">etl/algorithm.hpp</a>&gt;</span></div>
<div class="ttc" id="aalgorithm_8hpp_html"><div class="ttname"><a href="algorithm_8hpp.html">algorithm.hpp</a></div></div>
</div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a id="ga09c5b412c05c58fb89e569a2d72ed17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09c5b412c05c58fb89e569a2d72ed17e">&#9670;&nbsp;</a></span>adjacent_find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns ​true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_find">https://en.cppreference.com/w/cpp/algorithm/adjacent_find</a> </p>

</div>
</div>
<a id="gac76b028bf28233ada520a5bc0d52f6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac76b028bf28233ada520a5bc0d52f6b9">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::all_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for all elements in the range <code>[first, last)</code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="array_8cpp-example.html#a0">array.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga1d4122ca9a611ac90a64ff447c212a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d4122ca9a611ac90a64ff447c212a42">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::any_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for at least one element in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ga8844708a6931fb2b21419d7a605328dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8844708a6931fb2b21419d7a605328dd">&#9670;&nbsp;</a></span>binary_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::binary_search </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an element equivalent to value appears within the range <code>[first, last)</code>. For binary_search to succeed, the range <code>[first, last)</code> must be at least partially ordered with respect to <code>value</code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a> </p>

</div>
</div>
<a id="gaf90379160c94dc0396b5f32204c790bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf90379160c94dc0396b5f32204c790bf">&#9670;&nbsp;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::clamp </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values. </p>

</div>
</div>
<a id="gad3271ee1abafc543f4bf69cc20b01ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3271ee1abafc543f4bf69cc20b01ded">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copy </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination. </p>
<p>Copies all elements in the range <code>[first, last)</code> starting from first and proceeding to <code>last - 1</code>. The behavior is undefined if destination is within the range <code>[first, last)</code>. In this case, copy_backward may be used instead. </p><dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element copied. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="array_8cpp-example.html#a2">array.cpp</a>, <a class="el" href="string_8cpp-example.html#a2">string.cpp</a>, and <a class="el" href="vector_8cpp-example.html#a4">vector.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaf5caeb0f954aff0eb31c350558f7e827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5caeb0f954aff0eb31c350558f7e827">&#9670;&nbsp;</a></span>copy_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt1 , typename BidirIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copy_backward </td>
          <td>(</td>
          <td class="paramtype">BidirIt1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt2&#160;</td>
          <td class="paramname"><em>dLast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; BidirIt2
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range, defined by <code>[first, last)</code>, to another range ending at <code>dLast</code>. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved. </p>
<p>The behavior is undefined if <code>dLast</code> is within <code>(first, last]</code>. copy must be used instead of copy_backward in that case.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the last element copied. </dd></dl>

</div>
</div>
<a id="ga31799054ecdf344760efe76af7987776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31799054ecdf344760efe76af7987776">&#9670;&nbsp;</a></span>copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InIt , typename OutIt , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copy_if </td>
          <td>(</td>
          <td class="paramtype">InIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutIt&#160;</td>
          <td class="paramname"><em>dFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination. </p>
<p>Only copies the elements for which the predicate pred returns true. The relative order of the elements that are copied is preserved. The behavior is undefined if the source and the destination ranges overlap. </p><dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element copied. </dd></dl>

</div>
</div>
<a id="gaa65063d9f87cd088156f3d49bb32f2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa65063d9f87cd088156f3d49bb32f2e5">&#9670;&nbsp;</a></span>copy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Size , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copy_n </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#af9b15653958e67cfe944d92826719780">Size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer <code>0 &lt;= i &lt; count</code>, performs <code>*(result + i) = *(first + i)</code>. Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator in the destination range, pointing past the last element copied if count&gt;0 or result otherwise. </dd></dl>

</div>
</div>
<a id="ga7aff5cc5281436a205079dc71ee4c317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aff5cc5281436a205079dc71ee4c317">&#9670;&nbsp;</a></span>count_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::count_if </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;InputIt&gt;::difference_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts elements for which predicate p returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">p</td><td>Unary predicate which returns ​true for the required elements.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a> </p>

</div>
</div>
<a id="gadb446f356892ac1d540180018a20faba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb446f356892ac1d540180018a20faba">&#9670;&nbsp;</a></span>binary_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::binary_search </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gabfa416a307b0bb33666d34845c42ba2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfa416a307b0bb33666d34845c42ba2b">&#9670;&nbsp;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::clamp </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
