<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: etl::experimental::freertos::stream_buffer Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tetl<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structetl_1_1experimental_1_1freertos_1_1stream__buffer.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structetl_1_1experimental_1_1freertos_1_1stream__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">etl::experimental::freertos::stream_buffer Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Stream buffers are an RTOS task to RTOS task, and interrupt to task communication primitives. Unlike most other FreeRTOS communications primitives, they are optimised for single reader single writer scenarios, such as passing data from an interrupt service routine to a task, or from one microcontroller core to another on dual core CPUs. Data is passed by copy - the data is copied into the buffer by the sender and out of the buffer by the read.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stream__buffer_8hpp_source.html">stream_buffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa1cf720df2bd7a271e68b124466e6b52" id="r_aa1cf720df2bd7a271e68b124466e6b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a> = <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">etl::size_t</a></td></tr>
<tr class="separator:aa1cf720df2bd7a271e68b124466e6b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89422ef0666e5e5b51d74b44ac76505e" id="r_a89422ef0666e5e5b51d74b44ac76505e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89422ef0666e5e5b51d74b44ac76505e">stream_buffer</a> (<a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a> <a class="el" href="namespaceetl.html#af3008e042f920b06e2a67b1aa31a1803">size</a>, <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a> <a class="el" href="structetl_1_1static__vector.html">triggerLevel</a>) noexcept</td></tr>
<tr class="memdesc:a89422ef0666e5e5b51d74b44ac76505e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new stream buffer using dynamically allocated memory.  <br /></td></tr>
<tr class="separator:a89422ef0666e5e5b51d74b44ac76505e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b1a64d2a5bde9c16a8f9fecd8ffb92" id="r_ad8b1a64d2a5bde9c16a8f9fecd8ffb92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8b1a64d2a5bde9c16a8f9fecd8ffb92">~stream_buffer</a> () noexcept</td></tr>
<tr class="memdesc:ad8b1a64d2a5bde9c16a8f9fecd8ffb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a stream buffer, then the allocated memory is freed.  <br /></td></tr>
<tr class="separator:ad8b1a64d2a5bde9c16a8f9fecd8ffb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742211507585ea688b027bf8969f16ed" id="r_a742211507585ea688b027bf8969f16ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a742211507585ea688b027bf8969f16ed">stream_buffer</a> (<a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">other</a>)=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:a742211507585ea688b027bf8969f16ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0047c66fb9fc44745a9c1701297d2dc" id="r_ac0047c66fb9fc44745a9c1701297d2dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0047c66fb9fc44745a9c1701297d2dc">operator=</a> (<a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">other</a>) -&gt; <a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> &amp;=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:ac0047c66fb9fc44745a9c1701297d2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20063099e4f2292537e34a005d7b164a" id="r_a20063099e4f2292537e34a005d7b164a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20063099e4f2292537e34a005d7b164a">stream_buffer</a> (<a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">other</a>)=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:a20063099e4f2292537e34a005d7b164a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9f63900d2689879b44ee02ffe1098b" id="r_a2a9f63900d2689879b44ee02ffe1098b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a9f63900d2689879b44ee02ffe1098b">operator=</a> (<a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">other</a>) -&gt; <a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> &amp;=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:a2a9f63900d2689879b44ee02ffe1098b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a0c8e5535960cdb9b6685f766e6767" id="r_ac2a0c8e5535960cdb9b6685f766e6767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2a0c8e5535960cdb9b6685f766e6767">write</a> (<a class="el" href="structetl_1_1experimental_1_1net_1_1const__buffer.html">net::const_buffer</a> <a class="el" href="namespaceetl.html#a259846a061a975e4b40bc6f370701ac6">data</a>, <a class="el" href="stubs_8hpp.html#a7a499be6ab5cca64bfdc5c0c7c1805ca">TickType_t</a> <a class="el" href="structetl_1_1static__vector.html">ticks</a>) -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td></tr>
<tr class="memdesc:ac2a0c8e5535960cdb9b6685f766e6767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends bytes to a stream buffer. The bytes are copied into the stream buffer.  <br /></td></tr>
<tr class="separator:ac2a0c8e5535960cdb9b6685f766e6767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e62c30b455974f992cf318a816f3dd9" id="r_a2e62c30b455974f992cf318a816f3dd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e62c30b455974f992cf318a816f3dd9">write_from_isr</a> (<a class="el" href="structetl_1_1experimental_1_1net_1_1const__buffer.html">net::const_buffer</a> <a class="el" href="namespaceetl.html#a259846a061a975e4b40bc6f370701ac6">data</a>, <a class="el" href="stubs_8hpp.html#a2d7fc630e89911cbf80c510f0b1a3e9c">BaseType_t</a> *<a class="el" href="structetl_1_1static__vector.html">prio</a>) -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td></tr>
<tr class="memdesc:a2e62c30b455974f992cf318a816f3dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt safe version of the API function that sends a stream of bytes to the stream buffer.  <br /></td></tr>
<tr class="separator:a2e62c30b455974f992cf318a816f3dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1175fc5bec14169c5fcf2adb92986e15" id="r_a1175fc5bec14169c5fcf2adb92986e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1175fc5bec14169c5fcf2adb92986e15">read</a> (<a class="el" href="structetl_1_1experimental_1_1net_1_1mutable__buffer.html">net::mutable_buffer</a> <a class="el" href="namespaceetl.html#a259846a061a975e4b40bc6f370701ac6">data</a>, <a class="el" href="stubs_8hpp.html#a7a499be6ab5cca64bfdc5c0c7c1805ca">TickType_t</a> <a class="el" href="structetl_1_1static__vector.html">ticks</a>) -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td></tr>
<tr class="memdesc:a1175fc5bec14169c5fcf2adb92986e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives bytes from a stream buffer.  <br /></td></tr>
<tr class="separator:a1175fc5bec14169c5fcf2adb92986e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2d217e98d172990b5e1e9dffe64bbc" id="r_a9d2d217e98d172990b5e1e9dffe64bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d2d217e98d172990b5e1e9dffe64bbc">read_from_isr</a> (<a class="el" href="structetl_1_1experimental_1_1net_1_1mutable__buffer.html">net::mutable_buffer</a> <a class="el" href="namespaceetl.html#a259846a061a975e4b40bc6f370701ac6">data</a>, <a class="el" href="stubs_8hpp.html#a2d7fc630e89911cbf80c510f0b1a3e9c">BaseType_t</a> *<a class="el" href="structetl_1_1static__vector.html">prio</a>) -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td></tr>
<tr class="memdesc:a9d2d217e98d172990b5e1e9dffe64bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives bytes from a stream buffer.  <br /></td></tr>
<tr class="separator:a9d2d217e98d172990b5e1e9dffe64bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67041a34f6cc2d2be387b695c3267d5" id="r_ab67041a34f6cc2d2be387b695c3267d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab67041a34f6cc2d2be387b695c3267d5">empty</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ab67041a34f6cc2d2be387b695c3267d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a stream buffer to see if it is empty. A stream buffer is empty if it does not contain any data.  <br /></td></tr>
<tr class="separator:ab67041a34f6cc2d2be387b695c3267d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee237dccdea20b58f73f14667684b7a0" id="r_aee237dccdea20b58f73f14667684b7a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee237dccdea20b58f73f14667684b7a0">full</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aee237dccdea20b58f73f14667684b7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a stream buffer to see if it is full. A stream buffer is full if it does not have any free space, and therefore cannot accept any more data.  <br /></td></tr>
<tr class="separator:aee237dccdea20b58f73f14667684b7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a777340ddb9c01ea3d397f171392c40" id="r_a1a777340ddb9c01ea3d397f171392c40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a777340ddb9c01ea3d397f171392c40">bytes_available</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td></tr>
<tr class="memdesc:a1a777340ddb9c01ea3d397f171392c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a stream buffer to see how much data it contains, which is equal to the number of bytes that can be read from the stream buffer before the stream buffer would be empty.  <br /></td></tr>
<tr class="separator:a1a777340ddb9c01ea3d397f171392c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa99cbb0a38ef4d58eb8cfa2bdb73c1" id="r_a6fa99cbb0a38ef4d58eb8cfa2bdb73c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fa99cbb0a38ef4d58eb8cfa2bdb73c1">space_available</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td></tr>
<tr class="memdesc:a6fa99cbb0a38ef4d58eb8cfa2bdb73c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a stream buffer to see how much free space it contains, which is equal to the amount of data that can be sent to the stream buffer before it is full.  <br /></td></tr>
<tr class="separator:a6fa99cbb0a38ef4d58eb8cfa2bdb73c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f8f5c6aab705412be06bbc6eb006df" id="r_a81f8f5c6aab705412be06bbc6eb006df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81f8f5c6aab705412be06bbc6eb006df">reset</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a81f8f5c6aab705412be06bbc6eb006df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a stream buffer to its initial, empty, state. Any data that was in the stream buffer is discarded. A stream buffer can only be reset if there are no tasks blocked waiting to either send to or receive from the stream buffer.  <br /></td></tr>
<tr class="separator:a81f8f5c6aab705412be06bbc6eb006df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdda76f14ff325fb5b420ec6ede07993" id="r_afdda76f14ff325fb5b420ec6ede07993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdda76f14ff325fb5b420ec6ede07993">trigger_level</a> (<a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a> <a class="el" href="structetl_1_1static__vector.html">triggerLevel</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:afdda76f14ff325fb5b420ec6ede07993"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream buffer's trigger level is the number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state.  <br /></td></tr>
<tr class="separator:afdda76f14ff325fb5b420ec6ede07993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad3797dcdb12dc7827fa905674227f8" id="r_aaad3797dcdb12dc7827fa905674227f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad3797dcdb12dc7827fa905674227f8">native_handle</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="stubs_8hpp.html#a1d78f7e28aedae7857e0251fc89ef950">StreamBufferHandle_t</a></td></tr>
<tr class="memdesc:aaad3797dcdb12dc7827fa905674227f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the native FreeRTOS handle to the <a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html" title="Stream buffers are an RTOS task to RTOS task, and interrupt to task communication primitives....">stream_buffer</a>.  <br /></td></tr>
<tr class="separator:aaad3797dcdb12dc7827fa905674227f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stream buffers are an RTOS task to RTOS task, and interrupt to task communication primitives. Unlike most other FreeRTOS communications primitives, they are optimised for single reader single writer scenarios, such as passing data from an interrupt service routine to a task, or from one microcontroller core to another on dual core CPUs. Data is passed by copy - the data is copied into the buffer by the sender and out of the buffer by the read. </p>
<p><a href="https://www.freertos.org/RTOS-stream-buffer-API.html">https://www.freertos.org/RTOS-stream-buffer-API.html</a> <a href="https://www.freertos.org/RTOS-stream-message-buffers.html">https://www.freertos.org/RTOS-stream-message-buffers.html</a> </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa1cf720df2bd7a271e68b124466e6b52" name="aa1cf720df2bd7a271e68b124466e6b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cf720df2bd7a271e68b124466e6b52">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">etl::experimental::freertos::stream_buffer::size_type</a> = <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">etl::size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a89422ef0666e5e5b51d74b44ac76505e" name="a89422ef0666e5e5b51d74b44ac76505e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89422ef0666e5e5b51d74b44ac76505e">&#9670;&#160;</a></span>stream_buffer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">etl::experimental::freertos::stream_buffer::stream_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td>          <td class="paramname"><span class="paramname"><em>triggerLevel</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new stream buffer using dynamically allocated memory. </p>
<p><a href="https://www.freertos.org/xStreamBufferCreate.html">https://www.freertos.org/xStreamBufferCreate.html</a> </p>

</div>
</div>
<a id="ad8b1a64d2a5bde9c16a8f9fecd8ffb92" name="ad8b1a64d2a5bde9c16a8f9fecd8ffb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b1a64d2a5bde9c16a8f9fecd8ffb92">&#9670;&#160;</a></span>~stream_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">etl::experimental::freertos::stream_buffer::~stream_buffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes a stream buffer, then the allocated memory is freed. </p>
<p><a href="https://www.freertos.org/vStreamBufferDelete.html">https://www.freertos.org/vStreamBufferDelete.html</a> </p>

</div>
</div>
<a id="a742211507585ea688b027bf8969f16ed" name="a742211507585ea688b027bf8969f16ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742211507585ea688b027bf8969f16ed">&#9670;&#160;</a></span>stream_buffer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">etl::experimental::freertos::stream_buffer::stream_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a20063099e4f2292537e34a005d7b164a" name="a20063099e4f2292537e34a005d7b164a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20063099e4f2292537e34a005d7b164a">&#9670;&#160;</a></span>stream_buffer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">etl::experimental::freertos::stream_buffer::stream_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac0047c66fb9fc44745a9c1701297d2dc" name="ac0047c66fb9fc44745a9c1701297d2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0047c66fb9fc44745a9c1701297d2dc">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> &amp;=<a class="el" href="structetl_1_1static__vector.html">delete</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a9f63900d2689879b44ee02ffe1098b" name="a2a9f63900d2689879b44ee02ffe1098b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9f63900d2689879b44ee02ffe1098b">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a> &amp;=<a class="el" href="structetl_1_1static__vector.html">delete</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2a0c8e5535960cdb9b6685f766e6767" name="ac2a0c8e5535960cdb9b6685f766e6767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a0c8e5535960cdb9b6685f766e6767">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1experimental_1_1net_1_1const__buffer.html">net::const_buffer</a></td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stubs_8hpp.html#a7a499be6ab5cca64bfdc5c0c7c1805ca">TickType_t</a></td>          <td class="paramname"><span class="paramname"><em>ticks</em></span>&#160;) -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends bytes to a stream buffer. The bytes are copied into the stream buffer. </p>
<p><a href="https://www.freertos.org/xStreamBufferSend.html">https://www.freertos.org/xStreamBufferSend.html</a> </p>

</div>
</div>
<a id="a2e62c30b455974f992cf318a816f3dd9" name="a2e62c30b455974f992cf318a816f3dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e62c30b455974f992cf318a816f3dd9">&#9670;&#160;</a></span>write_from_isr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::write_from_isr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1experimental_1_1net_1_1const__buffer.html">net::const_buffer</a></td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stubs_8hpp.html#a2d7fc630e89911cbf80c510f0b1a3e9c">BaseType_t</a> *</td>          <td class="paramname"><span class="paramname"><em>prio</em></span>&#160;) -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt safe version of the API function that sends a stream of bytes to the stream buffer. </p>
<p><a href="https://www.freertos.org/xStreamBufferSendFromISR.html">https://www.freertos.org/xStreamBufferSendFromISR.html</a> </p>

</div>
</div>
<a id="a1175fc5bec14169c5fcf2adb92986e15" name="a1175fc5bec14169c5fcf2adb92986e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1175fc5bec14169c5fcf2adb92986e15">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1experimental_1_1net_1_1mutable__buffer.html">net::mutable_buffer</a></td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stubs_8hpp.html#a7a499be6ab5cca64bfdc5c0c7c1805ca">TickType_t</a></td>          <td class="paramname"><span class="paramname"><em>ticks</em></span>&#160;) -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives bytes from a stream buffer. </p>
<p><a href="https://www.freertos.org/xStreamBufferReceive.html">https://www.freertos.org/xStreamBufferReceive.html</a> </p>

</div>
</div>
<a id="a9d2d217e98d172990b5e1e9dffe64bbc" name="a9d2d217e98d172990b5e1e9dffe64bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2d217e98d172990b5e1e9dffe64bbc">&#9670;&#160;</a></span>read_from_isr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::read_from_isr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1experimental_1_1net_1_1mutable__buffer.html">net::mutable_buffer</a></td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stubs_8hpp.html#a2d7fc630e89911cbf80c510f0b1a3e9c">BaseType_t</a> *</td>          <td class="paramname"><span class="paramname"><em>prio</em></span>&#160;) -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives bytes from a stream buffer. </p>
<p><a href="https://www.freertos.org/xStreamBufferReceiveFromISR.html">https://www.freertos.org/xStreamBufferReceiveFromISR.html</a> </p>

</div>
</div>
<a id="ab67041a34f6cc2d2be387b695c3267d5" name="ab67041a34f6cc2d2be387b695c3267d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67041a34f6cc2d2be387b695c3267d5">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries a stream buffer to see if it is empty. A stream buffer is empty if it does not contain any data. </p>
<p><a href="https://www.freertos.org/xStreamBufferIsEmpty.html">https://www.freertos.org/xStreamBufferIsEmpty.html</a> </p>

</div>
</div>
<a id="aee237dccdea20b58f73f14667684b7a0" name="aee237dccdea20b58f73f14667684b7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee237dccdea20b58f73f14667684b7a0">&#9670;&#160;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::full </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries a stream buffer to see if it is full. A stream buffer is full if it does not have any free space, and therefore cannot accept any more data. </p>
<p><a href="https://www.freertos.org/xStreamBufferIsFull.html">https://www.freertos.org/xStreamBufferIsFull.html</a> </p>

</div>
</div>
<a id="a1a777340ddb9c01ea3d397f171392c40" name="a1a777340ddb9c01ea3d397f171392c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a777340ddb9c01ea3d397f171392c40">&#9670;&#160;</a></span>bytes_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::bytes_available </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries a stream buffer to see how much data it contains, which is equal to the number of bytes that can be read from the stream buffer before the stream buffer would be empty. </p>
<p><a href="https://www.freertos.org/xStreamBufferBytesAvailable.html">https://www.freertos.org/xStreamBufferBytesAvailable.html</a> </p>

</div>
</div>
<a id="a6fa99cbb0a38ef4d58eb8cfa2bdb73c1" name="a6fa99cbb0a38ef4d58eb8cfa2bdb73c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa99cbb0a38ef4d58eb8cfa2bdb73c1">&#9670;&#160;</a></span>space_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::space_available </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries a stream buffer to see how much free space it contains, which is equal to the amount of data that can be sent to the stream buffer before it is full. </p>
<p><a href="https://www.freertos.org/xStreamBufferSpacesAvailable.html">https://www.freertos.org/xStreamBufferSpacesAvailable.html</a> </p>

</div>
</div>
<a id="a81f8f5c6aab705412be06bbc6eb006df" name="a81f8f5c6aab705412be06bbc6eb006df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f8f5c6aab705412be06bbc6eb006df">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a stream buffer to its initial, empty, state. Any data that was in the stream buffer is discarded. A stream buffer can only be reset if there are no tasks blocked waiting to either send to or receive from the stream buffer. </p>
<p><a href="https://www.freertos.org/xStreamBufferReset.html">https://www.freertos.org/xStreamBufferReset.html</a> </p>

</div>
</div>
<a id="afdda76f14ff325fb5b420ec6ede07993" name="afdda76f14ff325fb5b420ec6ede07993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdda76f14ff325fb5b420ec6ede07993">&#9670;&#160;</a></span>trigger_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::trigger_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa1cf720df2bd7a271e68b124466e6b52">size_type</a></td>          <td class="paramname"><span class="paramname"><em>triggerLevel</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A stream buffer's trigger level is the number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state. </p>
<p>For example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 1 then the task will be unblocked when a single byte is written to the buffer or the task's block time expires. As another example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 10 then the task will not be unblocked until the stream buffer contains at least 10 bytes or the task's block time expires. If a reading task's block time expires before the trigger level is reached then the task will still receive however many bytes are actually available. Setting a trigger level of 0 will result in a trigger level of 1 being used. It is not valid to specify a trigger level that is greater than the buffer size.</p>
<p><a href="https://www.freertos.org/xStreamBufferSetTriggerLevel.html">https://www.freertos.org/xStreamBufferSetTriggerLevel.html</a> </p>

</div>
</div>
<a id="aaad3797dcdb12dc7827fa905674227f8" name="aaad3797dcdb12dc7827fa905674227f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad3797dcdb12dc7827fa905674227f8">&#9670;&#160;</a></span>native_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::experimental::freertos::stream_buffer::native_handle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="stubs_8hpp.html#a1d78f7e28aedae7857e0251fc89ef950">StreamBufferHandle_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the native FreeRTOS handle to the <a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html" title="Stream buffers are an RTOS task to RTOS task, and interrupt to task communication primitives....">stream_buffer</a>. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/etl/experimental/freertos/<a class="el" href="stream__buffer_8hpp_source.html">stream_buffer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li><li class="navelem"><a class="el" href="namespaceetl_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="namespaceetl_1_1experimental_1_1freertos.html">freertos</a></li><li class="navelem"><a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html">stream_buffer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
