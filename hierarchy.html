<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: Class Hierarchy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tetl
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('hierarchy.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Class Hierarchy</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">This inheritance list is sorted roughly, but not completely, alphabetically:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span><span onclick="javascript:toggleLevel(3);">3</span><span onclick="javascript:toggleLevel(4);">4</span><span onclick="javascript:toggleLevel(5);">5</span><span onclick="javascript:toggleLevel(6);">6</span><span onclick="javascript:toggleLevel(7);">7</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1linalg_1_1accessor__conjugate.html" target="_self">etl::linalg::accessor_conjugate&lt; Accessor &gt;</a></td><td class="desc"></td></tr>
<tr id="row_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__const.html" target="_self">etl::add_const&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds const </td></tr>
<tr id="row_2_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__cv.html" target="_self">etl::add_cv&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds both const and volatile </td></tr>
<tr id="row_3_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__volatile.html" target="_self">etl::add_volatile&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds volatile </td></tr>
<tr id="row_4_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1adopt__lock__t.html" target="_self">etl::adopt_lock_t</a></td><td class="desc">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock </td></tr>
<tr id="row_5_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1aligned__storage.html" target="_self">etl::aligned_storage&lt; Len, Align &gt;</a></td><td class="desc">Provides the nested type type, which is a trivial standard-layout type suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align. The default value of Align is the most stringent (the largest) alignment requirement for any object whose size is at most Len. If the default value is not used, Align must be the value of alignof(T) for some type T, or the behavior is undefined </td></tr>
<tr id="row_6_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1aligned__union.html" target="_self">etl::aligned_union&lt; Len, Types &gt;</a></td><td class="desc">Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitable for use as uninitialized storage for an object of any of the types listed in Types. The size of the storage is at least Len. <a class="el" href="structetl_1_1aligned__union.html" title="Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitab...">aligned_union</a> also determines the strictest (largest) alignment requirement among all Types and makes it available as the constant alignment_value. If sizeof...(Types) == 0 or if any of the types in Types is not a complete object type, the behavior is undefined. It is implementation-defined whether any extended alignment is supported. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1aligned__union.html" title="Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitab...">aligned_union</a> is undefined </td></tr>
<tr id="row_7_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1allocator__arg__t.html" target="_self">etl::allocator_arg_t</a></td><td class="desc">Allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member functions of allocator-aware objects </td></tr>
<tr id="row_8_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1allocator__traits.html" target="_self">etl::allocator_traits&lt; Alloc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_9_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1array.html" target="_self">etl::array&lt; Type, Size &gt;</a></td><td class="desc">Array is a container that encapsulates fixed size arrays </td></tr>
<tr id="row_10_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1array.html" target="_self">etl::array&lt; etl::uint8_t, allocated_ &gt;</a></td><td class="desc"></td></tr>
<tr id="row_11_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1array.html" target="_self">etl::array&lt; value_type, Capacity+1 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_12_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1assert__msg.html" target="_self">etl::assert_msg</a></td><td class="desc">Payload for an assertion </td></tr>
<tr id="row_13_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1at.html" target="_self">etl::meta::at&lt; I, List &gt;</a></td><td class="desc"></td></tr>
<tr id="row_14_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1at_3_010_00_01list_3_01Head_00_01Tail_8_8_8_01_4_01_4.html" target="_self">etl::meta::at&lt; 0, list&lt; Head, Tail... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_15_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1at_3_01I_00_01list_3_01Head_00_01Tail_8_8_8_01_4_01_4.html" target="_self">etl::meta::at&lt; I, list&lt; Head, Tail... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_16_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1back__insert__iterator.html" target="_self">etl::back_insert_iterator&lt; Container &gt;</a></td><td class="desc">Etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was constructed. The container's push_back() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a no-op </td></tr>
<tr id="row_17_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__common__reference.html" target="_self">etl::basic_common_reference&lt; T, U, TQ, UQ &gt;</a></td><td class="desc">The class template <a class="el" href="structetl_1_1basic__common__reference.html" title="The class template basic_common_reference is a customization point that allows users to influence the...">basic_common_reference</a> is a customization point that allows users to influence the result of <a class="el" href="structetl_1_1common__reference.html" title="Determines the common reference type of the types T..., that is, the type to which all the types in T...">common_reference</a> for user-defined types (typically proxy references). The primary template is empty </td></tr>
<tr id="row_18_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__common__reference_3_01pair_3_01T1_00_01T2_01_4_00_01pair_3_01U1_00_01U2_01_4_00_01TQual_00_01UQual_01_4.html" target="_self">etl::basic_common_reference&lt; pair&lt; T1, T2 &gt;, pair&lt; U1, U2 &gt;, TQual, UQual &gt;</a></td><td class="desc"></td></tr>
<tr id="row_19_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__format__arg.html" target="_self">etl::basic_format_arg&lt; Context &gt;</a></td><td class="desc"></td></tr>
<tr id="row_20_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__format__args.html" target="_self">etl::basic_format_args&lt; Context &gt;</a></td><td class="desc"></td></tr>
<tr id="row_21_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__format__context.html" target="_self">etl::basic_format_context&lt; OutputIt, CharT &gt;</a></td><td class="desc">Provides access to formatting state consisting of the formatting arguments and the output iterator </td></tr>
<tr id="row_22_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__format__parse__context.html" target="_self">etl::basic_format_parse_context&lt; CharT &gt;</a></td><td class="desc"></td></tr>
<tr id="row_23_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__format__string.html" target="_self">etl::basic_format_string&lt; CharT, Args &gt;</a></td><td class="desc"></td></tr>
<tr id="row_24_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__static__string.html" target="_self">etl::basic_static_string&lt; CharT, Capacity, Traits &gt;</a></td><td class="desc">Basic_static_string class with fixed size capacity </td></tr>
<tr id="row_25_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__streambuf.html" target="_self">etl::basic_streambuf&lt; CharT, Capacity, Traits, Child &gt;</a></td><td class="desc"></td></tr>
<tr id="row_26_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_26_" class="arrow" onclick="toggleFolder('26_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__streambuf.html" target="_self">etl::basic_streambuf&lt; CharT, Capacity, Traits, basic_stringbuf&lt; CharT, Capacity, Traits &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_26_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__stringbuf.html" target="_self">etl::basic_stringbuf&lt; CharT, Capacity, Traits &gt;</a></td><td class="desc"></td></tr>
<tr id="row_27_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__string__view.html" target="_self">etl::basic_string_view&lt; CharType, Traits &gt;</a></td><td class="desc">The class template <a class="el" href="structetl_1_1basic__string__view.html" title="The class template basic_string_view describes an object that can refer to a constant contiguous sequ...">basic_string_view</a> describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. A typical implementation holds only two members: a pointer to constant CharType and a size </td></tr>
<tr id="row_28_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__string__view.html" target="_self">etl::basic_string_view&lt; CharT &gt;</a></td><td class="desc"></td></tr>
<tr id="row_29_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bernoulli__distribution.html" target="_self">etl::bernoulli_distribution</a></td><td class="desc"></td></tr>
<tr id="row_30_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1binary__t.html" target="_self">etl::binary_t</a></td><td class="desc"></td></tr>
<tr id="row_31_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__and.html" target="_self">etl::bit_and&lt; T &gt;</a></td><td class="desc">Function object for performing bitwise AND. Effectively calls operator&amp; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/bit_and">https://en.cppreference.com/w/cpp/utility/functional/bit_and</a> </td></tr>
<tr id="row_32_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__and_3_01void_01_4.html" target="_self">etl::bit_and&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_33_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__not.html" target="_self">etl::bit_not&lt; T &gt;</a></td><td class="desc">Function object for performing bitwise NOT. Effectively calls operator~ on type T </td></tr>
<tr id="row_34_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__not_3_01void_01_4.html" target="_self">etl::bit_not&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_35_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__or.html" target="_self">etl::bit_or&lt; T &gt;</a></td><td class="desc">Function object for performing bitwise OR. Effectively calls operator| on type T </td></tr>
<tr id="row_36_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__or_3_01void_01_4.html" target="_self">etl::bit_or&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_37_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__xor.html" target="_self">etl::bit_xor&lt; T &gt;</a></td><td class="desc">Function object for performing bitwise XOR. Effectively calls operator^ on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/bit_xor">https://en.cppreference.com/w/cpp/utility/functional/bit_xor</a> </td></tr>
<tr id="row_38_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__xor_3_01void_01_4.html" target="_self">etl::bit_xor&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_39_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bitset.html" target="_self">etl::bitset&lt; N &gt;</a></td><td class="desc">The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators </td></tr>
<tr id="row_40_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_40_" class="arrow" onclick="toggleFolder('40_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>bool_constant&lt;(R1::num *R2::den &gt; R2::num *R1::den)&gt;</b></td><td class="desc"></td></tr>
<tr id="row_40_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__greater.html" target="_self">etl::ratio_greater&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_41_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_41_" class="arrow" onclick="toggleFolder('41_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>bool_constant&lt;(R1::num *R2::den &gt;=R2::num *R1::den)&gt;</b></td><td class="desc"></td></tr>
<tr id="row_41_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__greater__equal.html" target="_self">etl::ratio_greater_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_42_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_42_" class="arrow" onclick="toggleFolder('42_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>bool_constant&lt;(R1::num *R2::den&lt; R2::num *R1::den)&gt;</b></td><td class="desc"></td></tr>
<tr id="row_42_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__less.html" target="_self">etl::ratio_less&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_43_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_43_" class="arrow" onclick="toggleFolder('43_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>bool_constant&lt;(R1::num *R2::den&lt;=R2::num *R1::den)&gt;</b></td><td class="desc"></td></tr>
<tr id="row_43_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__less__equal.html" target="_self">etl::ratio_less_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_44_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1char__traits.html" target="_self">etl::char_traits&lt; CharT &gt;</a></td><td class="desc">The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class is a traits class template that abstracts basic character and string operations for a given character type. The defined operation set is such that generic algorithms almost always can be implemented in terms of it. It is thus possible to use such algorithms with almost any possible character or string type, just by supplying a customized <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class. The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class template serves as a basis for explicit instantiations. The user can provide a specialization for any custom character types. Several specializations are defined for the standard character types. If an operation on traits emits an exception, the behavior is undefined </td></tr>
<tr id="row_45_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html" target="_self">etl::char_traits&lt; char &gt;</a></td><td class="desc">Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char </td></tr>
<tr id="row_46_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1char__traits_3_01wchar__t_01_4.html" target="_self">etl::char_traits&lt; wchar_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_47_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1linalg_1_1column__major__t.html" target="_self">etl::linalg::column_major_t</a></td><td class="desc"></td></tr>
<tr id="row_48_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_48_" class="arrow" onclick="toggleFolder('48_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::common_cmpcat_base&lt;(0U|...|(is_same_v&lt; Ts, strong_ordering &gt; ? 0U :is_same_v&lt; Ts, weak_ordering &gt; ? 4U :is_same_v&lt; Ts, partial_ordering &gt; ? 2U :1U))&gt;</b></td><td class="desc"></td></tr>
<tr id="row_48_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__comparison__category.html" target="_self">etl::common_comparison_category&lt; Ts &gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__reference.html" target="_self">etl::common_reference&lt; T &gt;</a></td><td class="desc">Determines the common reference type of the types T..., that is, the type to which all the types in T... can be converted or bound. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type. The behavior is undefined if any of the types in T... is an incomplete type other than (possibly cv-qualified) void </td></tr>
<tr id="row_50_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_50_" class="arrow" onclick="toggleFolder('50_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__reference.html" target="_self">etl::common_reference&lt; common_reference_t&lt; T1, T2 &gt;, R... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_50_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__reference_3_01T1_00_01T2_00_01R_8_8_8_01_4.html" target="_self">etl::common_reference&lt; T1, T2, R... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_51_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__reference_3_01T_01_4.html" target="_self">etl::common_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_52_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__reference_3_01T_00_01U_01_4.html" target="_self">etl::common_reference&lt; T, U &gt;</a></td><td class="desc"></td></tr>
<tr id="row_53_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__reference_3_4.html" target="_self">etl::common_reference&lt;&gt;</a></td><td class="desc"></td></tr>
<tr id="row_54_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type.html" target="_self">etl::common_type&lt; T &gt;</a></td><td class="desc">Determines the common type among all types <code>T...</code>, that is the type all <code>T...</code> can be implicitly converted to. If such a type exists, the member type names that type. Otherwise, there is no member type </td></tr>
<tr id="row_55_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01chrono_1_1durat4fc2dee09f301ff098a97ea2485d2b03.html" target="_self">etl::common_type&lt; chrono::duration&lt; Rep1, Period1 &gt;, chrono::duration&lt; Rep2, Period2 &gt; &gt;</a></td><td class="desc">Exposes the type named type, which is the common type of two etl::chrono::durations, whose period is the greatest common divisor of Period1 and Period2 </td></tr>
<tr id="row_56_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01chrono_1_1time__point_3_01Clock_00_01Duration1_01_4_00_01chrono_1_ca83745423d4bfe5bc518c116bc7e175.html" target="_self">etl::common_type&lt; chrono::time_point&lt; Clock, Duration1 &gt;, chrono::time_point&lt; Clock, Duration2 &gt; &gt;</a></td><td class="desc">Exposes the type named type, which is the common type of two chrono::time_points </td></tr>
<tr id="row_57_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type.html" target="_self">etl::common_type&lt; common_type&lt; T1, T2 &gt;::type, R... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_58_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_58_" class="arrow" onclick="toggleFolder('58_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type.html" target="_self">etl::common_type&lt; T, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_58_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01T_01_4.html" target="_self">etl::common_type&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_59_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_59_" class="arrow" onclick="toggleFolder('59_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::common_type_2_impl&lt; etl::decay_t&lt; T1 &gt;, etl::decay_t&lt; T2 &gt; &gt;</b></td><td class="desc"></td></tr>
<tr id="row_59_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_01_4.html" target="_self">etl::common_type&lt; T1, T2 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_60_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_60_" class="arrow" onclick="toggleFolder('60_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::common_type_multi_impl&lt; void, T1, T2, R... &gt;</b></td><td class="desc"></td></tr>
<tr id="row_60_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_00_01R_8_8_8_01_4.html" target="_self">etl::common_type&lt; T1, T2, R... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_61_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1compare__three__way__result.html" target="_self">etl::compare_three_way_result&lt; T, U &gt;</a></td><td class="desc"></td></tr>
<tr id="row_62_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1compare__three__way__result_3_01T_00_01U_01_4.html" target="_self">etl::compare_three_way_result&lt; T, U &gt;</a></td><td class="desc"></td></tr>
<tr id="row_63_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1complex.html" target="_self">etl::complex&lt; T &gt;</a></td><td class="desc">A complex number </td></tr>
<tr id="row_64_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1conditional.html" target="_self">etl::conditional&lt; B, T, F &gt;</a></td><td class="desc">Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false </td></tr>
<tr id="row_65_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1conditional_3_01false_00_01T_00_01F_01_4.html" target="_self">etl::conditional&lt; false, T, F &gt;</a></td><td class="desc"></td></tr>
<tr id="row_66_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_66_" class="arrow" onclick="toggleFolder('66_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::conditional_t</b></td><td class="desc"></td></tr>
<tr id="row_66_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1unwrap__ref__decay.html" target="_self">etl::unwrap_ref_decay&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_67_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1net_1_1const__buffer.html" target="_self">etl::experimental::net::const_buffer</a></td><td class="desc"></td></tr>
<tr id="row_68_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_68_" class="arrow" onclick="toggleFolder('68_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1const__where__expression.html" target="_self">etl::const_where_expression&lt; M, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_68_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1where__expression.html" target="_self">etl::where_expression&lt; M, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_69_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1const__where__expression.html" target="_self">etl::experimental::const_where_expression&lt; M, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_70_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1const__where__expression.html" target="_self">etl::experimental::parallelism_v2::const_where_expression&lt; M, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_71_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ranges_1_1construct__at__fn.html" target="_self">etl::ranges::construct_at_fn</a></td><td class="desc"></td></tr>
<tr id="row_72_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1contains.html" target="_self">etl::meta::contains&lt; Needle, Haystack &gt;</a></td><td class="desc"></td></tr>
<tr id="row_73_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1count.html" target="_self">etl::meta::count&lt; Needle, Haystack &gt;</a></td><td class="desc"></td></tr>
<tr id="row_74_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ranges_1_1dangling.html" target="_self">etl::ranges::dangling</a></td><td class="desc"></td></tr>
<tr id="row_75_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1day.html" target="_self">etl::chrono::day</a></td><td class="desc"></td></tr>
<tr id="row_76_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1decay.html" target="_self">etl::decay&lt; T &gt;</a></td><td class="desc">Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type T, removes cv-qualifiers, and defines the resulting type as the member typedef type </td></tr>
<tr id="row_77_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1simd__abi_1_1deduce.html" target="_self">etl::experimental::parallelism_v2::simd_abi::deduce&lt; T, N, Abis &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1default__accessor.html" target="_self">etl::default_accessor&lt; ElementType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_79_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1default__delete.html" target="_self">etl::default_delete&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_80_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1default__delete_3_01T_0f_0e_4.html" target="_self">etl::default_delete&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_81_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1default__searcher.html" target="_self">etl::default_searcher&lt; ForwardIter, Predicate &gt;</a></td><td class="desc">Default searcher. A class suitable for use with Searcher overload of <a class="el" href="namespaceetl.html#af39a57bc56c6f3c0bf94045777e9f274" title="Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range [first,...">etl::search</a> that delegates the search operation to the pre-C++17 standard library's <a class="el" href="namespaceetl.html#af39a57bc56c6f3c0bf94045777e9f274" title="Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range [first,...">etl::search</a> </td></tr>
<tr id="row_82_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1defer__lock__t.html" target="_self">etl::defer_lock_t</a></td><td class="desc">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock </td></tr>
<tr id="row_83_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ranges_1_1destroy__at__fn.html" target="_self">etl::ranges::destroy_at_fn</a></td><td class="desc"></td></tr>
<tr id="row_84_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ranges_1_1destroy__fn.html" target="_self">etl::ranges::destroy_fn</a></td><td class="desc"></td></tr>
<tr id="row_85_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1destroying__delete__t.html" target="_self">etl::destroying_delete_t</a></td><td class="desc">Tag type used to identify the destroying delete form of operator delete </td></tr>
<tr id="row_86_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1hardware_1_1mcp23017_1_1device.html" target="_self">etl::experimental::hardware::mcp23017::device&lt; Driver &gt;</a></td><td class="desc"></td></tr>
<tr id="row_87_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1div__t.html" target="_self">etl::div_t</a></td><td class="desc">Return type for div, ldiv, lldiv &amp; imaxdiv </td></tr>
<tr id="row_88_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1divides.html" target="_self">etl::divides&lt; T &gt;</a></td><td class="desc">Function object for performing division. Effectively calls operator/ on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/divides">https://en.cppreference.com/w/cpp/utility/functional/divides</a> </td></tr>
<tr id="row_89_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1divides_3_01void_01_4.html" target="_self">etl::divides&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_90_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1duration.html" target="_self">etl::chrono::duration&lt; Rep, Period &gt;</a></td><td class="desc">Class template <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> represents a time interval </td></tr>
<tr id="row_91_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1duration__values.html" target="_self">etl::chrono::duration_values&lt; Rep &gt;</a></td><td class="desc">The <a class="el" href="structetl_1_1chrono_1_1duration__values.html" title="The etl::chrono::duration_values type defines three common durations.">etl::chrono::duration_values</a> type defines three common durations </td></tr>
<tr id="row_92_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dynamic__array.html" target="_self">etl::dynamic_array&lt; T, Allocator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_93_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1element__aligned__tag.html" target="_self">etl::element_aligned_tag</a></td><td class="desc"></td></tr>
<tr id="row_94_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1element__aligned__tag.html" target="_self">etl::experimental::element_aligned_tag</a></td><td class="desc"></td></tr>
<tr id="row_95_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1element__aligned__tag.html" target="_self">etl::experimental::parallelism_v2::element_aligned_tag</a></td><td class="desc"></td></tr>
<tr id="row_96_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1empty__c__array.html" target="_self">etl::empty_c_array</a></td><td class="desc"></td></tr>
<tr id="row_97_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1enable__if.html" target="_self">etl::enable_if&lt; bool, Type &gt;</a></td><td class="desc">Define a member typedef only if a boolean constant is true </td></tr>
<tr id="row_98_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1enable__if_3_01true_00_01Type_01_4.html" target="_self">etl::enable_if&lt; true, Type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_99_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1equal__to.html" target="_self">etl::equal_to&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator== on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/equal_to">https://en.cppreference.com/w/cpp/utility/functional/equal_to</a> </td></tr>
<tr id="row_100_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1equal__to_3_01void_01_4.html" target="_self">etl::equal_to&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_101_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_101_" class="arrow" onclick="toggleFolder('101_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1exception.html" target="_self">etl::exception</a></td><td class="desc"></td></tr>
<tr id="row_101_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bad__function__call.html" target="_self">etl::bad_function_call</a></td><td class="desc"></td></tr>
<tr id="row_101_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bad__optional__access.html" target="_self">etl::bad_optional_access</a></td><td class="desc">Defines a type of object to be thrown by <a class="el" href="structetl_1_1optional.html#acd491ba0eadd7e069af95df1e99d591d" title="If *this contains a value, returns a reference to the contained value. Otherwise, raises a etl::bad_o...">etl::optional::value</a> when accessing an optional object that does not contain a value </td></tr>
<tr id="row_101_2_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bad__variant__access.html" target="_self">etl::bad_variant_access</a></td><td class="desc">Etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get(etl::variant) called with an index or type that does not match the currently active alternative. (2) <a class="el" href="namespaceetl.html#aa43fcb4942d4cec1824f6e38edce9981" title="Applies the visitor vis (Callable that can be called with any combination of types from variants) to ...">etl::visit</a> called to visit a variant that is valueless_by_exception </td></tr>
<tr id="row_101_3_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_101_3_" class="arrow" onclick="toggleFolder('101_3_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logic__error.html" target="_self">etl::logic_error</a></td><td class="desc"></td></tr>
<tr id="row_101_3_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1domain__error.html" target="_self">etl::domain_error</a></td><td class="desc"></td></tr>
<tr id="row_101_3_1_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1invalid__argument.html" target="_self">etl::invalid_argument</a></td><td class="desc"></td></tr>
<tr id="row_101_3_2_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1length__error.html" target="_self">etl::length_error</a></td><td class="desc"></td></tr>
<tr id="row_101_3_3_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1out__of__range.html" target="_self">etl::out_of_range</a></td><td class="desc"></td></tr>
<tr id="row_101_4_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_101_4_" class="arrow" onclick="toggleFolder('101_4_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1runtime__error.html" target="_self">etl::runtime_error</a></td><td class="desc"></td></tr>
<tr id="row_101_4_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1overflow__error.html" target="_self">etl::overflow_error</a></td><td class="desc"></td></tr>
<tr id="row_101_4_1_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1range__error.html" target="_self">etl::range_error</a></td><td class="desc"></td></tr>
<tr id="row_101_4_2_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1underflow__error.html" target="_self">etl::underflow_error</a></td><td class="desc"></td></tr>
<tr id="row_102_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1expected.html" target="_self">etl::expected&lt; T, E &gt;</a></td><td class="desc"></td></tr>
<tr id="row_103_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1linalg_1_1explicit__diagonal__t.html" target="_self">etl::linalg::explicit_diagonal_t</a></td><td class="desc"></td></tr>
<tr id="row_104_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extents.html" target="_self">etl::extents&lt; IndexType, Extents &gt;</a></td><td class="desc"></td></tr>
<tr id="row_105_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1flat__set.html" target="_self">etl::flat_set&lt; Key, Container, Compare &gt;</a></td><td class="desc">A <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a> is a container adaptor that provides an associative container interface that supports unique keys (contains at most one of each key value) and provides for fast retrieval of the keys themselves. <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a> supports random access iterators. Any sequence container supporting random access iteration can be used to instantiate <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a> </td></tr>
<tr id="row_106_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1freertos_1_1forever.html" target="_self">etl::experimental::freertos::forever</a></td><td class="desc">Runs the task loop forever </td></tr>
<tr id="row_107_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1format__to__n__result.html" target="_self">etl::format_to_n_result&lt; Out &gt;</a></td><td class="desc">Etl::format_to_n_result has no base classes, or members other than out, size and implicitly declared special member functions </td></tr>
<tr id="row_108_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter.html" target="_self">etl::formatter&lt; T, CharT &gt;</a></td><td class="desc">The enabled specializations of formatter define formatting rules for a given type. Enabled specializations meet the Formatter requirements </td></tr>
<tr id="row_109_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01char_01const_01_5_00_01char_01_4.html" target="_self">etl::formatter&lt; char const *, char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_110_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01char_00_01char_01_4.html" target="_self">etl::formatter&lt; char, char &gt;</a></td><td class="desc">Standard specializations for basic type char </td></tr>
<tr id="row_111_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01char_0fN_0e_00_01char_01_4.html" target="_self">etl::formatter&lt; char[N], char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_112_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01etl_1_1static__string_3_01Capacity_01_4_00_01char_01_4.html" target="_self">etl::formatter&lt; etl::static_string&lt; Capacity &gt;, char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_113_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01etl_1_1string__view_00_01char_01_4.html" target="_self">etl::formatter&lt; etl::string_view, char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_114_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01int_00_01char_01_4.html" target="_self">etl::formatter&lt; int, char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_115_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01long_01long_00_01char_01_4.html" target="_self">etl::formatter&lt; long long, char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_116_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01long_00_01char_01_4.html" target="_self">etl::formatter&lt; long, char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_117_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01short_00_01char_01_4.html" target="_self">etl::formatter&lt; short, char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_118_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01unsigned_01long_01long_00_01char_01_4.html" target="_self">etl::formatter&lt; unsigned long long, char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_119_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01unsigned_01long_00_01char_01_4.html" target="_self">etl::formatter&lt; unsigned long, char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_120_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01unsigned_01short_00_01char_01_4.html" target="_self">etl::formatter&lt; unsigned short, char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_121_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1formatter_3_01unsigned_00_01char_01_4.html" target="_self">etl::formatter&lt; unsigned, char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_122_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1from__chars__result.html" target="_self">etl::from_chars_result</a></td><td class="desc">Primitive numerical input conversion </td></tr>
<tr id="row_123_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1front__insert__iterator.html" target="_self">etl::front_insert_iterator&lt; Container &gt;</a></td><td class="desc">Front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it was constructed. The container's push_front() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> is a no-op </td></tr>
<tr id="row_124_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1full__extent__t.html" target="_self">etl::full_extent_t</a></td><td class="desc"></td></tr>
<tr id="row_125_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1function__ref.html" target="_self">etl::function_ref&lt; Signature &gt;</a></td><td class="desc">Non-owning view of a callable </td></tr>
<tr id="row_126_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_126_" class="arrow" onclick="toggleFolder('126_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::function_ref&lt; false, R(Args...)&gt;</b></td><td class="desc"></td></tr>
<tr id="row_126_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1function__ref_3_01R_07Args_8_8_8_08_4.html" target="_self">etl::function_ref&lt; R(Args...)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_127_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_127_" class="arrow" onclick="toggleFolder('127_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::function_ref&lt; true, R(Args...)&gt;</b></td><td class="desc"></td></tr>
<tr id="row_127_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1function__ref_3_01R_07Args_8_8_8_08_01noexcept_01_4.html" target="_self">etl::function_ref&lt; R(Args...) noexcept &gt;</a></td><td class="desc"></td></tr>
<tr id="row_128_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1hardware_1_1stm32_1_1gpio__memory__layout.html" target="_self">etl::experimental::hardware::stm32::gpio_memory_layout</a></td><td class="desc"></td></tr>
<tr id="row_129_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1greater.html" target="_self">etl::greater&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/greater">https://en.cppreference.com/w/cpp/utility/functional/greater</a> </td></tr>
<tr id="row_130_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1greater_3_01void_01_4.html" target="_self">etl::greater&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_131_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1greater__equal.html" target="_self">etl::greater_equal&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&gt;= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/greater_equal">https://en.cppreference.com/w/cpp/utility/functional/greater_equal</a> </td></tr>
<tr id="row_132_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1greater__equal_3_01void_01_4.html" target="_self">etl::greater_equal&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_133_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1half.html" target="_self">etl::half</a></td><td class="desc"></td></tr>
<tr id="row_134_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1basic__format__arg_1_1handle.html" target="_self">etl::basic_format_arg&lt; Context &gt;::handle</a></td><td class="desc"></td></tr>
<tr id="row_135_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash.html" target="_self">etl::hash&lt; T &gt;</a></td><td class="desc">Hash </td></tr>
<tr id="row_136_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01bool_01_4.html" target="_self">etl::hash&lt; bool &gt;</a></td><td class="desc"></td></tr>
<tr id="row_137_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01char_01_4.html" target="_self">etl::hash&lt; char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_138_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01char16__t_01_4.html" target="_self">etl::hash&lt; char16_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_139_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01char32__t_01_4.html" target="_self">etl::hash&lt; char32_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_140_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01char8__t_01_4.html" target="_self">etl::hash&lt; char8_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_141_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01double_01_4.html" target="_self">etl::hash&lt; double &gt;</a></td><td class="desc"></td></tr>
<tr id="row_142_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01etl_1_1nullptr__t_01_4.html" target="_self">etl::hash&lt; etl::nullptr_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_143_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01etl_1_1optional_3_01T_01_4_01_4.html" target="_self">etl::hash&lt; etl::optional&lt; T &gt; &gt;</a></td><td class="desc">The template specialization of <a class="el" href="structetl_1_1hash.html" title="hash">etl::hash</a> for the <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a> class allows users to obtain hashes of the values contained in optional objects </td></tr>
<tr id="row_144_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01float_01_4.html" target="_self">etl::hash&lt; float &gt;</a></td><td class="desc"></td></tr>
<tr id="row_145_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01int_01_4.html" target="_self">etl::hash&lt; int &gt;</a></td><td class="desc"></td></tr>
<tr id="row_146_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01long_01_4.html" target="_self">etl::hash&lt; long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_147_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01long_01double_01_4.html" target="_self">etl::hash&lt; long double &gt;</a></td><td class="desc"></td></tr>
<tr id="row_148_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01long_01long_01_4.html" target="_self">etl::hash&lt; long long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_149_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01short_01_4.html" target="_self">etl::hash&lt; short &gt;</a></td><td class="desc"></td></tr>
<tr id="row_150_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01signed_01char_01_4.html" target="_self">etl::hash&lt; signed char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_151_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01T_01_5_01_4.html" target="_self">etl::hash&lt; T * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_152_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01unsigned_01char_01_4.html" target="_self">etl::hash&lt; unsigned char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_153_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01unsigned_01int_01_4.html" target="_self">etl::hash&lt; unsigned int &gt;</a></td><td class="desc"></td></tr>
<tr id="row_154_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01unsigned_01long_01_4.html" target="_self">etl::hash&lt; unsigned long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_155_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01unsigned_01long_01long_01_4.html" target="_self">etl::hash&lt; unsigned long long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_156_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01unsigned_01short_01_4.html" target="_self">etl::hash&lt; unsigned short &gt;</a></td><td class="desc"></td></tr>
<tr id="row_157_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hash_3_01wchar__t_01_4.html" target="_self">etl::hash&lt; wchar_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_158_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1head.html" target="_self">etl::meta::head&lt; Ts &gt;</a></td><td class="desc"></td></tr>
<tr id="row_159_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1head_3_01list_3_01Head_00_01Tail_8_8_8_01_4_01_4.html" target="_self">etl::meta::head&lt; list&lt; Head, Tail... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_160_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1identity.html" target="_self">etl::identity</a></td><td class="desc">Etl::identity is a function object type whose operator() returns its argument unchanged </td></tr>
<tr id="row_161_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ignore.html" target="_self">etl::ignore</a></td><td class="desc">An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with <a class="el" href="namespaceetl.html#ada3ddae955d45b6a63298906227f2f60">etl::tie</a> when unpacking a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>, as a placeholder for the arguments that are not used </td></tr>
<tr id="row_162_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1imaxdiv__t.html" target="_self">etl::imaxdiv_t</a></td><td class="desc">Return type for div, ldiv, lldiv &amp; imaxdiv </td></tr>
<tr id="row_163_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1linalg_1_1implicit__unit__diagonal__t.html" target="_self">etl::linalg::implicit_unit_diagonal_t</a></td><td class="desc"></td></tr>
<tr id="row_164_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ranges_1_1in__fun__result.html" target="_self">etl::ranges::in_fun_result&lt; I, F &gt;</a></td><td class="desc"></td></tr>
<tr id="row_165_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1in__place__index__t.html" target="_self">etl::in_place_index_t&lt; I &gt;</a></td><td class="desc">Disambiguation tags that can be passed to the constructors of <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>, <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed </td></tr>
<tr id="row_166_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1in__place__t.html" target="_self">etl::in_place_t</a></td><td class="desc">Disambiguation tags that can be passed to the constructors of <code>optional</code>, <code>variant</code>, and <code>any</code> to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed </td></tr>
<tr id="row_167_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1in__place__type__t.html" target="_self">etl::in_place_type_t&lt; T &gt;</a></td><td class="desc">Disambiguation tags that can be passed to the constructors of <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>, <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed </td></tr>
<tr id="row_168_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1incrementable__traits.html" target="_self">etl::incrementable_traits&lt; I &gt;</a></td><td class="desc"></td></tr>
<tr id="row_169_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1incrementable__traits_3_01T_01_5_01_4.html" target="_self">etl::incrementable_traits&lt; T * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_170_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_170_" class="arrow" onclick="toggleFolder('170_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1incrementable__traits_3_01T_01_4.html" target="_self">etl::incrementable_traits&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_170_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1incrementable__traits_3_01T_01const_01_4.html" target="_self">etl::incrementable_traits&lt; T const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_171_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1indirectly__readable__traits.html" target="_self">etl::indirectly_readable_traits&lt; I &gt;</a></td><td class="desc"></td></tr>
<tr id="row_172_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1indirectly__readable__traits_3_01I_01_4.html" target="_self">etl::indirectly_readable_traits&lt; I &gt;</a></td><td class="desc"></td></tr>
<tr id="row_173_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1inplace__function.html" target="_self">etl::inplace_function&lt; Signature, Capacity, Alignment &gt;</a></td><td class="desc"></td></tr>
<tr id="row_174_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1inplace__function_3_01R_07Args_8_8_8_08_00_01Capacity_00_01Alignment_01_4.html" target="_self">etl::inplace_function&lt; R(Args...), Capacity, Alignment &gt;</a></td><td class="desc"></td></tr>
<tr id="row_175_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1inplace__vector.html" target="_self">etl::inplace_vector&lt; T, Capacity &gt;</a></td><td class="desc"></td></tr>
<tr id="row_176_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1inplace__vector_3_01T_00_010_01_4.html" target="_self">etl::inplace_vector&lt; T, 0 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_177_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_177_" class="arrow" onclick="toggleFolder('177_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1input__iterator__tag.html" target="_self">etl::input_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_177_0_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_177_0_" class="arrow" onclick="toggleFolder('177_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1forward__iterator__tag.html" target="_self">etl::forward_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_177_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_177_0_0_" class="arrow" onclick="toggleFolder('177_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bidirectional__iterator__tag.html" target="_self">etl::bidirectional_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_177_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_177_0_0_0_" class="arrow" onclick="toggleFolder('177_0_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1random__access__iterator__tag.html" target="_self">etl::random_access_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_177_0_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1contiguous__iterator__tag.html" target="_self">etl::contiguous_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_178_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integer__sequence.html" target="_self">etl::integer_sequence&lt; T, Ints &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_179_" class="arrow" onclick="toggleFolder('179_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; Type, Val &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_0_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_0_" class="arrow" onclick="toggleFolder('179_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_member_function_pointer_helper&lt; remove_cv_t&lt; T &gt; &gt;</b></td><td class="desc"></td></tr>
<tr id="row_179_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__member__function__pointer.html" target="_self">etl::is_member_function_pointer&lt; T &gt;</a></td><td class="desc">Checks whether T is a non-static member function pointer. Provides the member constant value which is equal to true, if T is a non-static member function pointer type. Otherwise, value is equal to false </td></tr>
<tr id="row_179_1_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_1_" class="arrow" onclick="toggleFolder('179_1_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_member_pointer_helper&lt; remove_cv_t&lt; T &gt; &gt;</b></td><td class="desc"></td></tr>
<tr id="row_179_1_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__member__pointer.html" target="_self">etl::is_member_pointer&lt; T &gt;</a></td><td class="desc">If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__member__pointer.html" title="If T is pointer to non-static member object or a pointer to non-static member function,...">is_member_pointer</a> or is_member_pointer_v (since C++17) is undefined </td></tr>
<tr id="row_179_2_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_2_" class="arrow" onclick="toggleFolder('179_2_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_pointer&lt; etl::remove_cv_t&lt; T &gt; &gt;</b></td><td class="desc"></td></tr>
<tr id="row_179_2_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__pointer.html" target="_self">etl::is_pointer&lt; T &gt;</a></td><td class="desc">Checks whether T is a pointer to object or a pointer to function (but not a pointer to member/member function). Provides the member constant value which is equal to true, if T is a object/function pointer type. Otherwise, value is equal to false </td></tr>
<tr id="row_179_3_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_3_" class="arrow" onclick="toggleFolder('179_3_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__assignable.html" target="_self">etl::is_assignable&lt; add_lvalue_reference_t&lt; T &gt;, add_rvalue_reference_t&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_3_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__move__assignable.html" target="_self">etl::is_move_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a> </td></tr>
<tr id="row_179_4_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_4_" class="arrow" onclick="toggleFolder('179_4_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__assignable.html" target="_self">etl::is_assignable&lt; add_lvalue_reference_t&lt; T &gt;, add_lvalue_reference_t&lt; T const &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_4_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__copy__assignable.html" target="_self">etl::is_copy_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T const&amp;&gt;::value</a> </td></tr>
<tr id="row_179_5_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_5_" class="arrow" onclick="toggleFolder('179_5_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__floating__point.html" target="_self">etl::is_floating_point&lt; Rep &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_5_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1treat__as__floating__point.html" target="_self">etl::chrono::treat_as_floating_point&lt; Rep &gt;</a></td><td class="desc">The <a class="el" href="structetl_1_1chrono_1_1treat__as__floating__point.html" title="The etl::chrono::treat_as_floating_point trait helps determine if a duration can be converted to anot...">etl::chrono::treat_as_floating_point</a> trait helps determine if a duration can be converted to another duration with a different tick period </td></tr>
<tr id="row_179_6_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_6_" class="arrow" onclick="toggleFolder('179_6_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__assignable.html" target="_self">etl::is_nothrow_assignable&lt; add_lvalue_reference_t&lt; T &gt;, add_rvalue_reference_t&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_6_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__move__assignable.html" target="_self">etl::is_nothrow_move_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a> </td></tr>
<tr id="row_179_7_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_7_" class="arrow" onclick="toggleFolder('179_7_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__assignable.html" target="_self">etl::is_nothrow_assignable&lt; add_lvalue_reference_t&lt; T &gt;, add_lvalue_reference_t&lt; T const &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_7_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__copy__assignable.html" target="_self">etl::is_nothrow_copy_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_assignable&lt;T&amp;, T const&amp;&gt;::value</a> </td></tr>
<tr id="row_179_8_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_8_" class="arrow" onclick="toggleFolder('179_8_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__same.html" target="_self">etl::is_same&lt; nullptr_t, remove_cv_t&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_8_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__null__pointer.html" target="_self">etl::is_null_pointer&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_9_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_9_" class="arrow" onclick="toggleFolder('179_9_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__same.html" target="_self">etl::is_same&lt; void, etl::remove_cv_t&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_9_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__void.html" target="_self">etl::is_void&lt; T &gt;</a></td><td class="desc">Define a member typedef only if a boolean constant is true </td></tr>
<tr id="row_179_10_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_10_" class="arrow" onclick="toggleFolder('179_10_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__assignable.html" target="_self">etl::is_trivially_assignable&lt; add_lvalue_reference_t&lt; T &gt;, add_rvalue_reference_t&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_10_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__move__assignable.html" target="_self">etl::is_trivially_move_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a> </td></tr>
<tr id="row_179_11_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_11_" class="arrow" onclick="toggleFolder('179_11_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__assignable.html" target="_self">etl::is_trivially_assignable&lt; add_lvalue_reference_t&lt; T &gt;, add_lvalue_reference_t&lt; T const &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_11_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__copy__assignable.html" target="_self">etl::is_trivially_copy_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_trivially_assignable&lt;T&amp;, T const&amp;&gt;::value</a> </td></tr>
<tr id="row_179_12_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_12_" class="arrow" onclick="toggleFolder('179_12_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__constructible.html" target="_self">etl::is_trivially_constructible&lt; T, add_lvalue_reference_t&lt; add_const_t&lt; T &gt; &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_12_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__copy__constructible.html" target="_self">etl::is_trivially_copy_constructible&lt; T &gt;</a></td><td class="desc">Same as copy, but uses etl::is_trivially_constructible&lt;T, T const&amp;&gt; </td></tr>
<tr id="row_179_13_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_13_" class="arrow" onclick="toggleFolder('179_13_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__constructible.html" target="_self">etl::is_trivially_constructible&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_13_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__default__constructible.html" target="_self">etl::is_trivially_default_constructible&lt; T &gt;</a></td><td class="desc">If <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_trivially_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false </td></tr>
<tr id="row_179_14_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_14_" class="arrow" onclick="toggleFolder('179_14_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__constructible.html" target="_self">etl::is_trivially_constructible&lt; T, etl::add_rvalue_reference_t&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_14_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__move__constructible.html" target="_self">etl::is_trivially_move_constructible&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</a> </td></tr>
<tr id="row_179_15_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1__swap__no__throw.html" target="_self">etl::_swap_no_throw&lt; T, U &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_16_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1__swappable__with__helper.html" target="_self">etl::_swappable_with_helper&lt; T, U, typename &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_17_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1__swappable__with__helper_3_01T_00_01U_00_01void__t_3_01decltype_07swap_07declval_3a85b88c6bbfa63467fd799de16a3d15b.html" target="_self">etl::_swappable_with_helper&lt; T, U, void_t&lt; decltype(swap(declval&lt; T &gt;(), declval&lt; U &gt;()))&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_18_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1is__clock.html" target="_self">etl::chrono::is_clock&lt; typename &gt;</a></td><td class="desc">If T satisfies the Clock requirements, provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_179_19_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1conjunction.html" target="_self">etl::conjunction&lt; B &gt;</a></td><td class="desc">Forms the logical conjunction of the type traits B..., effectively performing a logical AND on the sequence of traits </td></tr>
<tr id="row_179_20_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_20_" class="arrow" onclick="toggleFolder('179_20_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_constructible_helper&lt; typename, T, Args &gt;</b></td><td class="desc"></td></tr>
<tr id="row_179_20_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__copy__constructible.html" target="_self">etl::is_copy_constructible&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_constructible&lt;T, T const&amp;&gt;::value </td></tr>
<tr id="row_179_20_1_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__default__constructible.html" target="_self">etl::is_default_constructible&lt; T &gt;</a></td><td class="desc">If etl::is_constructible&lt;T&gt;::value is true, provides the member constant value equal to true, otherwise value is false </td></tr>
<tr id="row_179_20_2_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__move__constructible.html" target="_self">etl::is_move_constructible&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_constructible&lt;T, T&amp;&amp;&gt;::value </td></tr>
<tr id="row_179_21_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_179_21_" class="arrow" onclick="toggleFolder('179_21_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_empty&lt; T &gt;</b></td><td class="desc"></td></tr>
<tr id="row_179_21_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__empty.html" target="_self">etl::is_empty&lt; T &gt;</a></td><td class="desc">F T is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant value equal to true. For any other type, value is false </td></tr>
<tr id="row_179_22_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1disjunction.html" target="_self">etl::disjunction&lt; B &gt;</a></td><td class="desc">Forms the logical disjunction of the type traits B..., effectively performing a logical OR on the sequence of traits </td></tr>
<tr id="row_179_23_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1has__unique__object__representations.html" target="_self">etl::has_unique_object_representations&lt; T &gt;</a></td><td class="desc">If T is TriviallyCopyable and if any two objects of type T with the same value have the same object representation, provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_179_24_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1has__virtual__destructor.html" target="_self">etl::has_virtual_destructor&lt; T &gt;</a></td><td class="desc">Https://en.cppreference.com/w/cpp/types/has_virtual_destructor </td></tr>
<tr id="row_179_25_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__abstract.html" target="_self">etl::is_abstract&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_26_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__aggregate.html" target="_self">etl::is_aggregate&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_27_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__any__of.html" target="_self">etl::is_any_of&lt; T, Types &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_28_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__arithmetic.html" target="_self">etl::is_arithmetic&lt; T &gt;</a></td><td class="desc">If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__arithmetic.html" title="If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified ver...">is_arithmetic</a> or is_arithmetic_v (since C++17) is undefined </td></tr>
<tr id="row_179_29_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__array.html" target="_self">etl::is_array&lt; T &gt;</a></td><td class="desc">Checks whether T is an array type. Provides the member constant value which is equal to true, if T is an array type. Otherwise, value is equal to false </td></tr>
<tr id="row_179_30_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__array_3_01T_0fN_0e_4.html" target="_self">etl::is_array&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_31_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__array_3_01T_0f_0e_4.html" target="_self">etl::is_array&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_32_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__assignable.html" target="_self">etl::is_assignable&lt; T, U &gt;</a></td><td class="desc">If the expression <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type </td></tr>
<tr id="row_179_33_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__base__of.html" target="_self">etl::is_base_of&lt; Base, Derived &gt;</a></td><td class="desc">If Derived is derived from Base or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant value equal to true. Otherwise value is false </td></tr>
<tr id="row_179_34_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__bitmask__type.html" target="_self">etl::is_bitmask_type&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_35_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__bounded__array.html" target="_self">etl::is_bounded_array&lt; T &gt;</a></td><td class="desc">Checks whether T is an array type of known bound. Provides the member constant value which is equal to true, if T is an array type of known bound. Otherwise, value is equal to false </td></tr>
<tr id="row_179_36_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__bounded__array_3_01T_0fN_0e_4.html" target="_self">etl::is_bounded_array&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_37_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__builtin__integer.html" target="_self">etl::is_builtin_integer&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_38_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__builtin__signed__integer.html" target="_self">etl::is_builtin_signed_integer&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_39_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__builtin__unsigned__integer.html" target="_self">etl::is_builtin_unsigned_integer&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_40_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__class.html" target="_self">etl::is_class&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_41_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__compound.html" target="_self">etl::is_compound&lt; T &gt;</a></td><td class="desc">If T is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_179_42_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__const.html" target="_self">etl::is_const&lt; T &gt;</a></td><td class="desc">If T is a const-qualified type (that is, const, or const volatile), provides the member constant value equal to true. For any other type, value is false </td></tr>
<tr id="row_179_43_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__const_3_01T_01const_01_4.html" target="_self">etl::is_const&lt; T const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_44_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__convertible.html" target="_self">etl::is_convertible&lt; From, To &gt;</a></td><td class="desc">If the imaginary function definition <code>To test() { return <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;From&gt;(); }</code> is well-formed, (that is, either <code><a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;From&gt;()</code> can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true. Otherwise value is false. For the purposes of this check, the use of <code><a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a></code> in the return statement is not considered an odr-use. Access checks are performed as if from a context unrelated to either type. Only the validity of the immediate context of the expression in the return statement (including conversions to the return type) is considered </td></tr>
<tr id="row_179_45_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__destructible_3_01Type_0f_0e_4.html" target="_self">etl::is_destructible&lt; Type[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_46_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__destructible_3_01void_01_4.html" target="_self">etl::is_destructible&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_47_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__enum.html" target="_self">etl::is_enum&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_48_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__error__condition__enum.html" target="_self">etl::is_error_condition_enum&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_49_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__error__condition__enum_3_01errc_01_4.html" target="_self">etl::is_error_condition_enum&lt; errc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_50_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__final.html" target="_self">etl::is_final&lt; T &gt;</a></td><td class="desc">If T is a final class (that is, a class declared with the final specifier), provides the member constant value equal true. For any other type, value is false. If T is a class type, T shall be a complete type; otherwise, the behavior is undefined </td></tr>
<tr id="row_179_51_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__floating__point.html" target="_self">etl::is_floating_point&lt; T &gt;</a></td><td class="desc">Checks whether T is a floating-point type. Provides the member constant value which is equal to true, if T is the type float, double, long double, including any cv-qualified variants. Otherwise, value is equal to false </td></tr>
<tr id="row_179_52_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__function.html" target="_self">etl::is_function&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_53_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__fundamental.html" target="_self">etl::is_fundamental&lt; T &gt;</a></td><td class="desc">If T is a fundamental type (that is, arithmetic type, void, or nullptr_t), provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_179_54_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__implicit__default__constructible.html" target="_self">etl::is_implicit_default_constructible&lt; T, typename, typename &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_55_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__implicit__default__constructible_3_01T_00_01decltype_07test__implicit__default_374fbed591f2848368bdbdd39f8c8e31.html" target="_self">etl::is_implicit_default_constructible&lt; T, decltype(test_implicit_default_constructible&lt; T const &amp; &gt;({})), false_type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_56_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__implicit__default__constructible_3_01T_00_01decltype_07test__implicit__default_63505ad1d5845f9b40fca2dabe8d3bef.html" target="_self">etl::is_implicit_default_constructible&lt; T, decltype(test_implicit_default_constructible&lt; T const &amp; &gt;({})), true_type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_57_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__integral.html" target="_self">etl::is_integral&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_58_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__invocable.html" target="_self">etl::is_invocable&lt; Fn, ArgTypes &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_59_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__invocable__r.html" target="_self">etl::is_invocable_r&lt; R, Fn, ArgTypes &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_60_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__lvalue__reference.html" target="_self">etl::is_lvalue_reference&lt; T &gt;</a></td><td class="desc">Checks whether T is a lvalue reference type. Provides the member constant value which is equal to true, if T is a lvalue reference type. Otherwise, value is equal to false </td></tr>
<tr id="row_179_61_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__lvalue__reference_3_01T_01_6_01_4.html" target="_self">etl::is_lvalue_reference&lt; T &amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_62_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__member__object__pointer.html" target="_self">etl::is_member_object_pointer&lt; T &gt;</a></td><td class="desc">Checks whether T is a non-static member object pointer. Provides the member constant value which is equal to true, if T is a non-static member object pointer type. Otherwise, value is equal to false </td></tr>
<tr id="row_179_63_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__assignable.html" target="_self">etl::is_nothrow_assignable&lt; T, U &gt;</a></td><td class="desc">If the expression <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type </td></tr>
<tr id="row_179_64_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__assignable_3_01T_00_01U_01_4.html" target="_self">etl::is_nothrow_assignable&lt; T, U &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_65_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__constructible.html" target="_self">etl::is_nothrow_constructible&lt; T, Args &gt;</a></td><td class="desc">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a> is considered trivial </td></tr>
<tr id="row_179_66_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__convertible.html" target="_self">etl::is_nothrow_convertible&lt; From, To &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_67_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__convertible_3_01From_00_01To_01_4.html" target="_self">etl::is_nothrow_convertible&lt; From, To &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_68_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_01_4.html" target="_self">etl::is_nothrow_destructible&lt; Type &amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_69_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_6_01_4.html" target="_self">etl::is_nothrow_destructible&lt; Type &amp;&amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_70_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__swappable__with.html" target="_self">etl::is_nothrow_swappable_with&lt; T, U &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_71_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__object.html" target="_self">etl::is_object&lt; T &gt;</a></td><td class="desc">If T is an object type (that is any possibly cv-qualified type other than function, reference, or void types), provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_179_72_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__polymorphic.html" target="_self">etl::is_polymorphic&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_73_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__reference.html" target="_self">etl::is_reference&lt; T &gt;</a></td><td class="desc">If T is a reference type (lvalue reference or rvalue reference), provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__reference.html" title="If T is a reference type (lvalue reference or rvalue reference), provides the member constant value e...">is_reference</a> or is_reference_v is undefined </td></tr>
<tr id="row_179_74_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__reference_3_01T_01_6_01_4.html" target="_self">etl::is_reference&lt; T &amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_75_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__reference_3_01T_01_6_6_01_4.html" target="_self">etl::is_reference&lt; T &amp;&amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_76_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__reference__wrapper.html" target="_self">etl::is_reference_wrapper&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_77_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__reference__wrapper_3_01reference__wrapper_3_01U_01_4_01_4.html" target="_self">etl::is_reference_wrapper&lt; reference_wrapper&lt; U &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_78_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__rvalue__reference.html" target="_self">etl::is_rvalue_reference&lt; T &gt;</a></td><td class="desc">Checks whether T is a rvalue reference type. Provides the member constant value which is equal to true, if T is a rvalue reference type. Otherwise, value is equal to false </td></tr>
<tr id="row_179_79_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__rvalue__reference_3_01T_01_6_6_01_4.html" target="_self">etl::is_rvalue_reference&lt; T &amp;&amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_80_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__same.html" target="_self">etl::is_same&lt; T, U &gt;</a></td><td class="desc">If T and U name the same type (taking into account const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false </td></tr>
<tr id="row_179_81_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__scalar.html" target="_self">etl::is_scalar&lt; T &gt;</a></td><td class="desc">If T is a scalar type (that is a possibly cv-qualified arithmetic, pointer, pointer to member, enumeration, or <a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> type), provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_179_82_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__scoped__enum.html" target="_self">etl::is_scoped_enum&lt; T, bool &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_83_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__scoped__enum_3_01T_00_01true_01_4.html" target="_self">etl::is_scoped_enum&lt; T, true &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_84_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__signed.html" target="_self">etl::is_signed&lt; T &gt;</a></td><td class="desc">If T is an arithmetic type, provides the member constant value equal to true if T(-1) &lt; T(0): this results in true for the floating-point types and the signed integer types, and in false for the unsigned integer types and the type bool. For any other type, value is false </td></tr>
<tr id="row_179_85_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__specialized.html" target="_self">etl::is_specialized&lt; typename, typename, typename &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_86_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__specialized_3_01Template_00_01T_00_01etl_1_1void__t_3_01decltype_07Template_3_01T_01_4_02_03_08_4_01_4.html" target="_self">etl::is_specialized&lt; Template, T, etl::void_t&lt; decltype(Template&lt; T &gt;{})&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_87_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__standard__layout.html" target="_self">etl::is_standard_layout&lt; T &gt;</a></td><td class="desc">If T is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false </td></tr>
<tr id="row_179_88_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__swappable__with.html" target="_self">etl::is_swappable_with&lt; T, U &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_89_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivial.html" target="_self">etl::is_trivial&lt; T &gt;</a></td><td class="desc">If T is TrivialType (that is, a scalar type, a trivially copyable class with a trivial default constructor, or array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false </td></tr>
<tr id="row_179_90_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__assignable.html" target="_self">etl::is_trivially_assignable&lt; T, U &gt;</a></td><td class="desc">If the expression <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type </td></tr>
<tr id="row_179_91_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__constructible.html" target="_self">etl::is_trivially_constructible&lt; T, Args &gt;</a></td><td class="desc">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a> is considered trivial </td></tr>
<tr id="row_179_92_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__copyable.html" target="_self">etl::is_trivially_copyable&lt; T &gt;</a></td><td class="desc">If T is a TriviallyCopyable type, provides the member constant value equal to true. For any other type, value is false. The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly cv-qualified). group is_trivial_copyable </td></tr>
<tr id="row_179_93_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__destructible.html" target="_self">etl::is_trivially_destructible&lt; T &gt;</a></td><td class="desc">Storage occupied by trivially destructible objects may be reused without calling the destructor </td></tr>
<tr id="row_179_94_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__unbounded__array.html" target="_self">etl::is_unbounded_array&lt; T &gt;</a></td><td class="desc">Checks whether T is an array type of unknown bound. Provides the member constant value which is equal to true, if T is an array type of unknown bound. Otherwise, value is equal to false </td></tr>
<tr id="row_179_95_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__unbounded__array_3_01T_0f_0e_4.html" target="_self">etl::is_unbounded_array&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_96_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__union.html" target="_self">etl::is_union&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_97_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__volatile.html" target="_self">etl::is_volatile&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_98_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__volatile_3_01T_01volatile_01_4.html" target="_self">etl::is_volatile&lt; T volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_99_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1contains_3_01Needle_00_01list_3_01Ts_8_8_8_01_4_01_4.html" target="_self">etl::meta::contains&lt; Needle, list&lt; Ts... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_179_100_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1negation.html" target="_self">etl::negation&lt; B &gt;</a></td><td class="desc">Forms the logical negation of the type trait B </td></tr>
<tr id="row_179_101_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__equal.html" target="_self">etl::ratio_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are equal, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_179_102_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__not__equal.html" target="_self">etl::ratio_not_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are not equal, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_179_103_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1uses__allocator.html" target="_self">etl::uses_allocator&lt; Type, Alloc &gt;</a></td><td class="desc">If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false </td></tr>
<tr id="row_180_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_180_" class="arrow" onclick="toggleFolder('180_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, 0 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_180_0_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_180_0_" class="arrow" onclick="toggleFolder('180_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent.html" target="_self">etl::extent&lt; T, N - 1 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_180_0_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent_3_01T_0fI_0e_00_01N_01_4.html" target="_self">etl::extent&lt; T[I], N &gt;</a></td><td class="desc"></td></tr>
<tr id="row_180_0_1_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent_3_01T_0f_0e_00_01N_01_4.html" target="_self">etl::extent&lt; T[], N &gt;</a></td><td class="desc"></td></tr>
<tr id="row_180_1_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent.html" target="_self">etl::extent&lt; T, N &gt;</a></td><td class="desc">If T is an array type, provides the member constant value equal to the number of elements along the Nth dimension of the array, if N is in [0, rank_v&lt;T&gt;). For any other type, or if T is an array of unknown bound along its first dimension and N is 0, value is 0 </td></tr>
<tr id="row_180_2_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent_3_01T_0f_0e_00_010_01_4.html" target="_self">etl::extent&lt; T[], 0 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_181_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_181_" class="arrow" onclick="toggleFolder('181_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, 2 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_181_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01etl_1_1complex_3_01T_01_4_01_4.html" target="_self">etl::tuple_size&lt; etl::complex&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_182_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_182_" class="arrow" onclick="toggleFolder('182_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, alignof(T)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_182_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1alignment__of.html" target="_self">etl::alignment_of&lt; T &gt;</a></td><td class="desc">Alignment_of </td></tr>
<tr id="row_183_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_183_" class="arrow" onclick="toggleFolder('183_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, I &gt;</a></td><td class="desc"></td></tr>
<tr id="row_183_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent_3_01T_0fI_0e_00_010_01_4.html" target="_self">etl::extent&lt; T[I], 0 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_184_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_184_" class="arrow" onclick="toggleFolder('184_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, sizeof...(Ts)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_184_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__size_3_01variant2_3_01Ts_8_8_8_01_4_01_4.html" target="_self">etl::variant_size&lt; variant2&lt; Ts... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_184_1_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__size_3_01variant_3_01Ts_8_8_8_01_4_01_4.html" target="_self">etl::variant_size&lt; variant&lt; Ts... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_185_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_185_" class="arrow" onclick="toggleFolder('185_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t,(etl::is_same_v&lt; Needle, Ts &gt;+...+0)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_185_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1count_3_01Needle_00_01list_3_01Ts_8_8_8_01_4_01_4.html" target="_self">etl::meta::count&lt; Needle, list&lt; Ts... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_186_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_186_" class="arrow" onclick="toggleFolder('186_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; int, 0 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_186_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__placeholder.html" target="_self">etl::is_placeholder&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_187_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; int, N &gt;</a></td><td class="desc"></td></tr>
<tr id="row_188_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_188_" class="arrow" onclick="toggleFolder('188_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; size_t, 0 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_188_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rank.html" target="_self">etl::rank&lt; T &gt;</a></td><td class="desc">If Type is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0. The behavior of a program that adds specializations for rank or rank_v is undefined </td></tr>
<tr id="row_189_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_189_" class="arrow" onclick="toggleFolder('189_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; size_t, 2 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_189_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html" target="_self">etl::tuple_size&lt; pair&lt; T1, T2 &gt; &gt;</a></td><td class="desc">The partial specialization of <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a> for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax </td></tr>
<tr id="row_190_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_190_" class="arrow" onclick="toggleFolder('190_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; size_t, N &gt;</a></td><td class="desc"></td></tr>
<tr id="row_190_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01array_3_01T_00_01N_01_4_01_4.html" target="_self">etl::tuple_size&lt; array&lt; T, N &gt; &gt;</a></td><td class="desc">Provides access to the number of elements in an array as a compile-time constant expression </td></tr>
<tr id="row_191_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_191_" class="arrow" onclick="toggleFolder('191_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; size_t, rank&lt; T &gt;::value+1 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_191_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rank_3_01T_0fN_0e_4.html" target="_self">etl::rank&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_191_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rank_3_01T_0f_0e_4.html" target="_self">etl::rank&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_192_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_192_" class="arrow" onclick="toggleFolder('192_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; size_t, sizeof...(Ts)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_192_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01tuple_3_01Ts_8_8_8_01_4_01_4.html" target="_self">etl::tuple_size&lt; tuple&lt; Ts... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_193_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_193_" class="arrow" onclick="toggleFolder('193_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; size_t, tuple_size&lt; T &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_193_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01T_01const_01_4.html" target="_self">etl::tuple_size&lt; T const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_193_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01T_01const_01volatile_01_4.html" target="_self">etl::tuple_size&lt; T const volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_193_2_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01T_01volatile_01_4.html" target="_self">etl::tuple_size&lt; T volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_194_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_194_" class="arrow" onclick="toggleFolder('194_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::invoke_result&lt; void, F, ArgTypes... &gt;</b></td><td class="desc"></td></tr>
<tr id="row_194_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1invoke__result.html" target="_self">etl::invoke_result&lt; F, ArgTypes &gt;</a></td><td class="desc">Deduces the return type of an INVOKE expression at compile time. F and all types in ArgTypes can be any complete type, array of unknown bound, or (possibly cv-qualified) void. The behavior of a program that adds specializations for any of the templates described on this page is undefined. This implementation is copied from <b>cppreference.com</b> </td></tr>
<tr id="row_195_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ios__base.html" target="_self">etl::ios_base</a></td><td class="desc"></td></tr>
<tr id="row_196_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1is__abi__tag.html" target="_self">etl::experimental::is_abi_tag&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_197_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1is__abi__tag.html" target="_self">etl::experimental::parallelism_v2::is_abi_tag&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_198_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_198_" class="arrow" onclick="toggleFolder('198_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_destructible_safe&lt; T, bool, bool &gt;</b></td><td class="desc"></td></tr>
<tr id="row_198_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__destructible.html" target="_self">etl::is_destructible&lt; T &gt;</a></td><td class="desc">Because the C++ program terminates if a destructor throws an exception during stack unwinding (which usually cannot be predicted), all practical destructors are non-throwing even if they are not declared noexcept. All destructors found in the C++ standard library are non-throwing </td></tr>
<tr id="row_199_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_199_" class="arrow" onclick="toggleFolder('199_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_nothrow_destructible_helper&lt; is_destructible_v&lt; Type &gt;, Type &gt;</b></td><td class="desc"></td></tr>
<tr id="row_199_0_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_199_0_" class="arrow" onclick="toggleFolder('199_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__destructible.html" target="_self">etl::is_nothrow_destructible&lt; Type &gt;</a></td><td class="desc">Https://en.cppreference.com/w/cpp/types/is_destructible </td></tr>
<tr id="row_199_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_0fN_0e_4.html" target="_self">etl::is_nothrow_destructible&lt; Type[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_200_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1is__simd.html" target="_self">etl::experimental::is_simd&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_201_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1is__simd.html" target="_self">etl::experimental::parallelism_v2::is_simd&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_202_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1is__simd__flag__type.html" target="_self">etl::experimental::is_simd_flag_type&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_203_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1is__simd__flag__type.html" target="_self">etl::experimental::parallelism_v2::is_simd_flag_type&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_204_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1is__simd__mask.html" target="_self">etl::experimental::is_simd_mask&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_205_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1is__simd__mask.html" target="_self">etl::experimental::parallelism_v2::is_simd_mask&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_206_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__typename.html" target="_self">etl::is_typename&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_207_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1hardware_1_1stm32_1_1isr.html" target="_self">etl::experimental::hardware::stm32::isr</a></td><td class="desc"></td></tr>
<tr id="row_208_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1iterator__traits_3_01T_01_5_01_4.html" target="_self">etl::iterator_traits&lt; T * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_209_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_209_" class="arrow" onclick="toggleFolder('209_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::iterator_traits_impl&lt; Iter, typename &gt;</b></td><td class="desc"></td></tr>
<tr id="row_209_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1iterator__traits.html" target="_self">etl::iterator_traits&lt; Iter &gt;</a></td><td class="desc">Iterator_traits is the type trait class that provides uniform interface to the properties of LegacyIterator types. This makes it possible to implement algorithms only in terms of iterators </td></tr>
<tr id="row_210_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1last__spec.html" target="_self">etl::chrono::last_spec</a></td><td class="desc">Last_spec is an empty tag type that is used in conjunction with other calendar types to indicate the last thing in a sequence </td></tr>
<tr id="row_211_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1layout__left.html" target="_self">etl::layout_left</a></td><td class="desc"></td></tr>
<tr id="row_212_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1layout__right.html" target="_self">etl::layout_right</a></td><td class="desc"></td></tr>
<tr id="row_213_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1layout__stride.html" target="_self">etl::layout_stride</a></td><td class="desc"></td></tr>
<tr id="row_214_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1linalg_1_1layout__transpose.html" target="_self">etl::linalg::layout_transpose&lt; Layout &gt;</a></td><td class="desc"></td></tr>
<tr id="row_215_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ldiv__t.html" target="_self">etl::ldiv_t</a></td><td class="desc">Return type for div, ldiv, lldiv &amp; imaxdiv </td></tr>
<tr id="row_216_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1less.html" target="_self">etl::less&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/less">https://en.cppreference.com/w/cpp/utility/functional/less</a> </td></tr>
<tr id="row_217_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1less.html" target="_self">etl::less&lt; Key &gt;</a></td><td class="desc"></td></tr>
<tr id="row_218_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1less_3_01void_01_4.html" target="_self">etl::less&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_219_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1less__equal.html" target="_self">etl::less_equal&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&lt;= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/less_equal">https://en.cppreference.com/w/cpp/utility/functional/less_equal</a> </td></tr>
<tr id="row_220_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1less__equal_3_01void_01_4.html" target="_self">etl::less_equal&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_221_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1list.html" target="_self">etl::meta::list&lt; Ts &gt;</a></td><td class="desc"></td></tr>
<tr id="row_222_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1lldiv__t.html" target="_self">etl::lldiv_t</a></td><td class="desc">Return type for div, ldiv, lldiv &amp; imaxdiv </td></tr>
<tr id="row_223_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1local__t.html" target="_self">etl::chrono::local_t</a></td><td class="desc">The class <a class="el" href="structetl_1_1chrono_1_1local__t.html" title="The class local_t is a pseudo-clock that is used as the first template argument to etl::chrono::time_...">local_t</a> is a pseudo-clock that is used as the first template argument to <a class="el" href="structetl_1_1chrono_1_1time__point.html" title="Class template time_point represents a point in time. It is implemented as if it stores a value of ty...">etl::chrono::time_point</a> to indicate that the time point represents local time with respect of a not-yet-specified time zone. local_time supports streaming and the full set of time point arithmetic </td></tr>
<tr id="row_224_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1lock__guard.html" target="_self">etl::lock_guard&lt; MutexT &gt;</a></td><td class="desc">The struct <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> is a mutex wrapper that provides a convenient RAII-style mechanism for owning a mutex for the duration of a scoped block. When a <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> object was created, the <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> is destructed and the mutex is released. The <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> struct is non-copyable </td></tr>
<tr id="row_225_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__and.html" target="_self">etl::logical_and&lt; T &gt;</a></td><td class="desc">Function object for performing logical AND (logical conjunction). Effectively calls operator&amp;&amp; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_and">https://en.cppreference.com/w/cpp/utility/functional/logical_and</a> </td></tr>
<tr id="row_226_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__and_3_01void_01_4.html" target="_self">etl::logical_and&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_227_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__not.html" target="_self">etl::logical_not&lt; T &gt;</a></td><td class="desc">Function object for performing logical NOT (logical negation). Effectively calls operator! for type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_not">https://en.cppreference.com/w/cpp/utility/functional/logical_not</a> </td></tr>
<tr id="row_228_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__not_3_01void_01_4.html" target="_self">etl::logical_not&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_229_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__or.html" target="_self">etl::logical_or&lt; T &gt;</a></td><td class="desc">Function object for performing logical OR (logical disjunction). Effectively calls operator|| on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_or">https://en.cppreference.com/w/cpp/utility/functional/logical_or</a> </td></tr>
<tr id="row_230_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__or_3_01void_01_4.html" target="_self">etl::logical_or&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_231_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1linalg_1_1lower__triangle__t.html" target="_self">etl::linalg::lower_triangle_t</a></td><td class="desc"></td></tr>
<tr id="row_232_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_232_" class="arrow" onclick="toggleFolder('232_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::make_signed&lt; Type &gt;</b></td><td class="desc"></td></tr>
<tr id="row_232_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__signed.html" target="_self">etl::make_signed&lt; Type &gt;</a></td><td class="desc">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__signed.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_signed</a> is undefined </td></tr>
<tr id="row_233_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_233_" class="arrow" onclick="toggleFolder('233_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::make_unsigned&lt; Type &gt;</b></td><td class="desc"></td></tr>
<tr id="row_233_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned.html" target="_self">etl::make_unsigned&lt; Type &gt;</a></td><td class="desc">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__unsigned.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_unsigned</a> is undefined </td></tr>
<tr id="row_234_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1layout__left_1_1mapping.html" target="_self">etl::layout_left::mapping&lt; Extents &gt;</a></td><td class="desc"></td></tr>
<tr id="row_235_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1layout__right_1_1mapping.html" target="_self">etl::layout_right::mapping&lt; Extents &gt;</a></td><td class="desc"></td></tr>
<tr id="row_236_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1layout__stride_1_1mapping.html" target="_self">etl::layout_stride::mapping&lt; Extents &gt;</a></td><td class="desc"></td></tr>
<tr id="row_237_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1max__align__t.html" target="_self">etl::max_align_t</a></td><td class="desc">Etl::max_align_t is a trivial standard-layout type whose alignment requirement is at least as strict (as large) as that of every scalar type </td></tr>
<tr id="row_238_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_238_" class="arrow" onclick="toggleFolder('238_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::maybe_value_type&lt; T &gt;</b></td><td class="desc"></td></tr>
<tr id="row_238_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01_5_01_4.html" target="_self">etl::indirectly_readable_traits&lt; T * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_239_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_239_" class="arrow" onclick="toggleFolder('239_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::maybe_value_type&lt; T::element_type &gt;</b></td><td class="desc"></td></tr>
<tr id="row_239_0_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_239_0_" class="arrow" onclick="toggleFolder('239_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01_4.html" target="_self">etl::indirectly_readable_traits&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_239_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01const_01_4.html" target="_self">etl::indirectly_readable_traits&lt; T const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_240_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_240_" class="arrow" onclick="toggleFolder('240_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::maybe_value_type&lt; T::value_type &gt;</b></td><td class="desc"></td></tr>
<tr id="row_240_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01_4.html" target="_self">etl::indirectly_readable_traits&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_241_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1mdarray.html" target="_self">etl::mdarray&lt; ElementType, Extents, LayoutPolicy, Container &gt;</a></td><td class="desc"></td></tr>
<tr id="row_242_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1mdspan.html" target="_self">etl::mdspan&lt; ElementType, Extents, LayoutPolicy, AccessorPolicy &gt;</a></td><td class="desc"></td></tr>
<tr id="row_243_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1memory__alignment.html" target="_self">etl::experimental::memory_alignment&lt; T, U &gt;</a></td><td class="desc"></td></tr>
<tr id="row_244_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1memory__alignment.html" target="_self">etl::experimental::parallelism_v2::memory_alignment&lt; T, U &gt;</a></td><td class="desc"></td></tr>
<tr id="row_245_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1minus.html" target="_self">etl::minus&lt; T &gt;</a></td><td class="desc">Function object for performing subtraction. Effectively calls operator- on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/minus">https://en.cppreference.com/w/cpp/utility/functional/minus</a> </td></tr>
<tr id="row_246_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1minus_3_01void_01_4.html" target="_self">etl::minus&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_247_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1modulus.html" target="_self">etl::modulus&lt; T &gt;</a></td><td class="desc">Function object for computing remainders of divisions. Implements operator% for type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/modulus">https://en.cppreference.com/w/cpp/utility/functional/modulus</a> </td></tr>
<tr id="row_248_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1modulus_3_01void_01_4.html" target="_self">etl::modulus&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_249_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1monostate.html" target="_self">etl::monostate</a></td><td class="desc">Unit type intended for use as a well-behaved empty alternative in <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>. In particular, a variant of non-default-constructible types may list <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> as its first alternative: this makes the variant itself default-constructible </td></tr>
<tr id="row_250_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1monotonic__allocator.html" target="_self">etl::monotonic_allocator&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_251_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1month.html" target="_self">etl::chrono::month</a></td><td class="desc"></td></tr>
<tr id="row_252_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1month__day.html" target="_self">etl::chrono::month_day</a></td><td class="desc"></td></tr>
<tr id="row_253_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1month__day__last.html" target="_self">etl::chrono::month_day_last</a></td><td class="desc"></td></tr>
<tr id="row_254_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1month__weekday.html" target="_self">etl::chrono::month_weekday</a></td><td class="desc"></td></tr>
<tr id="row_255_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1month__weekday__last.html" target="_self">etl::chrono::month_weekday_last</a></td><td class="desc"></td></tr>
<tr id="row_256_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1multiplies.html" target="_self">etl::multiplies&lt; T &gt;</a></td><td class="desc">Function object for performing multiplication. Effectively calls operator* on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/multiplies">https://en.cppreference.com/w/cpp/utility/functional/multiplies</a> </td></tr>
<tr id="row_257_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1multiplies_3_01void_01_4.html" target="_self">etl::multiplies&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_258_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1net_1_1mutable__buffer.html" target="_self">etl::experimental::net::mutable_buffer</a></td><td class="desc"></td></tr>
<tr id="row_259_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1negate.html" target="_self">etl::negate&lt; T &gt;</a></td><td class="desc">Function object for performing negation. Effectively calls operator- on an instance of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/negate">https://en.cppreference.com/w/cpp/utility/functional/negate</a> </td></tr>
<tr id="row_260_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1negate_3_01void_01_4.html" target="_self">etl::negate&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_261_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1freertos_1_1never.html" target="_self">etl::experimental::freertos::never</a></td><td class="desc">Runs the task loop 0 times </td></tr>
<tr id="row_262_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1nontype__t.html" target="_self">etl::nontype_t&lt; V &gt;</a></td><td class="desc"></td></tr>
<tr id="row_263_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1not__equal__to.html" target="_self">etl::not_equal_to&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator!= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/not_equal_to">https://en.cppreference.com/w/cpp/utility/functional/not_equal_to</a> </td></tr>
<tr id="row_264_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1not__equal__to_3_01void_01_4.html" target="_self">etl::not_equal_to&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_265_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1nothrow__t.html" target="_self">etl::nothrow_t</a></td><td class="desc">Etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing allocation functions </td></tr>
<tr id="row_266_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1nullopt__t.html" target="_self">etl::nullopt_t</a></td><td class="desc">Etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state. In particular, <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a> has a constructor with <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">nullopt_t</a> as a single argument, which creates an optional that does not contain a value </td></tr>
<tr id="row_267_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_267_" class="arrow" onclick="toggleFolder('267_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits.html" target="_self">etl::numeric_limits&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_267_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01T_01const_01_4.html" target="_self">etl::numeric_limits&lt; T const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_267_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01T_01const_01volatile_01_4.html" target="_self">etl::numeric_limits&lt; T const volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_267_2_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01T_01volatile_01_4.html" target="_self">etl::numeric_limits&lt; T volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_268_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01bool_01_4.html" target="_self">etl::numeric_limits&lt; bool &gt;</a></td><td class="desc"></td></tr>
<tr id="row_269_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01char_01_4.html" target="_self">etl::numeric_limits&lt; char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_270_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01char8__t_01_4.html" target="_self">etl::numeric_limits&lt; char8_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_271_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01double_01_4.html" target="_self">etl::numeric_limits&lt; double &gt;</a></td><td class="desc"></td></tr>
<tr id="row_272_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01float_01_4.html" target="_self">etl::numeric_limits&lt; float &gt;</a></td><td class="desc"></td></tr>
<tr id="row_273_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01int_01_4.html" target="_self">etl::numeric_limits&lt; int &gt;</a></td><td class="desc"></td></tr>
<tr id="row_274_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01long_01_4.html" target="_self">etl::numeric_limits&lt; long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_275_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01long_01double_01_4.html" target="_self">etl::numeric_limits&lt; long double &gt;</a></td><td class="desc"></td></tr>
<tr id="row_276_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01short_01_4.html" target="_self">etl::numeric_limits&lt; short &gt;</a></td><td class="desc"></td></tr>
<tr id="row_277_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01signed_01char_01_4.html" target="_self">etl::numeric_limits&lt; signed char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_278_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01char_01_4.html" target="_self">etl::numeric_limits&lt; unsigned char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_279_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01int_01_4.html" target="_self">etl::numeric_limits&lt; unsigned int &gt;</a></td><td class="desc"></td></tr>
<tr id="row_280_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01long_01_4.html" target="_self">etl::numeric_limits&lt; unsigned long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_281_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01short_01_4.html" target="_self">etl::numeric_limits&lt; unsigned short &gt;</a></td><td class="desc"></td></tr>
<tr id="row_282_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1optional_3_01T_01_6_01_4.html" target="_self">etl::optional&lt; T &amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_283_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_283_" class="arrow" onclick="toggleFolder('283_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_destruct_base&lt; T, bool &gt;</b></td><td class="desc"></td></tr>
<tr id="row_283_0_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_283_0_" class="arrow" onclick="toggleFolder('283_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_storage_base&lt; T, bool &gt;</b></td><td class="desc"></td></tr>
<tr id="row_283_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_283_0_0_" class="arrow" onclick="toggleFolder('283_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_copy_base&lt; T, bool &gt;</b></td><td class="desc"></td></tr>
<tr id="row_283_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_283_0_0_0_" class="arrow" onclick="toggleFolder('283_0_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_move_base&lt; T, bool &gt;</b></td><td class="desc"></td></tr>
<tr id="row_283_0_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span id="arr_283_0_0_0_0_" class="arrow" onclick="toggleFolder('283_0_0_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_copy_assign_base&lt; T, bool &gt;</b></td><td class="desc"></td></tr>
<tr id="row_283_0_0_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span id="arr_283_0_0_0_0_0_" class="arrow" onclick="toggleFolder('283_0_0_0_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_move_assign_base&lt; T, bool &gt;</b></td><td class="desc"></td></tr>
<tr id="row_283_0_0_0_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:112px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1optional.html" target="_self">etl::optional&lt; T &gt;</a></td><td class="desc">The class template optional manages an optional contained value, i.e. a value that may or may not be present </td></tr>
<tr id="row_284_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1output__iterator__tag.html" target="_self">etl::output_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_285_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1overaligned__tag.html" target="_self">etl::experimental::overaligned_tag&lt; size_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_286_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1overaligned__tag.html" target="_self">etl::experimental::parallelism_v2::overaligned_tag&lt; size_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_287_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1overaligned__tag.html" target="_self">etl::overaligned_tag&lt; size_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_288_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pair.html" target="_self">etl::pair&lt; T1, T2 &gt;</a></td><td class="desc">Etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a> with two elements. If neither T1 nor T2 is a possibly cv-qualified class type with non-trivial destructor, or array thereof, the destructor of pair is trivial </td></tr>
<tr id="row_289_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bernoulli__distribution_1_1param__type.html" target="_self">etl::bernoulli_distribution::param_type</a></td><td class="desc"></td></tr>
<tr id="row_290_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1uniform__int__distribution_1_1param__type.html" target="_self">etl::uniform_int_distribution&lt; IntType &gt;::param_type</a></td><td class="desc"></td></tr>
<tr id="row_291_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1uniform__real__distribution_1_1param__type.html" target="_self">etl::uniform_real_distribution&lt; RealType &gt;::param_type</a></td><td class="desc"></td></tr>
<tr id="row_292_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1partial__ordering.html" target="_self">etl::partial_ordering</a></td><td class="desc"></td></tr>
<tr id="row_293_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1piecewise__construct__t.html" target="_self">etl::piecewise_construct_t</a></td><td class="desc">Etl::piecewise_construct_t is an empty class tag type used to disambiguate between different functions that take two tuple arguments </td></tr>
<tr id="row_294_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1plus.html" target="_self">etl::plus&lt; T &gt;</a></td><td class="desc">Function object for performing addition. Effectively calls operator+ on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/plus">https://en.cppreference.com/w/cpp/utility/functional/plus</a> </td></tr>
<tr id="row_295_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1plus_3_01void_01_4.html" target="_self">etl::plus&lt; void &gt;</a></td><td class="desc"></td></tr>
<tr id="row_296_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pointer__int__pair.html" target="_self">etl::pointer_int_pair&lt; PointerT, IntBits, IntType, PtrTraits, Info &gt;</a></td><td class="desc">This struct implements a pair of a pointer and small integer. It is designed to represent this in the space required by one pointer by bitmangling the integer into the low part of the pointer. This can only be done for small integers: typically up to 3 bits, but it depends on the number of bits available according to <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for the type </td></tr>
<tr id="row_297_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pointer__int__pair__info.html" target="_self">etl::pointer_int_pair_info&lt; PointerT, IntBits, PtrTraits &gt;</a></td><td class="desc"></td></tr>
<tr id="row_298_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pointer__like__traits.html" target="_self">etl::pointer_like_traits&lt; T &gt;</a></td><td class="desc">A traits type that is used to handle pointer types and things that are just wrappers for pointers as a uniform entity </td></tr>
<tr id="row_299_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pointer__like__traits_3_01pointer__int__pair_3_01PtrT_00_01IntBits_00_01IntT_00_01PtrTraits_01_4_01_4.html" target="_self">etl::pointer_like_traits&lt; pointer_int_pair&lt; PtrT, IntBits, IntT, PtrTraits &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_300_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01_5_01_4.html" target="_self">etl::pointer_like_traits&lt; T * &gt;</a></td><td class="desc">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for non-cvr pointers </td></tr>
<tr id="row_301_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01const_01_5_01_4.html" target="_self">etl::pointer_like_traits&lt; T const * &gt;</a></td><td class="desc">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for const pointers </td></tr>
<tr id="row_302_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01const_01_4.html" target="_self">etl::pointer_like_traits&lt; T const &gt;</a></td><td class="desc">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for const things </td></tr>
<tr id="row_303_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pointer__like__traits_3_01uintptr__t_01_4.html" target="_self">etl::pointer_like_traits&lt; uintptr_t &gt;</a></td><td class="desc">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for uintptr_t </td></tr>
<tr id="row_304_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pointer__traits.html" target="_self">etl::pointer_traits&lt; Ptr &gt;</a></td><td class="desc">The <a class="el" href="structetl_1_1pointer__traits.html" title="The pointer_traits class template provides the standardized way to access certain properties of point...">pointer_traits</a> class template provides the standardized way to access certain properties of pointer-like types </td></tr>
<tr id="row_305_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pointer__traits_3_01T_01_5_01_4.html" target="_self">etl::pointer_traits&lt; T * &gt;</a></td><td class="desc">The <a class="el" href="structetl_1_1pointer__traits.html" title="The pointer_traits class template provides the standardized way to access certain properties of point...">pointer_traits</a> class template provides the standardized way to access certain properties of pointer-like types. <a href="https://en.cppreference.com/w/cpp/memory/pointer_traits">https://en.cppreference.com/w/cpp/memory/pointer_traits</a> </td></tr>
<tr id="row_306_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1hardware_1_1stm32_1_1port.html" target="_self">etl::experimental::hardware::stm32::port</a></td><td class="desc"></td></tr>
<tr id="row_307_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1push__back.html" target="_self">etl::meta::push_back&lt; T, List &gt;</a></td><td class="desc"></td></tr>
<tr id="row_308_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1push__back_3_01T_00_01list_3_01Ts_8_8_8_01_4_01_4.html" target="_self">etl::meta::push_back&lt; T, list&lt; Ts... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_309_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1push__front.html" target="_self">etl::meta::push_front&lt; T, List &gt;</a></td><td class="desc"></td></tr>
<tr id="row_310_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1push__front_3_01T_00_01list_3_01Ts_8_8_8_01_4_01_4.html" target="_self">etl::meta::push_front&lt; T, list&lt; Ts... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_311_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1freertos_1_1queue.html" target="_self">etl::experimental::freertos::queue&lt; T, Size &gt;</a></td><td class="desc">Wrapper around a FreeRTOS queue </td></tr>
<tr id="row_312_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio.html" target="_self">etl::ratio&lt; Num, Denom &gt;</a></td><td class="desc">The typename template provides compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number as long as its numerator Num and denominator Denom are representable as compile-time constants of type intmax_t </td></tr>
<tr id="row_313_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1rebind__simd.html" target="_self">etl::experimental::parallelism_v2::rebind_simd&lt; T, V &gt;</a></td><td class="desc"></td></tr>
<tr id="row_314_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1rebind__simd.html" target="_self">etl::experimental::rebind_simd&lt; T, V &gt;</a></td><td class="desc"></td></tr>
<tr id="row_315_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bitset_1_1reference.html" target="_self">etl::bitset&lt; N &gt;::reference</a></td><td class="desc">The primary use of <a class="el" href="structetl_1_1bitset_1_1reference.html" title="The primary use of etl::bitset::reference is to provide an l-value that can be returned from operator...">etl::bitset::reference</a> is to provide an l-value that can be returned from operator[] </td></tr>
<tr id="row_316_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1reference__wrapper.html" target="_self">etl::reference_wrapper&lt; T &gt;</a></td><td class="desc">Reference_wrapper is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">etl::static_vector</a>) which cannot normally hold references. Specifically, <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is a CopyConstructible and CopyAssignable wrapper around a reference to object or reference to function of type T. Instances of <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> are objects (they can be copied or stored in containers) but they are implicitly convertible to T&amp;, so that they can be used as arguments with the functions that take the underlying type by reference. If the stored reference is Callable, <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is callable with the same arguments </td></tr>
<tr id="row_317_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__all__extents.html" target="_self">etl::remove_all_extents&lt; T &gt;</a></td><td class="desc">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X,...">remove_all_extents</a> is undefined </td></tr>
<tr id="row_318_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__all__extents_3_01T_0f_0e_4.html" target="_self">etl::remove_all_extents&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_319_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__all__extents_3_01T_0fN_0e_4.html" target="_self">etl::remove_all_extents&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_320_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__const.html" target="_self">etl::remove_const&lt; Type &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const </td></tr>
<tr id="row_321_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__const_3_01Type_01const_01_4.html" target="_self">etl::remove_const&lt; Type const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_322_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__cv.html" target="_self">etl::remove_cv&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const, or the topmost volatile, or both, if present </td></tr>
<tr id="row_323_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__cvref.html" target="_self">etl::remove_cvref&lt; T &gt;</a></td><td class="desc">If the type T is a reference type, provides the member typedef type which is the type referred to by T with its topmost cv-qualifiers removed. Otherwise type is T with its topmost cv-qualifiers removed </td></tr>
<tr id="row_324_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__extent.html" target="_self">etl::remove_extent&lt; T &gt;</a></td><td class="desc">If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__extent.html" title="If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T....">remove_extent</a> is undefined </td></tr>
<tr id="row_325_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__extent_3_01T_0f_0e_4.html" target="_self">etl::remove_extent&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_326_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__extent_3_01T_0fN_0e_4.html" target="_self">etl::remove_extent&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_327_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__pointer.html" target="_self">etl::remove_pointer&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer, then type is the same as T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__pointer.html" title="Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer,...">remove_pointer</a> is undefined </td></tr>
<tr id="row_328_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5_01_4.html" target="_self">etl::remove_pointer&lt; T * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_329_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01_4.html" target="_self">etl::remove_pointer&lt; T *const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_330_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01volatile_01_4.html" target="_self">etl::remove_pointer&lt; T *const volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_331_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5volatile_01_4.html" target="_self">etl::remove_pointer&lt; T *volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_332_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__reference.html" target="_self">etl::remove_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_333_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_01_4.html" target="_self">etl::remove_reference&lt; T &amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_334_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_6_01_4.html" target="_self">etl::remove_reference&lt; T &amp;&amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_335_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__volatile.html" target="_self">etl::remove_volatile&lt; Type &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost volatile </td></tr>
<tr id="row_336_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__volatile_3_01Type_01volatile_01_4.html" target="_self">etl::remove_volatile&lt; Type volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_337_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1resize__simd.html" target="_self">etl::experimental::parallelism_v2::resize_simd&lt; N, V &gt;</a></td><td class="desc"></td></tr>
<tr id="row_338_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1resize__simd.html" target="_self">etl::experimental::resize_simd&lt; N, V &gt;</a></td><td class="desc"></td></tr>
<tr id="row_339_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1reverse__iterator.html" target="_self">etl::reverse_iterator&lt; Iter &gt;</a></td><td class="desc">Reverse_iterator is an iterator adaptor that reverses the direction of a given iterator. In other words, when provided with a bidirectional iterator, <code><a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">reverse_iterator</a></code> produces a new iterator that moves from the end to the beginning of the sequence defined by the underlying bidirectional iterator. This is the iterator returned by member functions <code><a class="el" href="namespaceetl.html#a31aadf1fc327da2eaac11d7e6e8617a8" title="Returns an iterator to the reverse-beginning of the given container.">rbegin()</a></code> and <code><a class="el" href="namespaceetl.html#a3db12aaf2a7b1819d28995d635d91954" title="Returns an iterator to the reverse-end of the given container.">rend()</a></code> of the standard library containers </td></tr>
<tr id="row_340_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1linalg_1_1row__major__t.html" target="_self">etl::linalg::row_major_t</a></td><td class="desc"></td></tr>
<tr id="row_341_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_341_" class="arrow" onclick="toggleFolder('341_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::scope_guard&lt; FuncT, detail::scope_exit_impl &gt;</b></td><td class="desc"></td></tr>
<tr id="row_341_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1scope__exit.html" target="_self">etl::scope_exit&lt; FuncT &gt;</a></td><td class="desc">The class template <code><a class="el" href="structetl_1_1scope__exit.html" title="The class template scope_exit is a general-purpose scope guard intended to call its exit function whe...">scope_exit</a></code> is a general-purpose scope guard intended to call its exit function when a scope is exited </td></tr>
<tr id="row_342_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_342_" class="arrow" onclick="toggleFolder('342_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::sfinae_assign_base&lt; CanCopy, CanMove &gt;</b></td><td class="desc"></td></tr>
<tr id="row_342_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1optional.html" target="_self">etl::optional&lt; T &gt;</a></td><td class="desc">The class template optional manages an optional contained value, i.e. a value that may or may not be present </td></tr>
<tr id="row_343_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_343_" class="arrow" onclick="toggleFolder('343_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::sfinae_ctor_base&lt; CanCopy, CanMove &gt;</b></td><td class="desc"></td></tr>
<tr id="row_343_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1optional.html" target="_self">etl::optional&lt; T &gt;</a></td><td class="desc">The class template optional manages an optional contained value, i.e. a value that may or may not be present </td></tr>
<tr id="row_344_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1simd.html" target="_self">etl::experimental::parallelism_v2::simd&lt; T, Abi &gt;</a></td><td class="desc"></td></tr>
<tr id="row_345_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1simd.html" target="_self">etl::experimental::simd&lt; T, Abi &gt;</a></td><td class="desc"></td></tr>
<tr id="row_346_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1simd__mask.html" target="_self">etl::experimental::parallelism_v2::simd_mask&lt; T, Abi &gt;</a></td><td class="desc"></td></tr>
<tr id="row_347_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1simd__mask.html" target="_self">etl::experimental::simd_mask&lt; T, Abi &gt;</a></td><td class="desc"></td></tr>
<tr id="row_348_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1simd__size.html" target="_self">etl::experimental::parallelism_v2::simd_size&lt; T, Abi &gt;</a></td><td class="desc"></td></tr>
<tr id="row_349_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1simd__size.html" target="_self">etl::experimental::simd_size&lt; T, Abi &gt;</a></td><td class="desc"></td></tr>
<tr id="row_350_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1small__ptr.html" target="_self">etl::small_ptr&lt; Type, BaseAddress, StorageType &gt;</a></td><td class="desc">Compressed pointer to specified size. Intended to be used as a drop in replacement for native pointers </td></tr>
<tr id="row_351_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1sorted__unique__t.html" target="_self">etl::sorted_unique_t</a></td><td class="desc"></td></tr>
<tr id="row_352_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1span.html" target="_self">etl::span&lt; ElementType, Extent &gt;</a></td><td class="desc">A non-owning view over a contiguous sequence of objects </td></tr>
<tr id="row_353_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1span.html" target="_self">etl::span&lt; etl::basic_format_arg&lt; Context &gt; const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_354_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1span.html" target="_self">etl::span&lt; etl::byte &gt;</a></td><td class="desc"></td></tr>
<tr id="row_355_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1stack.html" target="_self">etl::stack&lt; T, Container &gt;</a></td><td class="desc">The stack class is a container adapter that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure </td></tr>
<tr id="row_356_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1static__set.html" target="_self">etl::static_set&lt; Key, Capacity, Compare &gt;</a></td><td class="desc">Static_set is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare </td></tr>
<tr id="row_357_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_357_" class="arrow" onclick="toggleFolder('357_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>detail::static_vector_storage_type</b></td><td class="desc"></td></tr>
<tr id="row_357_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1static__vector.html" target="_self">etl::static_vector&lt; Key, Capacity &gt;</a></td><td class="desc"></td></tr>
<tr id="row_357_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1static__vector.html" target="_self">etl::static_vector&lt; T, Capacity &gt;</a></td><td class="desc">Dynamically-resizable fixed-capacity vector </td></tr>
<tr id="row_358_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1freertos_1_1stream__buffer.html" target="_self">etl::experimental::freertos::stream_buffer</a></td><td class="desc">Stream buffers are an RTOS task to RTOS task, and interrupt to task communication primitives. Unlike most other FreeRTOS communications primitives, they are optimised for single reader single writer scenarios, such as passing data from an interrupt service routine to a task, or from one microcontroller core to another on dual core CPUs. Data is passed by copy - the data is copied into the buffer by the sender and out of the buffer by the read </td></tr>
<tr id="row_359_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1strided__slice.html" target="_self">etl::strided_slice&lt; OffsetType, ExtentType, StrideType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_360_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1string__constant.html" target="_self">etl::string_constant&lt; CharT, Chars &gt;</a></td><td class="desc"></td></tr>
<tr id="row_361_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1strong__ordering.html" target="_self">etl::strong_ordering</a></td><td class="desc"></td></tr>
<tr id="row_362_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1submdspan__mapping__result.html" target="_self">etl::submdspan_mapping_result&lt; LayoutMapping &gt;</a></td><td class="desc"></td></tr>
<tr id="row_363_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1system__clock.html" target="_self">etl::chrono::system_clock</a></td><td class="desc"></td></tr>
<tr id="row_364_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1tail.html" target="_self">etl::meta::tail&lt; Ts &gt;</a></td><td class="desc"></td></tr>
<tr id="row_365_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1meta_1_1tail_3_01list_3_01Head_00_01Tail_8_8_8_01_4_01_4.html" target="_self">etl::meta::tail&lt; list&lt; Head, Tail... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_366_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1time__point.html" target="_self">etl::chrono::time_point&lt; Clock, Duration &gt;</a></td><td class="desc">Class template <a class="el" href="structetl_1_1chrono_1_1time__point.html" title="Class template time_point represents a point in time. It is implemented as if it stores a value of ty...">time_point</a> represents a point in time. It is implemented as if it stores a value of type Duration indicating the time interval from the start of the Clock's epoch </td></tr>
<tr id="row_367_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1freertos_1_1times.html" target="_self">etl::experimental::freertos::times&lt; Count &gt;</a></td><td class="desc">Runs the task loop Count times </td></tr>
<tr id="row_368_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1timespec.html" target="_self">etl::timespec</a></td><td class="desc"></td></tr>
<tr id="row_369_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tm.html" target="_self">etl::tm</a></td><td class="desc"></td></tr>
<tr id="row_370_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1to__chars__result.html" target="_self">etl::to_chars_result</a></td><td class="desc">Primitive numerical output conversion </td></tr>
<tr id="row_371_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_371_" class="arrow" onclick="toggleFolder('371_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>decltypeetl::detail::try_add_lvalue_reference</b></td><td class="desc"></td></tr>
<tr id="row_371_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__lvalue__reference.html" target="_self">etl::add_lvalue_reference&lt; T &gt;</a></td><td class="desc">Creates a lvalue reference type of T </td></tr>
<tr id="row_372_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_372_" class="arrow" onclick="toggleFolder('372_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>decltypeetl::detail::try_add_pointer</b></td><td class="desc"></td></tr>
<tr id="row_372_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__pointer.html" target="_self">etl::add_pointer&lt; T &gt;</a></td><td class="desc">If T is a reference type, then provides the member typedef type which is a pointer to the referred type. Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef type which is the type T*. Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef type which is the type T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1add__pointer.html" title="If T is a reference type, then provides the member typedef type which is a pointer to the referred ty...">add_pointer</a> is undefined </td></tr>
<tr id="row_373_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_373_" class="arrow" onclick="toggleFolder('373_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>decltypeetl::detail::try_add_rvalue_reference</b></td><td class="desc"></td></tr>
<tr id="row_373_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__rvalue__reference.html" target="_self">etl::add_rvalue_reference&lt; T &gt;</a></td><td class="desc">Creates a rvalue reference type of T </td></tr>
<tr id="row_374_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1try__to__lock__t.html" target="_self">etl::try_to_lock_t</a></td><td class="desc">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock </td></tr>
<tr id="row_375_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple.html" target="_self">etl::tuple&lt; Ts &gt;</a></td><td class="desc"></td></tr>
<tr id="row_376_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__element.html" target="_self">etl::tuple_element&lt; I, T &gt;</a></td><td class="desc">Provides compile-time indexed access to the type of the elements of the array using tuple-like interface </td></tr>
<tr id="row_377_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__element_3_01I_00_01array_3_01T_00_01N_01_4_01_4.html" target="_self">etl::tuple_element&lt; I, array&lt; T, N &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_378_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__element_3_01I_00_01pair_3_01T1_00_01T2_01_4_01_4.html" target="_self">etl::tuple_element&lt; I, pair&lt; T1, T2 &gt; &gt;</a></td><td class="desc">The partial specializations of <a class="el" href="structetl_1_1tuple__element.html" title="Provides compile-time indexed access to the type of the elements of the array using tuple-like interf...">tuple_element</a> for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if I &gt;= 2 </td></tr>
<tr id="row_379_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01const_01_4.html" target="_self">etl::tuple_element&lt; I, T const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_380_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01const_01volatile_01_4.html" target="_self">etl::tuple_element&lt; I, T const volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_381_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01volatile_01_4.html" target="_self">etl::tuple_element&lt; I, T volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_382_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__element_3_01I_00_01tuple_3_01Ts_8_8_8_01_4_01_4.html" target="_self">etl::tuple_element&lt; I, tuple&lt; Ts... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_383_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size.html" target="_self">etl::tuple_size&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_384_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_384_" class="arrow" onclick="toggleFolder('384_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>detail::is_nothrow_constructible_helper::type</b></td><td class="desc"></td></tr>
<tr id="row_384_0_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_384_0_" class="arrow" onclick="toggleFolder('384_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__constructible.html" target="_self">etl::is_nothrow_constructible&lt; T, add_rvalue_reference_t&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_384_0_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__move__constructible.html" target="_self">etl::is_nothrow_move_constructible&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</a> </td></tr>
<tr id="row_384_1_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_384_1_" class="arrow" onclick="toggleFolder('384_1_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__constructible.html" target="_self">etl::is_nothrow_constructible&lt; T, add_lvalue_reference_t&lt; add_const_t&lt; T &gt; &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_384_1_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__copy__constructible.html" target="_self">etl::is_nothrow_copy_constructible&lt; T &gt;</a></td><td class="desc">Same as copy, but uses etl::is_nothrow_constructible&lt;T, T const&amp;&gt; </td></tr>
<tr id="row_384_2_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_384_2_" class="arrow" onclick="toggleFolder('384_2_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__constructible.html" target="_self">etl::is_nothrow_constructible&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_384_2_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__default__constructible.html" target="_self">etl::is_nothrow_default_constructible&lt; T &gt;</a></td><td class="desc">If <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false </td></tr>
<tr id="row_385_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_385_" class="arrow" onclick="toggleFolder('385_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>detail::is_unsigned::type</b></td><td class="desc"></td></tr>
<tr id="row_385_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__unsigned.html" target="_self">etl::is_unsigned&lt; T &gt;</a></td><td class="desc">If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__unsigned.html" title="If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this re...">is_unsigned</a> or is_unsigned_v (since C++17) is undefined </td></tr>
<tr id="row_385_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__unsigned_3_01T_01const_01_4.html" target="_self">etl::is_unsigned&lt; T const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_385_2_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__unsigned_3_01T_01const_01volatile_01_4.html" target="_self">etl::is_unsigned&lt; T const volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_385_3_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__unsigned_3_01T_01volatile_01_4.html" target="_self">etl::is_unsigned&lt; T volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_386_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1aligned__storage_1_1type.html" target="_self">etl::aligned_storage&lt; Len, Align &gt;::type</a></td><td class="desc"></td></tr>
<tr id="row_387_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1aligned__union_1_1type.html" target="_self">etl::aligned_union&lt; Len, Types &gt;::type</a></td><td class="desc"></td></tr>
<tr id="row_388_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_388_" class="arrow" onclick="toggleFolder('388_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>is_nothrow_swappable_with::type</b></td><td class="desc"></td></tr>
<tr id="row_388_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__swappable.html" target="_self">etl::is_nothrow_swappable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_swappable_with&lt;T&amp;, T&amp;&gt;::value</a> </td></tr>
<tr id="row_389_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_389_" class="arrow" onclick="toggleFolder('389_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>is_placeholder::type</b></td><td class="desc"></td></tr>
<tr id="row_389_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__placeholder_3_01T_01const_01_4.html" target="_self">etl::is_placeholder&lt; T const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_389_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__placeholder_3_01T_01const_01volatile_01_4.html" target="_self">etl::is_placeholder&lt; T const volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_389_2_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__placeholder_3_01T_01volatile_01_4.html" target="_self">etl::is_placeholder&lt; T volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_390_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_390_" class="arrow" onclick="toggleFolder('390_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>is_swappable_with::type</b></td><td class="desc"></td></tr>
<tr id="row_390_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__swappable.html" target="_self">etl::is_swappable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_swappable_with&lt;T&amp;, T&amp;&gt;::value</a> </td></tr>
<tr id="row_391_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_391_" class="arrow" onclick="toggleFolder('391_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>variant_size::type</b></td><td class="desc"></td></tr>
<tr id="row_391_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__size_3_01T_01const_01_4.html" target="_self">etl::variant_size&lt; T const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_391_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__size_3_01T_01const_01volatile_01_4.html" target="_self">etl::variant_size&lt; T const volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_391_2_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__size_3_01T_01volatile_01_4.html" target="_self">etl::variant_size&lt; T volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_392_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1type__identity.html" target="_self">etl::type_identity&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_393_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_393_" class="arrow" onclick="toggleFolder('393_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::underlying_type&lt; T &gt;</b></td><td class="desc"></td></tr>
<tr id="row_393_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1underlying__type.html" target="_self">etl::underlying_type&lt; T &gt;</a></td><td class="desc">The underlying type of an enum </td></tr>
<tr id="row_394_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1unexpect__t.html" target="_self">etl::unexpect_t</a></td><td class="desc"></td></tr>
<tr id="row_395_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1unexpected.html" target="_self">etl::unexpected&lt; E &gt;</a></td><td class="desc"></td></tr>
<tr id="row_396_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1uniform__int__distribution.html" target="_self">etl::uniform_int_distribution&lt; IntType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_397_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1uniform__real__distribution.html" target="_self">etl::uniform_real_distribution&lt; RealType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_398_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1uninitialized__array.html" target="_self">etl::uninitialized_array&lt; T, Size &gt;</a></td><td class="desc"></td></tr>
<tr id="row_399_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1uninitialized__array.html" target="_self">etl::uninitialized_array&lt; T, Capacity &gt;</a></td><td class="desc"></td></tr>
<tr id="row_400_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1uninitialized__union.html" target="_self">etl::uninitialized_union</a></td><td class="desc"></td></tr>
<tr id="row_401_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1unique__lock.html" target="_self">etl::unique_lock&lt; Mutex &gt;</a></td><td class="desc">The struct <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">unique_lock</a> is a general-purpose mutex ownership wrapper allowing deferred locking, time-constrained attempts at locking, recursive locking, transfer of lock ownership, and use with condition variables </td></tr>
<tr id="row_402_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1unwrap__reference.html" target="_self">etl::unwrap_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_403_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1unwrap__reference_3_01etl_1_1reference__wrapper_3_01T_01_4_01_4.html" target="_self">etl::unwrap_reference&lt; etl::reference_wrapper&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_404_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1linalg_1_1upper__triangle__t.html" target="_self">etl::linalg::upper_triangle_t</a></td><td class="desc"></td></tr>
<tr id="row_405_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="unionetl_1_1variadic__union.html" target="_self">etl::variadic_union&lt; Ts &gt;</a></td><td class="desc"></td></tr>
<tr id="row_406_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="unionetl_1_1variadic__union_3_01T_00_01Ts_8_8_8_01_4.html" target="_self">etl::variadic_union&lt; T, Ts... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_407_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="unionetl_1_1variadic__union.html" target="_self">etl::variadic_union&lt; Ts... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_408_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant.html" target="_self">etl::variant&lt; Ts &gt;</a></td><td class="desc">The class template variant represents a type-safe union. An instance of variant at any given time either holds a value of one of its alternative types </td></tr>
<tr id="row_409_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant2.html" target="_self">etl::variant2&lt; Ts &gt;</a></td><td class="desc"></td></tr>
<tr id="row_410_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant.html" target="_self">etl::variant&lt; etl::monostate, bool, char_type, int, unsigned int, long long int, unsigned long long int, float, double, long double, char_type const *, etl::basic_string_view&lt; char_type &gt;, void const *, etl::basic_format_arg::handle &gt;</a></td><td class="desc"></td></tr>
<tr id="row_411_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant.html" target="_self">etl::variant&lt; T, E &gt;</a></td><td class="desc"></td></tr>
<tr id="row_412_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__alternative.html" target="_self">etl::variant_alternative&lt; I, T &gt;</a></td><td class="desc">Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative </td></tr>
<tr id="row_413_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01etl_1_1variant2_3_01Ts_8_8_8_01_4_01_4.html" target="_self">etl::variant_alternative&lt; Idx, etl::variant2&lt; Ts... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_414_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01etl_1_1variant_3_01Ts_8_8_8_01_4_01_4.html" target="_self">etl::variant_alternative&lt; Idx, etl::variant&lt; Ts... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_415_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01const_01_4.html" target="_self">etl::variant_alternative&lt; Idx, T const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_416_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01const_01volatile_01_4.html" target="_self">etl::variant_alternative&lt; Idx, T const volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_417_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01volatile_01_4.html" target="_self">etl::variant_alternative&lt; Idx, T volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_418_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__size.html" target="_self">etl::variant_size&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_419_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1vector.html" target="_self">etl::vector&lt; T, Allocator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_420_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1vector__aligned__tag.html" target="_self">etl::experimental::parallelism_v2::vector_aligned_tag</a></td><td class="desc"></td></tr>
<tr id="row_421_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1vector__aligned__tag.html" target="_self">etl::experimental::vector_aligned_tag</a></td><td class="desc"></td></tr>
<tr id="row_422_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1vector__aligned__tag.html" target="_self">etl::vector_aligned_tag</a></td><td class="desc"></td></tr>
<tr id="row_423_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1weak__ordering.html" target="_self">etl::weak_ordering</a></td><td class="desc"></td></tr>
<tr id="row_424_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1weekday.html" target="_self">etl::chrono::weekday</a></td><td class="desc"></td></tr>
<tr id="row_425_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1weekday__indexed.html" target="_self">etl::chrono::weekday_indexed</a></td><td class="desc"></td></tr>
<tr id="row_426_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1weekday__last.html" target="_self">etl::chrono::weekday_last</a></td><td class="desc"></td></tr>
<tr id="row_427_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1where__expression.html" target="_self">etl::experimental::parallelism_v2::where_expression&lt; M, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_428_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1parallelism__v2_1_1where__expression.html" target="_self">etl::experimental::where_expression&lt; M, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_429_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1xorshift.html" target="_self">etl::xorshift&lt; UInt, X, Y, Z &gt;</a></td><td class="desc"></td></tr>
<tr id="row_430_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1xoshiro128plus.html" target="_self">etl::xoshiro128plus</a></td><td class="desc"></td></tr>
<tr id="row_431_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1xoshiro128plusplus.html" target="_self">etl::xoshiro128plusplus</a></td><td class="desc"></td></tr>
<tr id="row_432_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1xoshiro128starstar.html" target="_self">etl::xoshiro128starstar</a></td><td class="desc"></td></tr>
<tr id="row_433_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1year.html" target="_self">etl::chrono::year</a></td><td class="desc"></td></tr>
<tr id="row_434_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1year__month.html" target="_self">etl::chrono::year_month</a></td><td class="desc"></td></tr>
<tr id="row_435_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1year__month__day.html" target="_self">etl::chrono::year_month_day</a></td><td class="desc"></td></tr>
<tr id="row_436_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1year__month__day__last.html" target="_self">etl::chrono::year_month_day_last</a></td><td class="desc"></td></tr>
<tr id="row_437_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1year__month__weekday.html" target="_self">etl::chrono::year_month_weekday</a></td><td class="desc"></td></tr>
<tr id="row_438_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1year__month__weekday__last.html" target="_self">etl::chrono::year_month_weekday_last</a></td><td class="desc"></td></tr>
<tr id="row_439_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_439_" class="arrow" onclick="toggleFolder('439_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::Functor</b></td><td class="desc"></td></tr>
<tr id="row_439_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1overload.html" target="_self">etl::overload&lt; Functor &gt;</a></td><td class="desc"></td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
